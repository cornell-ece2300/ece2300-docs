{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ECE 2300 Digital Logic and Computer Organization","text":"<p>Public Course Website: http://www.csl.cornell.edu/courses/ece2300</p> <p>This is the ECE 2300 Digital Logic and Computer Organization documentation site. It includes topic notes, discussion section handouts, tutorials, and lab assignment handouts. If you find any bugs or errors with this documentation, please post on Ed or feel free to create a pull request in the corresponding documentation repo.</p>"},{"location":"ece2300-fpga-primer/","title":"FPGA Development Primer","text":"<p>Before jumping into Lab 1, it's important to understand the tools we'll be working with. All lab assignments will include an FPGA component, where you'll emulate your design. FPGAs (short for Field Programmable Gate Arrays) are a special type of hardware that can be configured to represent any digital logic function. When we configure an FPGA to represent a specific piece of hardware, the FPGA is emulating our design, and will perform the same logic functions. Because of this, FPGAs are used extensively for early prototyping of designs; since they are actual hardware, they can run much faster than simulations and without forcing a designer to fabricate their design. In this primer, we'll become familiar with using FPGAs by emulating a design from lecture.</p>"},{"location":"ece2300-fpga-primer/#1-setting-up-a-quartus-project","title":"1. Setting up a Quartus Project","text":"<p>FPGAs often come with development environments. These environments are large pieces of software that help get your design from a hardware description language to something that can be configured on the FPGA. This includes:</p> <ul> <li>Determining what resources are needed to represent your design (known    as synthesis). An example of this would be determining that your    design needs 3 AND gates and 2 OR gates.</li> <li>Placing your design - determining which FPGA resources will be    used to represent your design</li> <li>Routing the different logic components together to represent your    design</li> </ul> <p>For this class, we will be using Quartus Prime (\"Quartus\") development environment. Quartus is installed on all lab machines, and will be used during the FPGA portions of lab assignments to put your  design on the FPGA.</p>"},{"location":"ece2300-fpga-primer/#11-creating-a-new-quartus-project","title":"1.1. Creating a New Quartus Project","text":"<p>First, let's use Quartus to create our project. To start Quartus,  double-click on the Quartus Prime icon on the Desktop of a lab machine:</p> <p></p> <p>Quartus Start-Up</p> <p>You may see the following prompt when starting Quartus:  Select \"Run the Quartus Prime software\", then click OK. We've found that Quartus often quits the first time after this, so you may need to re-open the application.</p> <p>After starting Quartus, go to File -&gt; New Project Wizard. This will start an interactive prompt menu to help create your project. In the menu:</p> <ul> <li>Directory, Name, Top-Level Entity:<ul> <li>Using the file searcher, create a new directory for your project   in your Documents. Name it <code>lab1-primer</code>. Select this as the    \"working directory\" for your project - the path should look like   <code>C:/Users/netid/Documents/lab1-primer</code></li> <li>Name your project <code>lab1-primer</code> by typing in the appropriate field.   The \"top-level design entity\" should be automatically filled    appropriately</li> <li>Click Next </li> </ul> </li> </ul> <p>Incorrect Folder</p> <p>If Quartus gives an error that it can't create the project, make sure that you're creating the project in your <code>Documents</code> folder. Quartus will give a default location of its installation folder - make sure to change this.</p> <ul> <li>Project Type:<ul> <li>Select \"Empty Project</li> <li>Click Next </li> </ul> </li> <li>Add Files:<ul> <li>Skip this for now; we'll add our design files later</li> <li>Click Next</li> </ul> </li> <li>Family, Device &amp; Board Settings:<ul> <li>Switch to the Board tab:</li> <li>Make sure \"Family\" is set to Cyclone V and \"Development Kit\" is      set to Any</li> <li>Select DE0-CV Development Board (this is the FPGA board for the      class)</li> <li>Make sure \"Create top-level design file\" is checked</li> <li>Click Next </li> </ul> </li> <li>EDA Tool Settings:<ul> <li>Skip this section for now. These are extra tools that can be used   to analyze your design, but we won't be using them</li> <li>Click Next</li> </ul> </li> <li>Summary:<ul> <li>Click Finish to finish creating your project</li> </ul> </li> </ul> <p>Wait for Quartus to set up your project. After that, you'll be left with a blank project to work on and configure as we wish.</p>"},{"location":"ece2300-fpga-primer/#12-the-top-level-module","title":"1.2. The Top-Level Module","text":"<p>One of the hardest parts of working with FPGAs is making sure that the development environment knows how to map your design to the physical pins on the board. Luckily, Quartus was able to do this for us - when we selected \"Create top-level design file\", Quartus automatically created a template module, and hooked up all of the pins correctly in its configuration. This module is now the top-level module; it is the module that will actually be put on the board. If we want to create any extra logic, it must be contained within this module.</p> <p>To see what this module looks like, go to the Project Navigator, and change the entities from Hierarchy to Files. You should see a file named <code>DE0_CV_golden_top.v</code>; this is the file where our top-level module was generated. Double-click the listing to open the file in Quartus.</p> <p>Missing Top-Level File</p> <p>If this file is missing, you may not have selected the DE0-CV  Development Board, or may not have checked \"Create top-level design file\" when creating your project.</p> <p>The module should look very similar to Verilog modules that you've seen in lecture, although with many inputs and outputs. These represent all of the possible inputs and outputs of our FPGA hardware. We won't use all of these right now, but will instead focus on two signals in particular:</p> <ul> <li><code>SW</code>: The physical switches on the board. These are a logical <code>1</code> or           <code>0</code> depending on whether the switch is up or down, respectively.          These are coming into our FPGA hardware, and are therefore           inputs to the top-level module.</li> <li><code>LEDR</code>: The (red) LEDs on the board. These are \"on\" or \"off\" depending            on whether our logic sets them to a <code>1</code> or <code>0</code>, respectively.            These are going out of our FPGA hardware, and are therefore            outputs of the top-level module.</li> </ul> <p>These signals are arrays; they represent a collection of multiple wires. You can access an individual signal using the bracket notation, similar to many programming languages. For example, if you wanted to set the 0th LED (the first one in the array, starting at 0) to the logical AND of the 0th and 1st switches, you might write</p> <pre><code>and(LEDR[0], SW[0], SW[1]);\n</code></pre> <p>Let's make a module so that we can perform logic with our switch and LED signals!</p>"},{"location":"ece2300-fpga-primer/#2-integrating-a-hardware-design-into-quartus","title":"2. Integrating a Hardware Design into Quartus","text":"<p>In this section, we'll add logic corresponding to the following gate-level network:</p> <p></p> <p>Code Re-Use</p> <p>This gate-level network should look familiar; we used this in Section 2. Feel free to re-use your code from then; if you haven't already, make sure to try out the Boolean Equations, as we'll be using them in Lab 1 and beyond.</p> <p>To add our own logic, we'll create a new module, and instantiate it within our top-level module. It's good practice to have only one module in a file (with the filename being the same as the name of the module it contains), so let's first add a new file to our project</p>"},{"location":"ece2300-fpga-primer/#21-implementing-hardware-directly-within-quartus","title":"2.1. Implementing Hardware Directly within Quartus","text":"<p>To create a new file within your Quartus project:</p> <ul> <li>Go to File -&gt; New</li> <li>Click on Verilog HDL File, then select OK</li> <li>You should now see a blank Verilog file. Go to File -&gt; Save As, and    save this file as <code>PairTripleDetector_GL.v</code> within your <code>lab1-primer</code>     directory</li> </ul> <p>We now have a new Verilog file that's included as part of our design -  from here, we can add or new logic inside of it</p> <p>Existing Files</p> <p>For this primer, we'll be creating and editing our design files directly within Quartus. However, this won't be the case for the labs, where you will be downloading and using the design you've already simulated/tested on <code>ecelinux</code>. Later on, when you wish to add files that already exist, you can do so by going to  Project -&gt; Add/Remove Files in Project</p> <p>When we add new blocks of logic, we want to add them as modules. This involves first creating the module, and then instantiating it wherever we want that logic.</p> <p>First, let's define our module. In <code>PairTripleDetector_GL.v</code>, define a module named <code>PairTripleDetector_GL</code> that represents the gate-level network above,  exactly as done in section.</p> <pre><code>module PairTripleDetector_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  ...\n\nendmodule\n</code></pre> <p>Make sure that it has three inputs (<code>in0</code>, <code>in1</code>, and <code>in2</code>), and one output (<code>out</code>). Make sure that it contains the logic to implement the gate-level network above. Lastly, make sure to save the file when you're done (File -&gt; Save)</p>"},{"location":"ece2300-fpga-primer/#22-connecting-to-the-top-level-module","title":"2.2. Connecting to the Top-Level Module","text":"<p>From here, we can instantiate this module - create an instance of the hardware it represents. In your <code>DE0_CV_golden_top.v</code> (which contains the top-level <code>DE0_CV_golden_top</code> module), if you scroll to the bottom, you'll notice the module doesn't contain any logic yet. Let's add some functionality by instantiating our <code>PairTripleDetector_GL</code> module within the <code>DE0_CV_golden_top</code> module - let's give it the name <code>detector</code>.</p> <p>The module should have the following connections:</p> <ul> <li><code>in0</code> should be connected to the 0th switch (<code>SW[0]</code>)</li> <li><code>in1</code> should be connected to the 1st switch (<code>SW[1]</code>)</li> <li><code>in2</code> should be connected to the 2nd switch (<code>SW[2]</code>)</li> <li><code>out</code> should be connected to the 0th LED (<code>LEDR[0]</code>)</li> </ul> <p>Once you're done, your top-level module should look like the following:</p> <pre><code>module DE0_CV_golden_top (\n  ...\n);\n\n  PairTripleDetector_GL detector (\n    .in0 (SW[0]),\n    .in1 (SW[1]),\n    .in2 (SW[2]),\n    .out (LEDR[0])\n  );\n\nendmodule\n</code></pre> <p>Make sure to save this file as well.</p>"},{"location":"ece2300-fpga-primer/#23-adding-timing-information","title":"2.3. Adding Timing Information","text":"<p>In addition to the above, we need to give Quartus information about our timing constraints, so that it can properly analyze the timing of our design and analyze the critical path.</p> <ul> <li>Similar to before, go to File -&gt; New to create a new file. This time,    select \"Synopsys Design Constraints File\"</li> <li>Inside the file, add the following Tcl commands:</li> </ul> <pre><code>set_time_format -unit ns -decimal_places 3\ncreate_clock -period 20 [get_ports {CLOCK_50}]\n\nset_input_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports SW*]\nset_input_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports SW*]\n\nset_output_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports LEDR*]\nset_output_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports LEDR*]\n</code></pre> <p>Timing Commands</p> <p>We won't delve into these commands too much, but at a high-level, we're telling Quartus to not factor in delay from these ports, so out timing results should only represent the delay in our design. We also tell Quartus to analyze our timing for a \"clock period\" of 20 nanoseconds. We'll learn much more about clocks when we cover sequential logic, but for right now, you can think of this as saying that our logic paths should take no longer than 20 nanoseconds.</p> <ul> <li>Go to File -&gt; Save As, and save this file as <code>timing.sdc</code> within your    <code>lab1-primer</code> directory</li> </ul> <p>With the timing information and our design logic, we should be good to start putting our design on the FPGA!</p>"},{"location":"ece2300-fpga-primer/#3-synthesizing-a-hardware-design-using-quartus","title":"3. Synthesizing a Hardware Design using Quartus","text":"<p>From here, we can \"synthesize\" our design for the FPGA. The \"synthesis\" step includes:</p> <ul> <li>synthesis (determining what resources we need for our design)</li> <li>placement (determining which FPGA resources will be used)</li> <li>routing (connecting the FPGA resources as appropriate)</li> </ul> <p>At the end, we'll be left with a synthesized version that can be immediately put on the FPGA - this is known as a bitstream.</p> <p>In Quartus, you can perform the synthesis step by going to Processing -&gt; Start Compilation, or clicking the blue \"play\" button in the top toolbar. This will start the synthesis step - here, the FPGA is  using many complicated tools, so the entire process may take a few minutes. You can keep track of the progress in the Tasks bar on the  left-hand side, as well as with the verbose output log in the bottom. If  you made any static errors (such as incorrect syntax, or mixing up inputs and outputs), this is where Quartus will let you know with an errors.  However, it can't check for dynamic behavior (errors in the logic of your design), as it doesn't know the correct logic - that's up to you as a designer.</p> <p>If you get no errors, after a few minutes, you should see the following output in the log produced at the bottom of Quartus:</p> <pre><code>Quartus Prime Full Compilation was successful\n</code></pre>"},{"location":"ece2300-fpga-primer/#4-analyzing-a-hardware-design-using-quartus","title":"4. Analyzing a Hardware Design using Quartus","text":"<p>Once we've synthesized our design, Quartus will also give us some reports about our design. These are CRITICAL for us as designers to understand the tradeoffs between our different designs, and can help us analyze which one might be \"better\" in different circumstances.</p>"},{"location":"ece2300-fpga-primer/#41-rtl-viewer","title":"4.1. RTL Viewer","text":"<p>First, Quartus can help us visualize what logic our RTL design maps to. Go to Tools -&gt; Netlist Viewers -&gt; RTL Viewer. This should open up a new window to view how Quartus implemented our design.</p> <p></p> <p>We can see that our RTL design takes in some of the switches as inputs, and outputs to an LED.</p> <p>Our modules are initially represented as boxes (abstracting away the internal logic), but we can also click the \"+\" to open up the design and see the underlying gate-level network that Quartus mapped our design to. Compare this gate-level network to the one above - they should be the same!</p> <p></p> <p>When you're finished, you can close this pop-up window.</p>"},{"location":"ece2300-fpga-primer/#42-technology-map-viewer","title":"4.2. Technology Map Viewer","text":"<p>The RTL Viewer showed us the gate-level network, but what if we want to visualize exactly which resources were used on the FPGA? The  Technology Map Viewer can help us with this.</p> <ul> <li>Go to Tools -&gt; Netlist Viewers -&gt; Technology Map Viewer (Post-Fitting).    This should open up a pop-up window that shows our entire design that    came with our template top-level module.</li> <li>To focus on our design:<ul> <li>Click the \"+\" at the top to open up a new tab.</li> <li>In the \"Netlist Navigator\" panel on the left-hand side, under   DE0_CV_golden_top -&gt; Instances, drag the instance of    PairTripleDetector_GL to the new tab</li> </ul> </li> <li>Click the \"+\" on the module instance to show the underlying FPGA    resources</li> </ul> <p>You should see only one block that makes up the logic. This is known as a \"LUT\" (Look-Up Table), but we'll reference this as a  reconfigurable truth table. When we configure our FPGA, we tell this table what outputs it should have for every input, to represent our design. This design is relatively simple, so it only needs one truth table, but later designs will require more due to increasing complexity.</p> <p></p> <p>When you're finished, you can close this pop-up window.</p>"},{"location":"ece2300-fpga-primer/#43-chip-planner","title":"4.3. Chip Planner","text":"<p>Next, let's see if we can visualize exactly which portions of the FPGA are being used! Navigate to Tools -&gt; Chip Planner to open up the Chip Planner window.</p> <p></p> <p>This helps us visualize exactly which portions of the chip are being utilized - the highlighted portions are being used for our design. Our design isn't too large, so very few resources are being used. Quartus also has different granularities for how much logic is being used - each of these rectangles is a \"LAB\" (Logic Array Block)</p> <p>We can also see what each of these LABs are doing. The upper LAB was a ground signal that Quartus created, but the other LAB was the reconfigurable truth table that Quartus used to implement our design. Zoom on on this block (View -&gt; Zoom In, or <code>Ctrl + Space</code>), and click on the highlighted portion within it. The smaller highlighted portion is an \"ALM\" (Adaptive Logic Module) - each LAB contains multiple ALMs. Each ALM contains multiple reconfigurable truth tables - you can start to get a sense of how much logic our FPGA can represent!</p> <p></p> <p>On the side, you should be able to see what the ALM is used for (indicated in the name), as well as the Boolean logic equation that it implements. In this case, our ALM is determining what the <code>out</code> port of our <code>detector</code> module should be.</p> <p>When you're finished, you can close this pop-up window.</p>"},{"location":"ece2300-fpga-primer/#44-area-reports","title":"4.4. Area Reports","text":"<p>Quartus also generates reports for us to gain numerical results for our design. The first one we'll look at is the area report - we want to know how many resources our design needs. For this class, we'll approximate a design's area by how many FPGA resources it uses.</p> <p>Navigate to Processing -&gt; Compilation Report. In the tab that opens up, under Fitter -&gt; Resource Section, click on Resource Usage Summary. This will open up a report that shows you how many resources are being used on the FPGA. Here, we can see that 1 ALM is needed for our logic, and 2 LABs are used for logic, matching what we saw in the Chip Planner. While we could tell our utilization from the Chip Planner in this case, this report will be much more useful later on when our designs become more complicated and use more resources.</p> <p></p>"},{"location":"ece2300-fpga-primer/#45-timing-reports","title":"4.5. Timing Reports","text":"<p>Lastly, we can view the timing associated with our design. This can help tell us how long each path takes. In lecture, we represented this as an abstract timing unit tau, but now that we have an actual design, we can represent our path times in nanoseconds.</p> <ul> <li>Navitage to Tools -&gt; Timing Analyzer. This will open up a pop-up    window for analyzing the timing of our design.</li> <li>Under the Tasks panel on the left-hand side:<ul> <li>Double-click \"Update Timing Netlist\" to update the netlist for   our design</li> </ul> </li> </ul> <p></p> <ul> <li>Navigate to Reports -&gt; Custom Reports -&gt; Report Timing to create a    timing report. This will open up a pop-up for us to tell Quartus what    paths to analyze:<ul> <li>In Targets, under \"From\", put <code>[get_keepers SW*]</code>. This tells   Quartus to analyze paths starting from our switch signals</li> <li>In Targets, under \"To\", put <code>[get_keepers LEDR*]</code>. This tells   Quartus to analyze paths ending at our LED signals</li> <li>In Paths, under \"Report number of paths\", put <code>100</code> - this is   the number of paths that Quartus will report</li> <li>Click Report Timing</li> </ul> </li> </ul> <p></p> <p>This will generate a timing report for our design:</p> <ul> <li>In the top-panel, you should see three paths that Quartus found. They    should each start at one of the switches, and end at our LED signal.    Note that the \"Data Delay\" is how long each path takes - the path with    the longest delay is the critical path. Right now, the delay may be    longer than needed because we told the tools that logic can take up to    20 nanoseconds. If we wanted to be more representative, we'd push the    tools to fit the logic in less time. We'll explore this more in Lab 1.</li> </ul> <p>No Paths</p> <p>If Quartus didn't find any paths, it's likely that you may have missed something in the pop-up window, or in your <code>timing.sdc</code> file. Make sure to go back and double-check them!</p> <ul> <li>Click on the critical path, then look at the Data Arrival Path panel.    This panel shows how long it takes in nanoseconds for the signal to    reach each portion of the logic:<ul> <li>The Total and Incr columns show the total and incremental delay   for each portion of the path</li> <li>The Location column shows what type of FPGA resource the signal is   going through</li> <li>The Element column shows what signal name corresponds to the FPGA   resource. Some of these may be generated by Quartus, but you should   still be able to see the switch signal, LED signal, and the logic   inside your <code>detector</code> module</li> </ul> </li> </ul> <p></p> <p>When you're finished, you can close this pop-up window.</p>"},{"location":"ece2300-fpga-primer/#5-configuring-a-hardware-design-onto-the-fpga","title":"5. Configuring a Hardware Design onto the FPGA","text":"<p>With our design synthesized, all that's left is to configure our FPGA for our design. First, make sure your FPGA is turned on and plugged into the workstation via the USB Blaster.</p> <p></p> <p>Go to Tools -&gt; Programmer. This should open a new window for configuring the FPGA:</p> <ul> <li>Click on Hardware Setup. Under \"Currently selected hardware\", you    should see your FPGA as an option (appearing as USB Blaster [USB-0]).     Select your FPGA, then click Close</li> <li>Click on Start. This should configure the FPGA - notice how this is a    lot quicker than the synthesis step. Quartus has already done the    difficult part of figuring out how the FPGA should represent our    design, so all this step needs to do is communicate that information    to the FPGA. You can check when it's done by looking at the \"Progress\"    bar in the top-right.</li> </ul> <p>Once that's done, your FPGA should now emulate your design! You should verify this; try all possible switch combinations, and create the truth table that they represent. Does this match what you expect?</p>"},{"location":"ece2300-lab1p1-display/","title":"Lab 1: Five-Bit Numeric Display (Code and Simulation)","text":"<p>Lab 1 is a warmup designed to give you experience designing, implementing, testing, and prototyping a simple Verilog hardware design. This lab will leverage the concepts from lecture across two key abstraction layers: logic gates and boolean equations.</p> <p>You will be implementing a five-bit numeric display that takes as input a five-bit binary value and displays this value as a decimal number using two seven-segment displays. Your implementation will exclusively use combinational logic gates and/or Boolean equations. This five-bit numeric display will be reused extensively across all of the remaining labs. You will also gain experience optimizing your design. Lab 1.1 focuses on using simulation to test your design, while Lab 1.2 will explore integrating, synthesizing, analyzing, and configuring your design for an FPGA prototype. Lab 1.1 must be done individually without a partner; Lab 1.2 must be done with a randomly assigned partner.</p> <p>This handout assumes that you have read and understand the course tutorials and that you have attended the discussion sections. To get started, use VS Code to log into an <code>ecelinux</code> server, source the setup script, and clone your individual remote repository from GitHub:</p> <pre><code> % source setup-ece2300.sh\n % mkdir -p ${HOME}/ece2300\n % cd ${HOME}/ece2300\n % git clone git@github.com:cornell-ece2300/netid\n % cd ${HOME}/ece2300/netid\n % tree\n</code></pre> <p>where <code>netid</code> should be replaced with your NetID. You can both pull and push to your individual remote repository. If you have already cloned your individual remote repository, then use git pull to ensure you have any recent updates before working on your lab assignment.</p> <pre><code> % cd ${HOME}/ece2300/netid\n % git pull\n % tree\n</code></pre> <p>Your repo includes the following files:</p> <ul> <li><code>BinaryToSevenSegUnopt_GL.v</code>: Binary-to-seven-segment converter (unoptimized)</li> <li><code>BinaryToSevenSegOpt_GL.v</code>: Binary-to-seven-segment converter (optimized)</li> <li><code>BinaryToBinCodedDec_GL.v</code>: Binary-to-BCD converter</li> <li><code>DisplayUnopt_GL.v</code>: Five-bit numeric display (unoptimized)</li> <li><code>DisplayOpt_GL.v</code>: Five-bit numeric display (optimized)</li> <li><code>ece2300-test.v</code>: Course unit testing library</li> <li><code>BinaryToSevenSegUnopt_GL-test.v</code>: Test bench for binary-to-seven-segment (unoptimized)</li> <li><code>BinaryToSevenSegOpt_GL-test.v</code>: Test bench for binary-to-seven-segment (optimized)</li> <li><code>BinaryToBinCodedDec_GL-test.v</code>: Test bench for binary-to-BCD converter</li> <li><code>DisplayUnopt_GL-test.v</code>: Test bench for five-bit numeric display (unoptimized)</li> <li><code>DisplayOpt_GL-test.v</code>: Test bench for five-bit numeric display (optimized)</li> <li><code>display-sim.v</code>: Simulator for five-bit numeric display</li> </ul> <p>The <code>_GL</code> suffix indicates that these hardware designs should be implemented using the logic gate or boolean equation layers of abstraction. This means students are only allowed to use these Verilog constructs in their Verilog hardware designs:</p> <ul> <li><code>wire</code>, <code>assign</code></li> <li><code>not</code>, <code>and</code>, <code>nand</code>, <code>or</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code></li> <li><code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code></li> <li>literals (e.g., <code>1'b0</code>, <code>1'b1</code>)</li> <li>module instantiation</li> </ul> <p>Using any other Verilog constructs in your Verilog hardware designs will result in significant penalties for code functionality and code quality. If you have any questions on what Verilog constructs can and cannot be used, please ask an instructor. There are no restrictions on Verilog constructs in test benches.</p> <p>The lab assignment is divided into seven steps. Complete each step before moving on to the next step.</p> <ul> <li>Step 1. Construct truth table for binary-to-seven-segment converter</li> <li>Step 2. Implement and test <code>BinaryToSevenSegUnopt_GL</code></li> <li>Step 3. Construct truth table for binary-to-BCD converter</li> <li>Step 4. Implement and test <code>BinaryToBinCodedDec_GL</code></li> <li>Step 5. Implement and test <code>DisplayUnopt_GL</code></li> <li>Step 6. Implement and test <code>BinaryToSevenSegOpt_GL</code></li> <li>Step 7. Implement and test <code>DisplayOpt_GL</code></li> </ul> <p>Students will almost certainly need to spend significant time outside of their lab session to complete this lab. Students with a lab session early in the week can use their lab session to get started with the help of the course staff and then finish on their own before the deadline. Students with a lab session late in the week can get started on their own and use their lab session to finish their lab with the help of the course staff. Steps 1-5 are due on Thursday at 11:59pm. Steps 6 and 7 are not due until your lab session during the Lab 1.2 week.</p>"},{"location":"ece2300-lab1p1-display/#1-interface-and-implementation-specification","title":"1. Interface and Implementation Specification","text":"<p>You will be implementing a five-bit numeric display that takes as input a five-bit binary value and displays this value as a decimal number using two seven-segment displays. This section first describes the required interface for the five-bit numeric display (i.e., the ports for the module and the module's functional behavior) before describing the required implementation (i.e., what goes inside the module).</p>"},{"location":"ece2300-lab1p1-display/#11-five-bit-numeric-display-interface","title":"1.1. Five-Bit Numeric Display Interface","text":"<p>Your five-bit numeric display should take as input a five-bit binary value and output two seven-bit values, each of which can be used to control a seven-segment display.</p> <p></p> <p>A seven-segment display includes seven light-emitting diodes (or \"segments\") arranged in the following pattern.</p> <p></p> <p>Notice how each segment is numbered from 0 to 6. A seven-segment display has seven input bits (numbered 0 to 6), and each \"segment\" can be independently turned on or off by the corresponding input bit. This enables displaying the numbers from 0 to 9 as shown below.</p> <p></p> <p>The specific seven-segment displays we will be using in this course are active low. This means the segment is turned on when the corresponding bit is zero and the segment is turned off when the corresponding bit is one.</p> <p>You should display a leading zero for numbers less than 10. So if the input to our five-bit numeric display is the binary value 00001 (decimal value 1), then the output for your five-bit numeric display should be 1000000 for the tens position since we want to display 0 (i.e., we want segments 0-5 on and segment 6 off). If the binary value 00001 (decimal value 1), then the output for your five-bit numeric display should be 1111001 for the ones position since we want to display 1 (i.e., we want segments 1-2 to be on, and the remaining segments to be off). These outputs would result in the following being displayed on the two seven-segment displays.</p> <p></p> <p>So if the input to our five-bit numeric display is the binary value 01111 (decimal value 15), then the output for your five-bit numeric display should be 111_1001 for the tens position and 0010010 for the one's position (i.e., segments 1 and 4 are on and the remaining segments are off). These outputs would result in the following being displayed on the two seven-segment displays.</p> <p></p> <p>Ensure you understand these examples before continuing to work on the lab. Remember, a segment is turned on when the corresponding bit is zero and the segment is turned off when the corresponding bit is one.</p>"},{"location":"ece2300-lab1p1-display/#12-five-bit-numeric-display-implementation","title":"1.2. Five-Bit Numeric Display Implementation","text":"<p>Implementing an optimized five-bit numeric display as a single monolithic module would be quite complex, so we will instead use the abstraction principles of modularity, hierarchy, and regularity to enable an incremental design approach. The following block diagram illustrates how we can implement the five-bit numeric display with two kinds of submodules: a binary-to-seven-segment converter (<code>BinaryToSevenSegUnopt_GL</code>) and a binary-to-BCD converter (<code>BinaryToBinCodedDec_GL</code>).</p> <p></p> <p>The binary-to-seven-segment converter has a four-bit binary input port and a seven-bit output port. Each bit of the output port corresponds to one bit of a seven-segment display. The converter should turn on (i.e., set to zero) all of the appropriate segments to display the input value as a decimal number. So if the input to the converter is binary value 0111 (decimal value 7) then the output of the converter should be 1111000 which turns on segments 0, 1, 2 displaying the number 7. If the input is invalid (i.e., greater than 9), all segments should be turned on. You will need to construct an appropriate truth table before implementing the binary-to-seven-segment converter. We have provided you a template below. Once you have the truth table then you can systematically implement this truth table using what you learned in the discussion section.</p> Input asDecimal Value Input asBinary Value Output654 3210 0 0000 100 0000 1 0001 111 1001 2 0010 010 0100 ... ... ... 15 1111 000 0000 <p>The binary-to-BCD converter has a five-bit input port and two four-bit output ports: a tens output port and a ones output port. The converter should convert the input binary value into a decimal ones digit and a decimal tens digit, but these digits are encoded as binary values. So for example, if the input to the converter is binary value 01111 (decimal value 15), then the tens output should be binary value 0001 (decimal value 1) and the ones output should be binary value 1001 (decimal value 5). You will need to construct an appropriate truth table before implementing the binary-to-BCD converter. We have provided you a template below. Once you have the truth table then you can systematically implement this truth table using what you learned in the discussion section.</p> Input asDecimal Value Input asBinary Value Tens Ones 0 00000 0000 0000 1 00001 0000 0001 2 00010 0000 0010 ... ... ... ... 10 01010 0001 0000 ... ... ... ... 31 11111 0011 0001 <p>Once you have implemented (and thoroughly tested!) your binary-to-seven-segment converter and binary-to-BCD converter, you can then compose them to implement the five-bit numeric display as shown above. You will instantiate the binary-to-seven-segment converter twice; once to display the tens digit and once to display the ones digit.</p>"},{"location":"ece2300-lab1p1-display/#13-unoptimized-vs-optimized-implementations","title":"1.3. Unoptimized vs Optimized Implementations","text":"<p>Once you have implemented (and thoroughly tested!) your five-bit numeric display, you can then experiment with optimizing the binary-to-seven-segment converter. Use what you have learned in lecture on Boolean algebra (especially Karnaugh maps) to see if you can reduce the amount of logic required to implement the binary-to-seven-segment converter. You should use <code>BinaryToSevenSegOpt_GL</code> for your optimized implementation.</p> <p>We strongly recommend taking a incremental design approach! Start by copying your unoptimized implementation into <code>BinaryToSevenSegOpt_GL</code>. Then pick a single output port to optimize. Work through the corresponding Karnaugh map and replace just the logic for that output port with the newly optimized version. Leave all of the logic for the other output ports unoptimized. Then use your tests to verify the converter is still working. If not, you know where to focus your debugging. If so, you can move on to the next output port.</p> <p>Your optimized implementation is not due until your lab session during the Lab 1.2 week.</p>"},{"location":"ece2300-lab1p1-display/#2-testing-strategy","title":"2. Testing Strategy","text":"<p>You are responsible for developing an effective testing strategy to ensure all implementations are correct. Writing tests is one of the most important and challenging aspects of designing hardware. Hardware engineers often spend far more time implementing tests than they do implementing the actual hardware design.</p> <p>Continually having to use the same complex commands over and over can be tedious. We strongly recommend creating a few Bash shell scripts to enable you to automatically execute the commands to lint, compile, and run systematic test benches. See the discussion section for an example.</p>"},{"location":"ece2300-lab1p1-display/#21-linting","title":"2.1. Linting","text":"<p>Verilog is a very permissive language. We will be using <code>verilator</code> for <code>linting</code> which involves statically analyzing your hardware design to help catch syntax bugs early. You can run <code>verilator</code> to lint your <code>BinaryToSevenSegUnopt_GL</code> module like this:</p> <pre><code>% cd ${HOME}/ece2300/netid\n% verilator --Wall --lint-only BinaryToSevenSegUnopt_GL.v\n</code></pre> <p>You should always lint your designs before trying to compile them into a simulator. You can also lint your test benches.</p>"},{"location":"ece2300-lab1p1-display/#22-systematic-unit-testing","title":"2.2. Systematic Unit Testing","text":"<p>We will be using a lightweight testing framework to support a systematic and automatic unit testing strategy for every module you implement in the lab assignment:</p> <ul> <li><code>BinaryToSevenSegUnopt_GL</code></li> <li><code>BinaryToSevenSegOpt_GL</code></li> <li><code>BinaryToBinCodedDec_GL</code></li> <li><code>DisplayUnopt_GL</code></li> <li><code>DisplayOpt_GL</code></li> </ul> <p>For each module, we provide a test bench for you to use along with one basic test case. In future lab assignments we will use directed and random testing, but in this lab assignment you can use exhaustive testing where you try every single possible input. We have provided you an empty test case for you to insert your checks for exhaustive testing. Once you have added exhaustive testing (and linted your design!), you can compile your test bench like this:</p> <pre><code>% cd ${HOME}/ece2300/netid\n% iverilog -Wall -g2012 -o BinaryToSevenSegUnopt_GL-test BinaryToSevenSegUnopt_GL-test.v\n</code></pre> <p>And you can then run your test bench like this:</p> <pre><code>% cd ${HOME}/ece2300/netid\n% ./BinaryToSevenSegUnopt_GL-test\n% ./BinaryToSevenSegUnopt_GL-test +test-case=1\n% ./BinaryToSevenSegUnopt_GL-test +test-case=2\n% ./BinaryToSevenSegUnopt_GL-test +test-case=2 +dump-vcd=BinaryToSevenSegUnopt_GL-test.vcd\n</code></pre>"},{"location":"ece2300-lab1p1-display/#23-simulator","title":"2.3. Simulator","text":"<p>We have provided you a simple display simulator which will emulate what you will prototype on the FPGA in Lab 1.2. After finishing your implementation for the unoptimized display, you can run the display simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/netid\n% iverilog -Wall -g2012 -o display-sim display-sim.v\n% ./display-sim +switches=01111\n</code></pre> <p>The display simulator will show what the two seven segment displays would look like on the FPGA prototype.</p>"},{"location":"ece2300-lab1p1-display/#4-lab-code-submission","title":"4. Lab Code Submission","text":"<p>Your code quality score will be based on the way you format the text in your source files, proper use of comments, deletion of instructor comments, and uploading the correct files to GitHub (only source files should be uploaded, no generated build files). Note that students must remove unnecessary comments that are provided by instructors in the code distributed to students. Students must not commit executable binaries or any other unnecessary files.</p> <p>To submit your code you simply upload it to GitHub. Your design code will be assessed both in terms of functionality and code quality. Your functionality score will be determined by running your code against a series of tests developed by the instructors to test its correctness. Your test bench code will also be assessed both in terms of verification quality and code quality. Here is how we will be testing your final code submission for Lab 1.1:</p> <pre><code>% mkdir -p ${HOME}/ece2300/submissions\n% cd ${HOME}/ece2300/submissions\n% git clone git@github.com:cornell-ece2300/netid\n\n% verilator -Wall --lint-only BinaryToSevenSegUnopt_GL.v\n% iverilog -Wall -g2012 -o BinaryToSevenSegUnopt_GL-test BinaryToSevenSegUnopt_GL-test.v\n% ./BinaryToSevenSegUnopt_GL-test\n\n% verilator -Wall --lint-only BinaryToBinCodedDec_GL.v\n% iverilog -Wall -g2012 -o BinaryToBinCodedDec_GL-test BinaryToBinCodedDec_GL-test.v\n% ./BinaryToBinCodedDec_GL-test\n\n% verilator -Wall --lint-only DisplayUnopt_GL.v\n% iverilog -Wall -g2012 -o DisplayUnopt_GL-test DisplayUnopt_GL-test.v\n% ./DisplayUnopt_GL-test\n</code></pre>"},{"location":"ece2300-lab1p2-display/","title":"Lab 1: Five-Bit Numeric Display (FPGA and Report)","text":"<p>Lab 1 is a warmup designed to give you experience designing, implementing, testing, and prototyping a simple Verilog hardware design. This lab will leverage the concepts from lecture across two key abstraction layers: logic gates and boolean equations.</p> <p>You will continue to explore a five-bit numeric display that takes as input a five-bit binary value and displays this value as a decimal number using two seven-segment displays. Your implementation should exclusively used combinational logic gates and/or Boolean equations. This five-bit numeric display will be reused extensively across all of the remaining labs. You will also gain experience optimizing your design. Lab 1.1 focuses on using simulation to test your design, while Lab 1.2 will explore integrating, synthesizing, analyzing, and configuring your design for an FPGA prototype. Lab 1.1 must be done individually without a partner; Lab 1.2 must be done with a randomly assigned partner.</p> <p>This handout assumes that you have read and understand the course tutorials and that you have attended the discussion sections. This handout assumes you have completed the FPGA development primer, and you have successfully completed all parts of Lab 1.1. For Lab 1.1, both students worked individually, so for Lab 1.2, you should choose one student's code to use for the FPGA prototype. Obviously only choose code which is fully functional, but also choose whichever student's implementation of <code>BinaryToSevenSegOpt_GL</code> seems to be more aggressively optimized.</p> <p>Here are the steps to get started:</p> <ul> <li>Step 1. Check Canvas for your randomly assigned lab partner (Click     on People, then Groups, then search for your name to find your     Lab 1.2 group)</li> <li>Step 2. Find your randomly assigned lab partner</li> <li>Step 3. Find a free workstation</li> <li>Step 4. Ask the TAs for a lab check-off sheet (each student needs     their own check-off sheet)</li> </ul> <p>Throughout this handout you will see two kinds tasks: lab check-off tasks and lab report tasks.</p> <p>For each lab report task you must take some notes, save a screenshot, and/or record some data for your lab report. Students can start working on their lab report during their lab session, but will likely need to continue working on their lab report after the lab session. The lab report is due on Thursday at 11:59pm.</p> <p>For each lab check-off task you must raise your hand and have a TA come to check-off your work. The TA will ask you the questions included as part of the lab check-off task and the assess your understanding using the following rubric: mastery; accomplished; emerging; beginning. If the TA and students together feel the students have not mastered the lab check-off task, the students are encouraged to take a few minutes and try again.</p> <p>Lab Check-Off Task 1: Setup FPGA Board</p> <p>Request an FPGA board from the TAs. The TAs will record the board number on your check-off sheet. Use the power cord to plug the FPGA board into an outlet, and use the USB cable to plug the FPGA board into the workstation.</p>"},{"location":"ece2300-lab1p2-display/#1-simulation-of-five-bit-numeric-display","title":"1. Simulation of Five-Bit Numeric Display","text":"<p>Before starting to work on an FPGA prototype, you must make sure you have a working Verilog hardware design that has been thoroughly tested in simulation. The student whose code will be used for Lab 1.2, should start VS Code on the workstation, log into an <code>ecelinux</code> server, source the setup script, and make sure their individual remote repository is up to date.</p> <pre><code>% source setup-ece2300.sh\n% cd ${HOME}/ece2300/netid\n% git pull\n% tree\n</code></pre> <p>Where <code>netid</code> is your Cornell NetID. Now run all of the tests to ensure your design is fully functional.</p> <pre><code>% cd ${HOME}/ece2300/netid\n\n% verilator -Wall --lint-only BinaryToSevenSegUnopt_GL.v\n% iverilog -Wall -g2012 -o BinaryToSevenSegUnopt_GL-test BinaryToSevenSegUnopt_GL-test.v\n% ./BinaryToSevenSegUnopt_GL-test\n\n% verilator -Wall --lint-only BinaryToSevenSegOpt_GL.v\n% iverilog -Wall -g2012 -o BinaryToSevenSegOpt_GL-test BinaryToSevenSegOpt_GL-test.v\n% ./BinaryToSevenSegOpt_GL-test\n\n% verilator -Wall --lint-only BinaryToBinCodedDec_GL.v\n% iverilog -Wall -g2012 -o BinaryToBinCodedDec_GL-test BinaryToBinCodedDec_GL-test.v\n% ./BinaryToBinCodedDec_GL-test\n\n% verilator -Wall --lint-only DisplayUnopt_GL.v\n% iverilog -Wall -g2012 -o DisplayUnopt_GL-test DisplayUnopt_GL-test.v\n% ./DisplayUnopt_GL-test\n\n% verilator -Wall --lint-only DisplayOpt_GL.v\n% iverilog -Wall -g2012 -o DisplayOpt_GL-test DisplayOpt_GL-test.v\n% ./DisplayOpt_GL-test\n</code></pre> <p>We now need to get the files for your design from <code>ecelinux</code> onto the workstation. This requires multiple steps.</p> <ul> <li> <p>Step 1. Click Microsoft Edge on the desktop to open a web-browser on    the workstation to log into GitHub and then find your repository</p> </li> <li> <p>Step 2. Start PowerShell by clicking the Start menu then searching    for Windows PowerShell</p> </li> <li> <p>Step 3. Clone your repo onto the workstation by using this command in    PowerShell (where <code>netid</code> is your Cornell NetID, notice we are using    https!):</p> </li> </ul> <pre><code>% git clone https://github.com/cornell-ece2300/netid\n</code></pre> <ul> <li> <p>Step 4. In the Connect to GitHub pop-up, click Sign in with your    browser</p> </li> <li> <p>Step 5. You may be asked for your GitHub username again and you may be    asked to authorize the Git Credential Manager; click authorize    git-ecosystem</p> </li> <li> <p>Step 6. Verify that you have successfully cloned your repo by changing    into your repo and using <code>tree</code> on the workstation:</p> </li> </ul> <pre><code>% cd netid\n% tree\n</code></pre> <p>Lab Check-Off Task 2: Verify Test Simulations, Discuss Optimizations</p> <p>Show a TA that your hardware design is passing all five tests on <code>ecelinux</code>. The TA will ask both students to explain how they optimized their designs for the binary-to-seven-segment converter. Explain which outputs you ended up optimizing and how you used either Boolean theorems or a Karnaugh map to simplify the logic. Hypothesize how much you think these optimizations will reduce the overall area of the design and/or the critical path delay.</p>"},{"location":"ece2300-lab1p2-display/#2-setup-quartus-project","title":"2. Setup Quartus Project","text":"<p>Click Quartus (Quartus Prime 19.1) on the desktop to start Quartus, and click Run the Quartus Prime software. You might need to try starting Quartus twice. Setup a new Quartus project using the New Project Wizard:</p> <ul> <li>Directory, Name, Top-Level Entity<ul> <li>Working directory: <code>C:\\Users\\netid\\lab1</code></li> <li>Name of this project: <code>lab1</code></li> <li>Name of top-level design entity: <code>lab1</code></li> <li>Click Next</li> </ul> </li> <li>Directory does not exist. Do you want to create it?<ul> <li>Click yes</li> </ul> </li> <li>Project Type<ul> <li>Choose Empty Project</li> <li>Click Next</li> </ul> </li> <li>Add Files<ul> <li>Click triple dots to right of File name</li> <li>Click on This PC, then navigate to your cloned repo by choosing    Windows (C:) &gt;  Users &gt; netid &gt; netid where netid is your    Cornell NetID</li> <li>Shift-click on every Verilog hardware design file (do not include    any test files)</li> <li>Click Open</li> <li>Click Next</li> </ul> </li> <li>Family, Device, and Board Settings<ul> <li>Click Board tab</li> <li>Family: Cyclone V</li> <li>Select DE0-CV Development Board</li> <li>Make sure Create top-level design file is checked</li> <li>Click Next</li> </ul> </li> <li>EDA Tool Settings<ul> <li>Click Next</li> </ul> </li> <li>Summary<ul> <li>Click Finish</li> </ul> </li> </ul>"},{"location":"ece2300-lab1p2-display/#3-integrate-synthesize-analyze-unoptimized-five-bit-numeric-display","title":"3. Integrate, Synthesize, Analyze Unoptimized Five-Bit Numeric Display","text":"<p>We will start by integrating, synthesizing, and analyzing the unoptimized version of your five-bit numeric display. Refer back to the FPGA development primer for more details on each step.</p>"},{"location":"ece2300-lab1p2-display/#31-integrate","title":"3.1. Integrate","text":"<p>Start by spending a few minutes identifying the location of the input switches and the seven-segment displays on the board.</p> <p></p> <p>The ten switches are numbered from right to left. Switch <code>SW[0]</code> is the right-most switch, and switch <code>SW[9]</code> is the left-most switch. The seven-segment displays are also numbered from right to levet. Seven-segment display <code>HEX0</code> is the right-most display, and seven-segment display <code>HEX5</code> is the left-most display.</p> <p>The New Project Wizard creates a top-level Verilog module for us which has ports for all of the switches, LEDs, seven-segment displays, and pins on the FPGA development board. You need to instantiate whatever design you want to synthesize and analyze in this top-level Verilog module and connect the ports appropriately.</p> <ul> <li>Double-click on DE0_CV_golden_top</li> <li>Instantiate DisplayUnopt_GL in the top-level module</li> <li>Connect the ports as shown below</li> <li>Choose File &gt; Save from the menu</li> </ul> <pre><code>DisplayUnopt_GL display\n(\n  .in       (SW[4:0]),\n  .seg_tens (HEX1),\n  .seg_ones (HEX0)\n);\n</code></pre> <p>Lab Check-Off Task 3: Explain Top-Level Connections</p> <p>Show a TA the location of switches <code>SW[0]</code> through <code>SW[4]</code> on the board. Show the TA the location of seven-segment displays <code>HEX0</code> and <code>HEX1</code> on the board. Show the TA your top-level connections in Verilog, and clearly explain how the inputs and outputs of your <code>DisplayUnopt_GL</code> Verilog module will be hooked up to the physical switches and seven-segment displays on the board. Explain to the TA what is the expected behavior (i.e., when we flip these switches, we expect this to happen).</p>"},{"location":"ece2300-lab1p2-display/#32-synthesize-and-analyze","title":"3.2. Synthesize and Analyze","text":"<p>Before we synthesize and analyze the unoptimized display unit, we need to create a timing constraint file. It is critical to understand that the FPGA tools do not synthesize the design to just run as fast as possible. The way the FPGA tools work, is that the designer provides a timing constraint on the critical path delay, and the tools work as hard as they can (but no harder!) to meet this critical path delay constraint. When finished, the design will either \"meet timing\" (i.e., the actual critical path delay is less than the constraint) or \"not meet timing\" (i.e., the actual critical path delay is greater than the contraint).</p> <p>Here are the steps to create a timing constraint file:</p> <ul> <li>Choose File &gt; New from the menu</li> <li>Click Synopsys Design Constraints File</li> <li>Click OK</li> <li>Enter the constraints shown below</li> <li>Click File &gt; Save from the menu</li> <li>Name the file timing.sdc</li> <li>Save the file in the lab1 directory</li> </ul> <p>We will use the following initial constraints:</p> <pre><code>set_time_format -unit ns -decimal_places 3\ncreate_clock -period 20 [get_ports {CLOCK_50}]\n\nset_input_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports SW*]\nset_input_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports SW*]\n\nset_output_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports HEX*]\nset_output_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports HEX*]\n</code></pre> <p>These constraints tell the FPGA tools that our critical path delay constraint is 20ns and that the FPGA tools should analyze all paths from every input switches (<code>SW*</code>) to every seven-segment display (<code>HEX*</code>).</p> <p>Now use the following steps to synthesize your design and then look at the RTL viewer, technology map viewer, and chip planner.</p> <ul> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>RTL Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; RTL Viewer from the menu</li> <li>Drill down in the hierarchy to see the netlist for <code>BinaryToSevenSegUnopt_GL</code></li> <li>Choose File &gt; Close from menu to close the RTL viewer</li> </ul> </li> <li>Technology Map Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; Technology Map Viewer (Post-Fitting)</li> <li>Click + for a new tab</li> <li>In Netlist Navigator choose DE0_CV_golden_top &gt; Instances &gt; DisplayUnopt_GL</li> <li>Drag DisplayUnopt_GL into the empty tab</li> <li>Drill down in the hierarchy to see the implementation of <code>BinaryToSevenSegUnopt_GL</code></li> <li>Choose File &gt; Close from the menu to close the technology map viewer</li> </ul> </li> <li>Chip Planner<ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located in the FPGA</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> </li> </ul> <p>Lab Report Task 1: RTL Viewer for Unoptimized Design</p> <p>Save a screenshot of the RTL viewer for just <code>BinaryToSevenSegUnopt_GL</code> for your lab report. Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report.</p> <p>The next step is to analyze the area of your design.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu. Under Table    of Contents choose Fitter &gt; Resource Section &gt; Resource Usage    Summary</li> <li>Look through the report to determine the number of combinational ALUTs    (configurable look-up tables) are used for your design</li> </ul> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>From: [get_keepers SW*]</li> <li>To: [get_keepers HEX*]</li> <li>Report number of paths: 100</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the propagation delay of the longest path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one of the input switches through your     design to one of the seven-segment displays</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Lab Report Task 2: Critical Path for Unoptimized Design</p> <p>Save a screenshot of just the critical path of your unoptimized design for your lab report. Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report. The screenshot should clearly show the total delay, incremental delay, location, and element for each gate along the critical path.</p> <p>Lab Check-Off Task 4: Discuss RTL Viewer and Critical Path for Unoptimized Design</p> <p>Show a TA your screenshot of the RTL viewer for just <code>BinaryToSevenSegUnopt_GL</code>. Explain how the RTL viewer connects back to the Verilog for your design. Show a TA your screenshot of the critical path. Explain how the critical path connects back to the Verilog code for your design (i.e., where does the critical path start and end? what modules does the critical path go through?). Explain what is the actual delay of every single gate in the real FPGA along the critical path. What kind of delay model (i.e., a zero-delay model? a constant-delay model? a more complex delay model?) are the FPGA tools using to analyze the delay?</p>"},{"location":"ece2300-lab1p2-display/#33-iterate","title":"3.3. Iterate","text":"<p>Your design will almost certainly meet timing with a critical path delay constraint of 20ns. We are interested in the limit on the critical path delay (i.e., what is the true minimum critical path delay) so we can compare our unoptimized and optimized designs. To find the limit, we need to iteratively reduce the critical path timing constraint until we no longer meet timing. We can consider the shortest critical path delay while still meeting timing as the \"true minimum critical path delay\".</p> <p>You can iteratively reduce the critical path delay, by changing 20 in the timing constraint file to something smaller. So the iterative process will look like this:</p> <ul> <li>Edit the timing constraints file to reduce the critical path delay constraint</li> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>Analyze the area of your design</li> <li>Analyze the timing of your design</li> </ul> <p>You will be working to fill in this table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1lJkyLqEPCzKxX4zA0fiVSmTuxLOED7eDWVi5F_9yAC0/edit?gid=0#gid=0</li> </ul> <p>Make a copy of this table, and enter in the data for your unoptimized design with a 20ns critical path delay constraint. You can find the number of 7-input ALUts, 6-input ALUts, etc in the area report. The critical path delay is just the Data Delay of the slowest path in the timing report.</p> <p>Then iteratively reduce the timing constraint until your design no longer meets timing. Then the \"true minimum critical path delay\" is the shortest critical path across all experiments that meet timing. You should enter at least four rows into the table, but you can enter more if you need to.</p> <p>Lab Report Task 3: Unoptimized Analysis Data Table</p> <p>Save your completed data table with your analysis of the unoptimized design and include it in your report.</p> <p>Lab Check-Off Task 5: Discuss Area and Delay Analysis for Unoptimized Design</p> <p>Show a TA your completed data table with your analysis of the unoptimized design. Explain if the number ALUTs (i.e., configurable truth tables) either does or does not match your expectation given your Verilog code. Discuss what you found for the \"true minimum critical path delay\" of your unoptimized design.</p>"},{"location":"ece2300-lab1p2-display/#4-integrate-synthesize-analyze-optimized-five-bit-numeric-display","title":"4. Integrate, Synthesize, Analyze Optimized Five-Bit Numeric Display","text":"<p>Now we will integrate, synthesize, and analyze the optimized version of your five-bit numeric display. Refer back to the FPGA development primer for more details on each step.</p>"},{"location":"ece2300-lab1p2-display/#41-integrate","title":"4.1. Integrate","text":"<p>We will not create a new project, but we will instead simply change which module is being instantiated in the top-level Verilog module provided for us by the New Project Wizard.</p> <ul> <li>Double-click on DE0_CV_golden_top</li> <li>Instantiate DisplayOpt_GL in the top-level module</li> <li>Connect the ports as shown below</li> <li>Choose File &gt; Save from the menu</li> </ul> <pre><code>DisplayOpt_GL display\n(\n  .in       (SW[4:0]),\n  .seg_tens (HEX1),\n  .seg_ones (HEX0)\n);\n</code></pre>"},{"location":"ece2300-lab1p2-display/#42-synthesize-and-analyze","title":"4.2. Synthesize and Analyze","text":"<p>We will repeat the steps we did to synthesize and analyze the unoptimized design, except now for the optimized design. Start by resetting the timing constraint file to use a 20ns critical path delay constraint:</p> <pre><code>set_time_format -unit ns -decimal_places 3\ncreate_clock -period 20 [get_ports {CLOCK_50}]\n\nset_input_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports SW*]\nset_input_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports SW*]\n\nset_output_delay -add_delay -clock { CLOCK_50 } -max 0 [get_ports HEX*]\nset_output_delay -add_delay -clock { CLOCK_50 } -min 0 [get_ports HEX*]\n</code></pre> <p>Now use the following steps to synthesize your design and then look at the RTL viewer, technology map viewer, and chip planner.</p> <ul> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>RTL Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; RTL Viewer from the menu</li> <li>Drill down in the hierarchy to see the netlist for <code>BinaryToSevenSegOpt_GL</code></li> <li>How does this compare to your unoptimized design?</li> <li>Choose File &gt; Close from menu to close the RTL viewer</li> </ul> </li> <li>Technology Map Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; Technology Map Viewer (Post-Fitting)</li> <li>Click + for a new tab</li> <li>In Netlist Navigator choose DE0_CV_golden_top &gt; Instances &gt; DisplayOpt_GL</li> <li>Drag DisplayOpt_GL into the empty tab</li> <li>Drill down in the hierarchy to see the implementation of <code>BinaryToSevenSegOpt_GL</code></li> <li>How does this compare to your unoptimized design?</li> <li>Choose File &gt; Close from the menu to close the technology map viewer</li> </ul> </li> <li>Chip Planner<ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located in the FPGA</li> <li>How does this compare to your unoptimized design?</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> </li> </ul> <p>Lab Report Task 4: RTL Viewer for Optimized Design</p> <p>Save a screenshot of the RTL viewer for just <code>BinaryToSevenSegOpt_GL</code> for your lab report. Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report.</p> <p>The next step is to analyze the area of your design.</p> <ul> <li>In Table of Contents choose Fitter &gt; Resource Section &gt; Resource Usage Summary</li> <li>Look through the report to determine the number of combinational ALUs    (configurable look-up tables) are used for your design</li> <li>How does this compare to your unoptimized design?</li> </ul> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. Once again, we analyze the timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>From: [get_keepers SW*]</li> <li>To: [get_keepers HEX*]</li> <li>Report number of paths: 100</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the propagation delay of the longest path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one of the input switches through your     design to one of the seven-segment displays</li> <li>How does this compare to your unoptimized design?</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Lab Report Task 5: Critical Path for Optimized Design</p> <p>Save a screenshot of just the critical path of your optimized design for your lab report. Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report. The screenshot should clearly show the total delay, incremental delay, location, and element for each gate along the critical path.</p> <p>Lab Check-Off Task 6: Discuss RTL Viewer and Critical Path for Optimized Design</p> <p>Show a TA your screenshot of the RTL viewer for just <code>BinaryToSevenSegOpt_GL</code>. Explain how the RTL viewer connects back to the Verilog for your design. Show a TA your screenshot of the critical path. Explain how the critical path connects back to the Verilog code for your design (i.e., where does the critical path start and end? what modules does the critical path go through?). Explain what is the actual delay of every single gate in the real FPGA along the critical path.</p>"},{"location":"ece2300-lab1p2-display/#43-iterate","title":"4.3. Iterate","text":"<p>We are beginning to be able to compare our unoptmized and optimized designs, but need to find the \"true minimum critical path delay\" of the optimized design for a rigorous comparison. As with the unoptimized design, you can iteratively reduce the critical path delay, by changing 20 in the timing constraint file to something smaller. The iterative process looks like this:</p> <ul> <li>Edit the timing constraints file to reduce the critical path delay constraint</li> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>Analyze the area of your design</li> <li>Analyze the timing of your design</li> </ul> <p>You will be working to fill out the rest of this table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1lJkyLqEPCzKxX4zA0fiVSmTuxLOED7eDWVi5F_9yAC0/edit?gid=0#gid=0</li> </ul> <p>Work on the same copy of this table you made earlier, and enter in the data for your optimized design with a 20ns critical path delay constraint. Then iteratively reduce the timing constraint until your design no longer meets timing, updating the table as you go along. You should enter at least four rows into the table, but you can enter more if you need to.</p> <p>Lab Report Task 6: Optimized Analysis Data Table</p> <p>Save your completed data table with your analysis of the optimized design and include it in your report.</p> <p>Lab Check-Off Task 7: Discuss Area and Delay Analysis for Optimized Design</p> <p>Show a TA your completed data table with your analysis of the optimized design. Discuss in detail your findings comparing the unoptimized vs. optimized implementations. What conclusions can we draw in terms of how much effort we should spend trying to optimize the gate-level implementation and/or Boolean equations in our Verilog hardware designs?</p>"},{"location":"ece2300-lab1p2-display/#5-configure-five-bit-numeric-display-fpga-prototype","title":"5. Configure Five-Bit Numeric Display FPGA Prototype","text":"<p>We now have a fully verified Verilog hardware design, and we have finished a rigorous comparative analysis of the area and timing for both an unoptimized and optimized implementation. The last step is to configure the FPGA with our optimized design and demostrate the final FPGA prototype!</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>Lab Check-Off Task 8: Final Five-Bit Numeric Display Demo</p> <p>Show a TA your final five-bit numeric display demo. The TA will ask you to enter at least two specific binary numbers using the switches. You must determine the correct decimal value first, tell the TA what the correct decimal value should be, and only then set the switches to confirm correct operation.</p> <p>Lab Check-Off Task 9: Turn In FPGA Board</p> <p>When you are finished with your demo, pack up your FPGA development board. Neatly put the board, power cable, and USB cable back in the box. Return the box to a TA who will then record the board number on your check-off sheet, initial the final check-off, and then collect your check-off sheet.</p>"},{"location":"ece2300-lab1p2-display/#6-lab-report-submission","title":"6. Lab Report Submission","text":"<p>Students should work with their partner to prepare a short lab report that conveys what they have learned in this lab assignment. Before starting the lab report, pick one student's code and create a Verilog data table using this template:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1lJkyLqEPCzKxX4zA0fiVSmTuxLOED7eDWVi5F_9yAC0/edit?gid=446446324</li> </ul> <p>Count the number of logic gates with a specific number of inputs in your Verilog code and enter these counts in the table. Count the number of logic gates along the critical path and enter these counts in the table. The provided template uses a very simple area/delay model where the area/delay of a gate is equal to the number of inputs to that gate. This data should enable you to make a very simplistic estimate of the total area and critical path delay of the unoptimized and optimized designs. There is no \"right way\" to count gates from Verilog. Students must use their judgement to estimate the number of gates. The key is to be consistent so you can make a comparison between your unoptimized and optimized design from just the Verilog code.</p> <p>Note that you cannot directly compare the area/delay estimated using your simple Verilog area/delay model to the area/delay reported by the FPGA tools; these are completely different ways to estimate area/delay. However, you can relate the two comparisions when using the same methodology: is design A better than design B when using the Verilog area/delay model but then design A is worse than design B based on the FPGA tools? or maybe design A and B are similar when using the Verilog area/delay model but they are different when using the FPGA tools? So while directly comparing numbers from your simple Verilog area/delay model and the area/delay reported by the FPGA tools is not possible, it is possible to discuss if the comparisons using the same model are similar or different.</p> <p>The lab report should start with no more than two pages of text. Students should include all figures, tables, and diagrams after these two pages in an appendix. The appendix can be as many pages as necessary. Do not interleave the text, figures, tables, and diagrams. There should be two pages of text and then the appendix with all of the text, figures, tables, and diagrams.</p> <p>There are no restrictions on font size, margins, or line spacing, but please make sure your report is readable. We recommend using 10pt Times or 10pt Palintino with 0.75in to 1in margins. Please make sure you include a title, your names, and your NetIDs at the top of the first page. Do not include a title page.</p> <p>The lab report must include the following numbered sections. Please number your sections and use these specific titles. Please follow the guidelines on the number of paragraphs, the content of each paragraph, and which figures/tables to include. Some paragraphs might just be 2-3 sentences.</p>"},{"location":"ece2300-lab1p2-display/#section-1-introduction-one-paragraph","title":"Section 1. Introduction (one paragraph)","text":"<ul> <li>Include 2-3 sentences explaining what the lab involves</li> <li>Include one sentence explaining the purpose of this lab (why are     students doing this lab?)</li> <li>Include one sentence explicitly connecting the lab to one or more     lecture topics; be specific on which lecture topics this lab     reinforces with experiential learning</li> </ul>"},{"location":"ece2300-lab1p2-display/#section-2-optimizing-a-binary-to-seven-segment-converter-one-paragraph","title":"Section 2: Optimizing a Binary-to-Seven-Segment Converter (one paragraph)","text":"<ul> <li>Choose one student's code to feature in this section</li> <li>Include a figure in the appendix illustrating the K-maps or your     Boolean simplifications</li> <li>Include 2-3 sentences describing your K-maps or Boolean     simplifications</li> <li>Include a sentence describing why the result of your K-maps or     Boolean simplifications should hopefully result in a more     optimized implementation</li> </ul>"},{"location":"ece2300-lab1p2-display/#section-3-comparative-analysis-three-paragraphs","title":"Section 3: Comparative Analysis (three paragraphs)","text":"<ul> <li> <p>Paragraph 1: Verilog Comparison</p> <ul> <li>Include the Verilog data    table    mentioned above in the appendix</li> <li>Include the RTL Viewer screenshots for both the unoptimized and    optimized designs in the appendix</li> <li>Include a sentence referencing the Verilog data table</li> <li>Include a sentence comparing the total area of the unoptimized    vs optimized designs using the simple Verilog area model</li> <li>Include a sentence comparing the total delay of the unoptimized    vs optimized designs using the simple Verilog delay model</li> <li>Include 2-3 sentences comparing and contrasting the unoptimized    vs optimized designs based just on the original Verilog</li> <li>Include a sentence discussing the RTL Viewer screenshots</li> </ul> </li> <li> <p>Paragraph 2: FPGA Area Comparison</p> <ul> <li>Include the FPGA data    table    in the appendix</li> <li>Include a sentence referencing the area data in the FPGA data    table</li> <li>Include a sentence comparing the area of the unoptimized vs    optimized designs using the FPGA area data</li> <li>Include a sentence relating this FPGA comparison to your comparison    based purely on the simple Verilog area model.</li> </ul> </li> <li> <p>Paragraph 3: FPGA Delay Comparison</p> <ul> <li>Include the critical path screenshots for both the unoptimized    and optimized design in the appendix</li> <li>Include a sentence referencing the delay data in the FPGA data    table</li> <li>Include a sentence describing where the critical path goes    through the design (at a high-level) for both the unoptimized    and optimized designs</li> <li>Include a sentence comparing the critical path delay of the    unoptimized vs optimized designs using the FPGA delay data</li> <li>Include a sentence relating this FPGA comparison to your comparison    based purely on the simple Verilog delay model</li> </ul> </li> </ul>"},{"location":"ece2300-lab1p2-display/#section-4-conclusion-one-paragraph","title":"Section 4: Conclusion (one paragraph)","text":"<ul> <li>Include 2-3 sentences that summarizes all of the data and analysis     in this lab assignment</li> <li>Include a sentence that draws a high-level conclusion; how will     what you have learned impact your design work throughout the rest     of the semester?</li> </ul>"},{"location":"ece2300-lab1p2-display/#appendix","title":"Appendix","text":"<ul> <li>Figure illustrating K-maps or Boolean simplifications</li> <li>Verilog data table</li> <li>Screenshot of RTL Viewer for unoptimized design</li> <li>Screenshot of RTL Viewer for optimized design</li> <li>FPGA data table</li> <li>Screenshot of critical path for unoptimized design</li> <li>Screenshot of critical path for optimized design</li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/","title":"Lab 2: Two-Function Calculator (FPGA and Report)","text":"<p>Lab 2 is meant to give you experience designing, implementing, testing, and prototyping more complicated combinational logic using the Verilog hardware description language. In addition to leveraging the concepts from lecture across two key abstraction layers: logic gates and Boolean equations, this lab will also reinforce three key abstraction principles: modularity, hierarchy, and regularity. This lab will give students experience with several combinational building blocks including multiplexors, adders, and multipliers.</p> <p>You will continue to explore a two-function calculator that takes as input two binary values and then calculates either the sum or the product of these two values. The input values and the result will be displayed on seven-segment displays using your Verilog hardware design from Lab 1. Your implementation should mostly use combinational logic gates and/or Boolean equations, but you will also start to explore very simple register-transfer-level modeling. You will also gain experience comparing implementations using gate-level and Boolean equations vs implementations using register-transfer-level modeling. You should have already worked on using simulation to test your design, so in this lab session we will explore integrating, synthesizing, analyzing, and configuring your design for an FPGA prototype. Lab 2 must be done with your lab partner.</p> <p>This handout assumes that you have read and understand the course tutorials, attended the discussion sections, and successfully completed Lab 1. Here are the steps to get started:</p> <ul> <li>Step 1. Find your lab partner</li> <li>Step 2. Find a free workstation</li> <li>Step 3. Ask the TAs for a lab check-off sheet (each student needs     their own check-off sheet)</li> </ul> <p>Throughout this handout you will see two kinds tasks: lab check-off tasks and lab report tasks.</p> <p>For each lab report task you must take some notes, save a screenshot, and/or record some data for your lab report. Students can start working on their lab report during their lab session, but will likely need to continue working on their lab report after the lab session. The lab report is due three days after your lab session at 11:59pm.</p> <p>For each lab check-off task you must raise your hand and have a TA come to check-off your work. The TA will ask you the questions included as part of the lab check-off task and the assess your understanding using the following rubric: mastery; accomplished; emerging; beginning. If the TA and students together feel the students have not mastered the lab check-off task, the students are encouraged to take a few minutes and try again.</p> <p>Lab Check-Off Task 1: Setup FPGA Board</p> <p>Request an FPGA board from the TAs. The TAs will record the board number on your check-off sheet. Use the power cord to plug the FPGA board into an outlet, and use the USB cable to plug the FPGA board into the workstation.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#1-simulation-of-a-two-function-calculator","title":"1. Simulation of a Two-Function Calculator","text":"<p>Before starting to work on an FPGA prototype, you must make sure you have a working Verilog hardware design that has been thoroughly tested in simulation. One student should start VS Code on the workstation, log into the <code>ecelinux</code> servers, source the setup script, and make sure their individual remote repository is up to date.</p> <pre><code>% source setup-ece2300.sh\n% cd ${HOME}/ece2300/groupXX\n% git pull\n% tree\n</code></pre> <p>Where <code>XX</code> is your group number. Now run all of the tests from a clean build to ensure your design is fully functional.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc\n% trash build\n% mkdir build\n% cd build\n% ../configure\n% make check\n</code></pre> <p>Also make sure the two-function calculator interactive simulator is working.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/build\n% make calculator-sim\n% ./calculator-sim +in0-switches=00100 +in1-switches=00011 +button=0\n% ./calculator-sim +in0-switches=00100 +in1-switches=00011 +button=1\n</code></pre> <p>We now need to get the files for your design from <code>ecelinux</code> onto the workstation. This requires multiple steps.</p> <ul> <li> <p>Step 1. Click Microsoft Edge on the desktop to open a web-browser on    the workstation to log into GitHub and then find your repository</p> </li> <li> <p>Step 2. Start PowerShell by clicking the Start menu then searching    for Windows PowerShell</p> </li> <li> <p>Step 3. Clone your repo onto the workstation by using this command in    PowerShell (where <code>netid</code> is your Cornell NetID, notice we are using    https!):</p> </li> </ul> <pre><code>% git clone https://github.com/cornell-ece2300/groupXX\n</code></pre> <ul> <li> <p>Step 4. In the Connect to GitHub pop-up, click Sign in with your    browser</p> </li> <li> <p>Step 5. You may be asked for your GitHub username again and you may be    asked to authorize the Git Credential Manager; click authorize    git-ecosystem</p> </li> <li> <p>Step 6. Verify that you have successfully cloned your repo by changing    into your repo and using <code>tree</code> on the workstation:</p> </li> </ul> <pre><code>% cd groupXX\n% tree\n</code></pre> <p>Lab Check-Off Task 2: Verify Test and Interactive Simulators</p> <p>Show a TA that your hardware designs are passing all of your tests on <code>ecelinux</code>. The TA will give you two decimal numbers. You should first determine their unsigned binary representation, then determine what the correct unsigned binary output would be if we added these two numbers together, and finally determine what the correct unsigned output should be if we multiplied these two numbers together. You must determine these unsigned binary values before running the two-function interactive simulator! Once you know these values, then use the two-function interactive simulator to verify your work. The TA will ask follow-up questions about the following scenarios:</p> <ul> <li>(1) addition when <code>in0</code> is 31 and <code>in1</code> is 1</li> <li>(2) multiplication when <code>in0</code> is 16 and <code>in1</code> is 3</li> <li>(3) multiplication when <code>in0</code> is 16 and <code>in1</code> is 7</li> </ul> <p>Be ready to explain why the calculator is producing the corresponding output for each scenario.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#2-setup-quartus-project","title":"2. Setup Quartus Project","text":"<p>Click Quartus (Quartus Prime 19.1) on the desktop to start Quartus, and click Run the Quartus Prime software. You might need to try starting Quartus twice. Setup a new Quartus project using the New Project Wizard:</p> <ul> <li>Directory, Name, Top-Level Entity<ul> <li>Working directory: <code>C:\\Users\\netid\\lab2</code></li> <li>Name of this project: <code>lab2</code></li> <li>Name of top-level design entity: <code>lab2</code></li> <li>Click Next</li> </ul> </li> <li>Directory does not exist. Do you want to create it?<ul> <li>Click yes</li> </ul> </li> <li>Project Type<ul> <li>Choose Empty Project</li> <li>Click Next</li> </ul> </li> <li>Add Files<ul> <li>Click triple dots to right of File name</li> <li>Click on This PC, then navigate to your cloned repo by choosing    Windows (C:) &gt;  Users &gt; netid &gt; netid where netid is your    Cornell NetID</li> <li>Shift-click on every Verilog hardware design file (do not include    any test files)</li> <li>Click Open</li> <li>Click Next</li> </ul> </li> <li>Family, Device, and Board Settings<ul> <li>Click Board tab</li> <li>Family: Cyclone V</li> <li>Select DE0-CV Development Board</li> <li>Make sure Create top-level design file is checked</li> <li>Click Next</li> </ul> </li> <li>EDA Tool Settings<ul> <li>Click Next</li> </ul> </li> <li>Summary<ul> <li>Click Finish</li> </ul> </li> </ul> <p>Since we are now using RTL modeling, there is one new step from Lab 1. You must choose Assignments &gt; Settings from the menu. Then select the category Compiler Settings &gt; Verilog HDL Input and under Verilog version click SystemVerilog. Then click OK.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#3-synthesize-and-analyze-adders","title":"3. Synthesize and Analyze Adders","text":"<p>We will start by synthesizing and analyzing three different adder designs in isolation. When we say in isolation we mean that our goal is not to actually prototype these adder designs on the FPGA (e.g., demo the adders with switches and seven segment displays), but our goal is instead to perform a rigorous comparative analysis across multiple adder designs. Once we better understand the adder design space we can then select the appropriate adder for use in the final FPGA prototype.</p> <p>Before starting, we want to predict the critical path for the ripple-carry and carry-select adders. Ask the TAs for a hard copy of the two block diagrams shown below. You do not need to redraw these yourself.</p> <p></p> <p>Lab Report Task 1: Predicted Adder Critical Paths</p> <p>Clearly draw your predicted critical path on each block diagram. Save these diagrams since you will be continuing to annotate them throughout the lab.</p> <p>Lab Check-Off Task 3: Discuss Predicted Adder Critical Paths</p> <p>Show a TA your block diagrams with the critical paths. Explain to the TA which design should have a shorter critical path and why. How much shorter will the critical path be?</p>"},{"location":"ece2300-lab2-calc-fpga-report/#31-synthesize-and-analyze-ripple-carry-adder","title":"3.1. Synthesize and Analyze Ripple-Carry Adder","text":"<p>We will be using a slightly different approach to synthesize and analyze the adders in isolation compared to our process in Lab 1. When pushing a hardware design through the flow in isolation, we want to let the FPGA tools automatically assign the top-level ports to the FPGA pins. This will enable the FPGA to optimize this assignment improving the overall critical path and enabling a more rigorous analysis.</p> <p>To synthesize and analyze the ripple-carry adder in isolation first find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>AdderRippleCarry_8b_GL.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>AdderRippleCarry_8b_GL</code> is shown as the only entity.</p> <p>As in Lab 1, we need to create a timing constraint file. As mentioned in Lab 1, the FPGA tools do not synthesize the design to just run as fast as possible. The way the FPGA tools work, is that the designer provides a timing constraint on the critical path delay, and the tools work as hard as they can (but no harder!) to meet this critical path delay constraint. When finished, the design will either \"meet timing\" (i.e., the actual critical path delay is less than the constraint) or \"not meet timing\" (i.e., the actual critical path delay is greater than the constraint).</p> <p>Here are the steps to create a timing constraint file:</p> <ul> <li>Choose File &gt; New from the menu</li> <li>Click Synopsys Design Constraints File</li> <li>Click OK</li> <li>Enter the constraints shown below</li> <li>Click File &gt; Save from the menu</li> <li>Name the file timing.sdc</li> <li>Save the file in the lab2 directory</li> </ul> <p>We will use the following initial constraints:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n</code></pre> <p>These constraints tell the FPGA tools that our critical path delay constraint is 20ns and that the FPGA tools should analyze all paths from every input port to every output port.</p> <p>Now use the following steps to synthesize your design and then look at the RTL viewer, technology map viewer, and chip planner.</p> <ul> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>RTL Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; RTL Viewer from the menu</li> <li>Drill down in the hierarchy to see the netlist for the 8-bit    ripply-carry adder, the 4-bit ripple-carry adder, and the full    adder</li> <li>Does the RTL viewer match your expectations? Where would the      critical path go on this diagram?</li> <li>Choose File &gt; Close from menu to close the RTL viewer</li> </ul> </li> <li>Technology Map Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; Technology Map Viewer (Post-Fitting)</li> <li>Drill down in the hierarchy to see the implementation of the 8-bit    ripply-carry adder, the 4-bit ripple-carry adder, and the full    adder</li> <li>Does the RTL viewer match your expectations? Where would the      critical path go on this diagram?</li> <li>Choose File &gt; Close from the menu to close the technology map viewer</li> </ul> </li> <li>Chip Planner<ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located in the FPGA</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> </li> </ul> <p>The next step is to analyze the area of your design.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu</li> <li>Under Table of Contents choose Fitter &gt; Resource Section &gt; Resource    Usage Summary</li> <li>Look through the report to determine the number of combinational ALUTs    (configurable look-up tables) are used for your design</li> </ul> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>From: [all_inputs]</li> <li>To: [all_outputs]</li> <li>Report number of paths: 1</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the propagation delay of the displayed path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one of the inputs through your     design to one of the outputs</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Your design will almost certainly meet timing with a critical path delay constraint of 20ns. As in Lab 1, we are interested in the limit on the critical path delay (i.e., what is the true minimum critical path delay) so we can compare our unoptimized and optimized designs. To find the limit, we need to iteratively reduce the critical path timing constraint until we no longer meet timing. We can consider the shortest critical path delay while still meeting timing as the \"true minimum critical path delay\").</p> <p>You can iteratively reduce the critical path delay, by changing 20 in the timing constraint file to something smaller. So the iterative process will look like this:</p> <ul> <li>Edit the timing constraints file to reduce the critical path delay constraint</li> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>Analyze the area of your design</li> <li>Analyze the timing of your design</li> </ul> <p>You will be working to fill in this table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1tlkaQYOx7t8CJpzAL5IsU2EbmdBQsGVKJyi_uQSu1BQ/edit?gid=0#gid=0</li> </ul> <p>Make a copy of this table, and enter in the data for your ripple-carry adder with a 20ns critical path delay constraint. You can find the number of 7-input ALUts, 6-input ALUts, etc in the area report. You can save time by not generating a brand new timing report. You can instead simply use the following steps.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu</li> <li>Under Table of Contents choose Timing Analyzer &gt; Slow 1100mV 85C      Model &gt; Setup Summary</li> <li>The critical path delay is just the constraint minus the slack</li> </ul> <p>Then iteratively reduce the timing constraint until your design no longer meets timing. We are interested in the limit on the critical path delay (i.e., what is the true minimum critical path delay) so we can compare our unoptimized and optimized designs. To find the limit, we need to iteratively reduce the critical path timing constraint until we no longer meet timing. We can consider the shortest critical path delay while still meeting timing as the \"true minimum critical path delay\".</p> <p>Once you have found the minimum timing constraint which still meets timing, use the Timing Analyzer to find the corresponding critical path. We want to save the timing report to a file so we can include it in our report. So when using the Timing Analyzer to create the timing report complete the following two steps:</p> <ul> <li>Check File name</li> <li>Enter file name as <code>AdderRippleCarry_8b_GL-critical-path.txt</code></li> </ul> <p>Find and open this timing report text file. It should be in the <code>lab2</code> subdirectory. Make sure there is only a single critical path in the timing report text file.</p> <p>Lab Report Task 2: Data Table and Critical Path Report for Ripple-Carry Adder</p> <p>Save your completed data table with your analysis of the ripple-carry adder and include it in your report. Save the critical path timing report text file and include it in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Report Task 3: Actual Critical Path for Ripple-Carry Adder</p> <p>Draw the actual critical path on the block diagram for the ripple-carry adder using the timing report. Label each full adder along the critical path with its corresponding delay using the timing report. Label the delay to get from the FPGA input pin to the adder and the delay to get from the adder to the FPGA output pin.</p> <p>Lab Check-Off Task 4: Discuss Area and Delay Analysis for Ripple-Carry Adder</p> <p>Show a TA your completed data table with your analysis for the ripple-carry adder. Show a TA the actual critical path on the block diagram for the ripple-carry adder. Clearly show how the delays in the timing report correspond to the delays through the full adders in the block diagram.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#32-synthesize-and-analyze-carry-select-adder","title":"3.2. Synthesize and Analyze Carry-Select Adder","text":"<p>Use the same process to synthesize and analyze the carry-select adder in isolation. Remember to change that hardware module to be the top-level entity. So find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>AdderCarrySelect_8b_GL.v file. Right click on the file and choose _Select as Top-Level Entity_. Then click on _Files_ to display the drop-down list again. Choose _Hierarchy_ and confirm that</code>AdderCarrySelect_8b_GL` is shown as the only entity. Remember to reset the timing constraint back to 20ns.</p> <p>Go through the same process of looking at the RTL Viewer, Technology Map Viewer, and the Chip Planner. Use the same process to iteratively reduce the critical path delay, by changing 20 in the timing constraint file to something smaller. The iterative process will look like this:</p> <ul> <li>Edit the timing constraints file to reduce the critical path delay constraint</li> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>Analyze the area of your design</li> <li>Analyze the timing of your design</li> </ul> <p>You will be continuing to to fill in this table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1tlkaQYOx7t8CJpzAL5IsU2EbmdBQsGVKJyi_uQSu1BQ/edit?gid=0#gid=0</li> </ul> <p>Once you have found the minimum timing constraint which still meets timing, use the Timing Analyzer to find the corresponding critical path. We want to save the timing report to a file so we can include it in our report. So when using the Timing Analyzer to create the timing report complete the following two steps:</p> <ul> <li>Check File name</li> <li>Enter file name as <code>AdderCarrySelect_8b_GL-critical-path.txt</code></li> </ul> <p>Find and open this timing report text file. It should be in the <code>lab2</code> subdirectory. Make sure there is only a single critical path in the timing report text file.</p> <p>Lab Report Task 4: Data Table and Critical Path Report for Carry-Select Adder</p> <p>Save your completed data table with your analysis of the carry-select adder and include it in your report. Save the critical path timing report text file and include it in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Report Task 5: Actual Critical Path for Carry-Select Adder</p> <p>Draw the actual critical path on the block diagram for the carry-select adder using the timing report. Label each full adder and 1-bit multiplexor along the critical path with its corresponding delay using the timing report. Label the delay to get from the FPGA input pin to the adder and the delay to get from the adder to the FPGA output pin.</p> <p>Lab Check-Off Task 5: Discuss Area and Delay Analysis for Both Adders</p> <p>Show a TA your completed data table with your analysis for the carry-select adder. Show a TA the actual critical path on the block diagram for the carry-select adder. Clearly show how the delays in the timing report correspond to the delays through the full adders and 1-bit multiplexors in the block diagram. Use your experimental data to quantitatively explain to the TA the trade-offs between these two adders. Which adder is smallest? By what percentage is the area decreased? Which adder is the fastest? By what percentage is the critical path decreased?</p>"},{"location":"ece2300-lab2-calc-fpga-report/#32-synthesize-and-analyze-rtl-adder","title":"3.2. Synthesize and Analyze RTL Adder","text":"<p>Use the same process to synthesize and analyze the carry-select adder in isolation. Remember to change that hardware module to be the top-level entity. So find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>Adder_8b_RTL.v file. Right click on the file and choose _Select as Top-Level Entity_. Then click on _Files_ to display the drop-down list again. Choose _Hierarchy_ and confirm that</code>Adder_8b_RTL` is shown as the only entity. Remember to reset the timing constraint back to 20ns.</p> <p>Go through the same process of looking at the RTL Viewer, Technology Map Viewer, and the Chip Planner. Look closely at the RTL viewer. What kind of adder do the FPGA tools seem to be using?</p> <p>Use the same process to iteratively reduce the critical path delay, by changing 20 in the timing constraint file to something smaller. The iterative process will look like this:</p> <ul> <li>Edit the timing constraints file to reduce the critical path delay constraint</li> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>Analyze the area of your design</li> <li>Analyze the timing of your design</li> </ul> <p>You will be continuing to to fill in this table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1tlkaQYOx7t8CJpzAL5IsU2EbmdBQsGVKJyi_uQSu1BQ/edit?gid=0#gid=0</li> </ul> <p>Once you have found the minimum timing constraint which still meets timing for the carry-select adder, use the Timing Analyzer to find the corresponding critical path. Remember to output the timing report to a text file when using the Timing Analyzer. Find and open this timing report text file. It should be in the <code>lab2</code> subdirectory. Make sure there is only a single critical path in the timing report text file. Look very closely at this critical path and compare it to the critical path for the ripple-carry and carry-select adders.</p> <p>We are going to do something a little different to help us understand the critical path. Right click on the Data Arrival Path area and then choose Locate Path &gt; Locate in Technology Map Viewer. This is now showing a diagram illustrating where the critical path goes through various logic gates on the FPGA. What kind of adder do the FPGA tools seem to be using?</p> <p>Lab Report Task 6: RTL Viewer and Critical Path Diagram for RTL Adder</p> <p>Save a screenshot of the RTL viewer for <code>Adder_8b_RTL</code> and a screenshot of the critical path located in the technology map viewer for your lab report. Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report.</p> <p>Lab Report Task 7: Data Table and Critical Path Report for RTL Adder</p> <p>Save your completed data table with your analysis of the RTL adder and include it in your report. Save the critical path timing report text file and include it in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Check-Off Task 6: Discuss Area and Delay Analysis for All Adders</p> <p>Show a TA your completed data table with your analysis for the RTL adder. Explain to the TA what kind of adder you think the FPGA tools are using to implement the RTL adder. Use your experimental data to quantitatively explain to the TA the trade-offs between all three adders. Which adder is the smallest? Which adder is the fastest? What conclusions can we draw in terms of how much effort we should spend trying to implement building blocks using a gate-level implementation and/or Boolean equations in our Verilog hardware designs?</p>"},{"location":"ece2300-lab2-calc-fpga-report/#4-synthesize-and-analyze-multipliers","title":"4. Synthesize and Analyze Multipliers","text":"<p>We want to do a similar comparison between our gate-level and RTL multipliers. To save you time, we have gone ahead and done the iterative sweep to find a reasonable timing constraint for both multipliers. Go ahead and determine the area and critical path delay for both multipliers using these constraints:</p> <ul> <li><code>Multiplier_2x8b_GL</code>: 16ns</li> <li><code>Multiplier_2x8b_RTL</code>: 13ns</li> </ul> <p>If one of your designs does not meet timing with these constraints increase the constraint by 1ns and try again.</p> <p>Lab Report Task 8: Data Table and Critical Path Report for Multipliers</p> <p>Save your completed data table with your analysis of both multipliers. Save the critical path timing report text files for both multipliers and include them in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Check-Off Task 7: Discuss Area and Delay Analysis for Multipliers</p> <p>Show a TA your completed data table with your analysis for both multipliers. Use your experimental data to quantitatively explain to the TA the trade-offs between all these two multipliers. Which adder is smallest? By what percentage is the area decreased? Which adder is the fastest? By what percentage is the critical path decreased? What conclusions can we draw in terms of how much effort we should spend trying to implement building blocks using a gate-level implementation and/or Boolean equations in our Verilog hardware designs?</p>"},{"location":"ece2300-lab2-calc-fpga-report/#5-integrate-synthesize-and-configure-two-function-calculator-fpga-prototype","title":"5. Integrate, Synthesize, and Configure Two-Function Calculator FPGA Prototype","text":"<p>We now have a fully verified Verilog hardware design, and we have finished a rigorous comparative analysis of the area and timing of both the adders and multipliers. The last step is to integrate, synthesize, and configure the FPGA with our design and demonstrate the final FPGA prototype!</p>"},{"location":"ece2300-lab2-calc-fpga-report/#51-integrate","title":"5.1. Integrate","text":"<p>We need to change the top-level entity to be <code>DE0_CV_golden_top.v</code>. Find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>DE0_CV_golden_top.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>DE0_CV_golden_top</code> is shown as the only entity.</p> <p>The New Project Wizard creates a top-level Verilog module for us which has ports for all of the switches, LEDs, seven-segment displays, and pins on the FPGA development board. We need to instantiate <code>CalculatorDisplay_GL</code> in this top-level Verilog module and connect the ports. Students are responsible for figuring out the appropriate top-level port connections to meet the following specification.</p> <ul> <li>The left five switches are for <code>in0</code></li> <li>The right five switches are for <code>in1</code></li> <li>The two seven-segment displays on the left are for <code>in0</code></li> <li>The two seven-segment displays in the middle are for <code>in1</code></li> <li>The two seven-segment displays on the right are for the result</li> <li>The right-most push button is for <code>op</code></li> <li>By default calculator should perform addition, pressing the button    should perform multiplication</li> </ul> <p></p> <p>Look carefully at the labels on the board to figure out how the switches, buttons, and seven-segment displays correspond to ports in the top-level Verilog module. Use the following steps when you are ready to integrate the calculator.</p> <ul> <li>Double-click on DE0_CV_golden_top</li> <li>Instantiate CalculatorDisplay_GL in the top-level module</li> <li>Connect the ports</li> <li>Choose File &gt; Save from the menu</li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/#52-synthesize","title":"5.2. Synthesize","text":"<p>You will need to update the timing constraint file as follows:</p> <pre><code>set_max_delay -from [get_ports {SW* KEY*}] -to [get_ports HEX*] 22\nset_min_delay -from [get_ports {SW* KEY*}] -to [get_ports HEX*] 0\n</code></pre> <p>Then choose  Processing &gt; Start Compilation from the menu to synthesize your design. Open the Chip Planner to see where the calculator is located on the FPGA:</p> <ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located in the FPGA</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> <p>Feel free to also take a look at the area and critical path for the complete calculator.</p> <p>Lab Report Task 9: Calculator Chip Planner</p> <p>Save a screenshot of the chip planner for <code>CalculatorDisplay_GL</code> Press the Fn + Print Screen key to save a screenshot to the clipboard, then paste the screenshot into a Google Doc and crop appropriately for your lab report. You must highlight where your calculator is located on the FPGA.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#53-configure","title":"5.3. Configure","text":"<p>Now we are finally ready to configure the FPGA for our calculator demo!</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>Test out your calculator. Note that the specification requires that your calculator performs addition by default and only performs multiplication when the button is pressed. Consider this excerpt from the data-sheet for our FPGA boards.</p> <p></p> <p>Given this new information you may need to add a logic gate to the top-level Verilog file to ensure your calculator correctly implements the specification.</p> <p>Lab Check-Off Task 8: Final Two-Function Calculator Demo</p> <p>Show a TA your final two-function calculator demo. The TA will ask you to enter two binary numbers using the switches. You must determine the correct decimal values first, tell the TA what the correct decimal value should be for both addition and multiplication, and only then set the switches to confirm correct operation. Your calculator must display the digits in the correct locations and perform addition by default and multiplication when the button is pressed.</p> <p>Lab Check-Off Task 9: Turn In FPGA Board</p> <p>When you are finished with your demo, pack up your FPGA development board. Neatly put the board, power cable, and USB cable back in the box. Return the box to a TA who will then record the board number on your check-off sheet, initial the final check-off, and then collect your check-off sheet.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#6-lab-report-submission","title":"6. Lab Report Submission","text":"<p>Students should work with their partner to prepare a short lab report that conveys what they have learned in this lab assignment. The lab report should start with no more than two pages of text. Students should include all figures, tables, and diagrams after these two pages in an appendix. The appendix can be as many pages as necessary. Do not interleave the text, figures, tables, and diagrams. There should be two pages of text and then the appendix with all of the text, figures, tables, and diagrams.</p> <p>There are no restrictions on font size, margins, or line spacing, but please make sure your report is readable. We recommend using 10pt Times or 10pt Palintino with 0.75in to 1in margins. Please make sure you include a title, your names, and your NetIDs at the top of the first page. Do not include a title page.</p> <p>The lab report must include the following numbered sections. Please number your sections and use these specific titles. Please follow the guidelines on the number of paragraphs, the content of each paragraph, and which figures/tables to include. Some paragraphs might just be 2-3 sentences.</p>"},{"location":"ece2300-lab2-calc-fpga-report/#section-1-introduction-one-paragraph","title":"Section 1. Introduction (one paragraph)","text":"<ul> <li>Include 2-3 sentences explaining what the lab involves</li> <li>Include one sentence explaining the purpose of this lab (why are     students doing this lab?)</li> <li>Include one sentence explicitly connecting the lab to one or more     lecture topics; be specific on which lecture topics this lab     reinforces with experiential learning</li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/#section-2-testing-strategy-one-paragraph","title":"Section 2: Testing Strategy (one paragraph)","text":"<ul> <li>Include one sentence about the importance of a comprehensive testing      strategy</li> <li>Include 1-2 sentences about what is exhaustive testing and which      modules used exhaustive testing</li> <li>Include 2-3 sentences about what is directed testing and which      modules used directed testing; mention specific kinds of directed      test cases you included</li> <li>Include 2-3 sentences about what is random testing and which modules      used random testing; mention specific kinds of random test cases you      included</li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/#section-3-comparative-analysis-three-paragraphs","title":"Section 3: Comparative Analysis (three paragraphs)","text":"<ul> <li> <p>Paragraph 1: Adder Area Comparison</p> <ul> <li>Include a sentence referencing the area data in the FPGA data    table for all three adder designs</li> <li>Include 1-2 sentences comparing the area of the ripple-carry adder    to the carry-select adder; you must explain why the area of one    adder is more or less than the other adder</li> <li>Include 1-2 sentences comparing the area of the RTL adder to the    other two adders; you must try your best to explain why the area    of the RTL adder is more or less than the other adders</li> </ul> </li> <li> <p>Paragraph 2: Adder Delay Comparison</p> <ul> <li>Include a sentence referencing the delay data in the FPGA data    table for all three adder designs</li> <li>Include a sentence describing where the critical path goes in    detail for the ripple-carry adder by referencing your timing    report and your annotated block diagram</li> <li>Include a sentence describing where the critical path goes in    detail for the carry-select adder by referencing your timing    report and your annotated block diagram</li> <li>Include 1-2 sentences comparing the critical path delays for the    ripple-carry adder and the carry-select adder; you must explain    why the delay of one adder is more or less than the other    adder</li> <li>Include 1-2 sentences comparing the delay of the RTL adder to the    other two adders; you must try your best to explain why the    delay of the RTL adder is more or less than the other adders</li> </ul> </li> <li> <p>Paragraph 3: Multiplier Comparison</p> <ul> <li>Include a 1-2 sentences comparing the area of the gate-level    multiplier to the RTL multiplier</li> <li>Include a 1-2 sentences comparing the delay of the gate-level    multiplier to the RTL multiplier</li> <li>It might be hard to deeply understand why the area and/or delay of    one multiplier is more or less than the other, so it is fine to    just summarize your results</li> </ul> </li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/#section-4-conclusion-one-paragraph","title":"Section 4: Conclusion (one paragraph)","text":"<ul> <li>Include 2-3 sentences that summarizes all of the data and analysis     in this lab assignment</li> <li>Include a sentence that draws a high-level conclusion; how will     what you have learned impact your design work throughout the rest     of the semester?</li> </ul>"},{"location":"ece2300-lab2-calc-fpga-report/#appendix","title":"Appendix","text":"<ul> <li>FPGA Data Table</li> <li>Block diagram for ripple-carry adder with highlighted critical path      and annotated delays</li> <li>Block diagram for carry-select adder with highlighted critical path      and annotated delays</li> <li>RTL Viewer for RTL adder</li> <li>Critical Path Diagram Located in Technology Map Viewer for RTL Adder</li> <li>Chip planner for calculator with logic highlighted</li> <li>Critical path report for ripple-carry adder (1 page max, fixed width font!)</li> <li>Critical path report for carry-select adder (1 page max, fixed width font!)</li> <li>Critical path report for RTL adder (1 page max, fixed width font!)</li> <li>Critical path report for array multiplier (1 page max, fixed width font!)</li> <li>Critical path report for RTL multiplier (1 page max, fixed width font!)</li> </ul>"},{"location":"ece2300-lab2p1-calc/","title":"Lab 2: Two-Function Calculator (Code and Simulation)","text":"<p>Lab 2 will give you experience designing, implementing, testing, and prototyping more complicated combinational logic using the Verilog hardware description language. In addition to leveraging the concepts from lecture across two key abstraction layers: logic gates and Boolean equations, this lab will also reinforce three key abstraction principles: modularity, hierarchy, and regularity. This lab will give students experience with several combinational building blocks including multiplexors, adders, and multipliers.</p> <p>You will be implementing a two-function calculator that takes as input two binary values and then calculates either the sum or the product of these two values. The input values and the result will be displayed on seven-segment displays using your Verilog hardware design from Lab 1. Parts of the calculator will be used in future labs. Your implementation will mostly use combinational logic gates and/or Boolean equations, but you will also start to explore very simple register-transfer-level modeling. You will also gain experience comparing implementations using gate-level and Boolean equations vs implementations using register-transfer-level modeling. Lab 2.1 focuses on using simulation to test your design, while Lab 2.2 will explore integrating, synthesizing, analyzing, and configuring your design for an FPGA prototype. Lab 2 must be done with a partner. You can confirm your assigned partner on Canvas (Click on People, then Groups, then search for your name to find your lab group)</p> <p>This handout assumes that you have read and understand the course tutorials and that you have attended the discussion sections. To get started, use VS Code to log into an <code>ecelinux</code> server, source the setup script, and clone your individual remote repository from GitHub:</p> <pre><code> % source setup-ece2300.sh\n % mkdir -p ${HOME}/ece2300\n % cd ${HOME}/ece2300\n % git clone git@github.com:cornell-ece2300/groupXX\n % cd ${HOME}/ece2300/groupXX\n % tree\n</code></pre> <p>where <code>XX</code> should be replaced with your group number. You can both pull and push to your remote repository. If you have already cloned your remote repository, then use <code>git pull</code> to ensure you have any recent updates before working on your lab assignment.</p> <pre><code> % cd ${HOME}/ece2300/groupXX\n % git pull\n % tree\n</code></pre> <p>Go ahead and create a build directory in the <code>lab2-calc</code> directory for this lab, and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>Your repo contains the following files which are part of the automated build system:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> </ul> <p>The <code>hw</code> subdirectory includes the following Verilog hardware design files.</p> <ul> <li><code>BinaryToSevenSeg_GL.v</code>: Binary-to-seven-segment converter</li> <li><code>BinaryToBinCodedDec_GL.v</code>: Binary-to-BCD converter</li> <li><code>Display_GL.v</code>: Five-bit numeric display</li> <li><code>FullAdder_GL.v</code>: Full adder</li> <li><code>AdderRippleCarry_4b_GL.v</code>: 4-bit ripple-carry adder</li> <li><code>AdderRippleCarry_8b_GL.v</code>: 8-bit ripple-carry adder</li> <li><code>Mux2_1b_GL.v</code>: 1-bit 2-to-1 multiplexor</li> <li><code>Mux2_4b_GL.v</code>: 4-bit 2-to-1 multiplexor</li> <li><code>Mux2_8b_GL.v</code>: 8-bit 2-to-1 multiplexor</li> <li><code>AdderCarrySelect_8b_GL.v</code>: 8-bit carry-select adder</li> <li><code>Adder_8b_RTL.v</code>: 8-bit register-transfer-level adder</li> <li><code>Multiplier_1x8b_GL.v</code>: 1-bit by 8-bit multplier</li> <li><code>Multiplier_2x8b_GL.v</code>: 2-bit by 8-bit multplier</li> <li><code>Multiplier_2x8b_RTL.v</code>: 2-bit by 8-bit register-transfer-level multiplier</li> <li><code>Calculator_GL.v</code>: Calculator supporting addition and multiplication</li> <li><code>CalculatorDisplay_GL.v</code>: Calculator with seven-segment displays</li> </ul> <p>The <code>test</code> subdirectory includes the following test libraries and test benches.</p> <ul> <li><code>ece2300-test.v</code>: ECE 2300 unit testing framework</li> <li><code>BinaryToSevenSeg_GL-test.v</code>: Tests for binary-to-seven-segment converter</li> <li><code>BinaryToBinCodedDec_GL-test.v</code>: Tests for binary-to-BCD converter</li> <li><code>Display_GL-test.v</code>: Tests for five-bit numeric display</li> <li><code>FullAdder_GL-test.v</code>: Tests for full adder</li> <li><code>AdderRippleCarry_4b_GL-test.v</code>: Tests for 4-bit ripple-carry adder</li> <li><code>AdderRippleCarry_8b_GL-test.v</code>: Tests for 8-bit ripple-carry adder</li> <li><code>Mux2_1b_GL-test.v</code>: Tests for 1-bit 2-to-1 multiplexor</li> <li><code>Mux2_4b_GL-test.v</code>: Tests for 4-bit 2-to-1 multiplexor</li> <li><code>Mux2_8b_GL-test.v</code>: Tests for 8-bit 2-to-1 multiplexor</li> <li><code>AdderCarrySelect_8b_GL-test.v</code>: Tests for 8-bit carry-select adder</li> <li><code>Adder_8b_RTL-test.v</code>: Tests for 8-bit register-transfer-level adder</li> <li><code>Multiplier_1x8b_GL-test.v</code>: Tests for 1-bit by 8-bit multplier</li> <li><code>Multiplier_2x8b_GL-test.v</code>: Tests for 2-bit by 8-bit multplier</li> <li><code>Multiplier_2x8b_RTL-test.v</code>: Tests for 2-bit by 8-bit register-transfer-level multiplier</li> <li><code>Calculator_GL-test.v</code>: Tests for calculator supporting addition and multiplication</li> <li><code>CalculatorDisplay_GL-test.v</code>: Tests for calculator with seven-segment displays</li> </ul> <p>Finally, the <code>sim</code> directory includes the following interactive simulator.</p> <ul> <li><code>calculator-sim.v</code>: Interactive simulator for calculator with    seven-segment displays</li> </ul> <p>The <code>_GL</code> suffix indicates which hardware designs should be implemented using the logic gate or Boolean equation layers of abstraction. For these designs, students are only allowed to use these Verilog constructs:</p> <ul> <li><code>wire</code>, <code>assign</code></li> <li><code>not</code>, <code>and</code>, <code>nand</code>, <code>or</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code></li> <li><code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code></li> <li>literals (e.g., <code>1'b0</code>, <code>1'b1</code>)</li> <li>module instantiation</li> </ul> <p>The <code>_RTL</code> suffix indicates which hardware designs should be implemented using register-transfer-level (RTL) modeling. For RTL designs, students can additionally use the following Verilog constructs.</p> <ul> <li><code>+</code> <code>*</code></li> </ul> <p>Using unallowed Verilog constructs will result in significant penalties for code functionality and code quality. If you have any questions on what Verilog constructs can and cannot be used, please ask an instructor. There are no restrictions on Verilog constructs in test benches.</p> <p>The lab assignment is divided into two parts each with several steps. Complete each step before moving on to the next step.</p> <ul> <li> <p>Part A (Submit on GitHub by Thu, Sep 26 @ 11:59pm)</p> <ul> <li>Step 1. Copy your lab 1 design and testing code into lab 2</li> <li>Step 2. Implement and test <code>FullAdder_GL</code></li> <li>Step 3. Implement and test <code>AdderRippleCarry_4b_GL</code></li> <li>Step 4. Implement and test <code>AdderRippleCarry_8b_GL</code></li> <li>Step 5. Implement and test <code>Mux2_1b_GL</code></li> <li>Step 6. Implement and test <code>Mux2_4b_GL</code></li> <li>Step 7. Implement and test <code>Mux2_8b_GL</code></li> <li>Step 8. Implement and test <code>AdderCarrySelect_8b_GL</code></li> <li>Step 9. Implement and test <code>Adder_8b_RTL</code></li> </ul> </li> <li> <p>Part B (Submit on GitHub by Thu, Oct 3 @ 11:59pm)</p> <ul> <li>Step 10. Implement and test <code>Multiplier_1x8b_GL</code></li> <li>Step 11. Implement and test <code>Multiplier_2x8b_GL</code></li> <li>Step 12. Implement and test <code>Multiplier_2x8b_RTL</code></li> <li>Step 13. Implement and test <code>Calculator_GL</code></li> <li>Step 14. Implement and test <code>CalculatorDisplay_GL</code></li> </ul> </li> </ul> <p>Students will almost certainly need to spend significant time outside of their lab session to complete this lab. Students with a lab session early in the week can use their lab session to get started with the help of the course staff and then finish on their own before the deadline. Students with a lab session late in the week can get started on their own and use their lab session to finish their lab with the help of the course staff. Even though Part B does not need to be submitted on GitHub until Thursday, October 3rd, students still must have Part B completed before their lab session during the FPGA week in order to complete the FPGA lab check-off tasks.</p> <p>It is critical for students to work together to complete the lab assignment. It is unlikely one student can complete the entire lab on their own. A very productive approach is to have one student work on the design of a few hardware modules while the other student works on the test benches for those same hardware modules. Then work together to test and debug these modules. Then switch roles and move on the next few modules.</p> <p>Even though this may seem like many steps, several hardware modules are reused from Lab 1. Some hardware modules can be implemented in just a few lines of Verilog (e.g., <code>FullAdder_GL</code>, <code>Mux2_1b_GL</code>, <code>Adder_8b_RTL</code>, <code>Multiplier_2x8b_RTL</code>). It should also be possible to reuse your test cases unchagned to verify hardware modules that have the same interface (e.g., the same test cases can be used for <code>AdderRippleCarry_8b_GL</code>, <code>AdderCarrySelect_8b_GL</code>, and <code>Adder_8b_RTL</code>; similarly, the same test cases can be used for <code>Multiplier_2x8b_GL</code> and <code>Multiplier_2x8b_RTL</code>). Be strategic; work through one step at a time; start early!</p>"},{"location":"ece2300-lab2p1-calc/#1-interface-and-implementation-specification","title":"1. Interface and Implementation Specification","text":"<p>You will be implementing and composing a variety of combinational building blocks including muxes, adders, and multipliers; ultimately you will be composing combinational building blocks to implement a two-function calculator that takes as input two binary values and then calculates either the sum or the product of these two values. This section describe the required interface (i.e., the ports for the module and the module's functional behavior) before describing the required implementation (i.e., what goes inside the module) for each combinational building block.</p>"},{"location":"ece2300-lab2p1-calc/#11-five-bit-numeric-display","title":"1.1. Five-Bit Numeric Display","text":"<p>Recall the five-bit numeric display you implemented in Lab 1 which takes as input a five-bit binary value and outputs two seven-bit values, each of which can be used to control a seven-segment display.</p> <p></p> <p>You should reuse your code from Lab 1. You can choose either the unoptimized or optimized implementation from either partner. Copy this code into <code>BinaryToSevenSeg_GL.v</code>, <code>BinaryToBinCodedDec_GL.v</code>, <code>Display_GL.v</code> in your Lab 2 repo.</p>"},{"location":"ece2300-lab2p1-calc/#12-full-adder","title":"1.2. Full Adder","text":"<p>A full adder adds three one-bit input values to produce a single two-bit output.</p> <p></p> <p>Review the lecture notes to derive the truth table for a full adder and implement this truth table in <code>FullAdder_GL.v</code>. Use either an explicit gate-level network or Boolean equations. Even though we learned from Lab 1 that the FPGA tools will thoroughly optimize your logic, we sill recommend using simplified logic for the <code>sum</code> and <code>cout</code> signals to enable the reader to easily see that this module does indeed implement a full adder.</p>"},{"location":"ece2300-lab2p1-calc/#13-four-bit-ripple-carry-adder","title":"1.3. Four-Bit Ripple-Carry Adder","text":"<p>A four-bit adder performs four-bit binary addition (i.e., adds two four-bit input values to determine a four-bit sum output). A four-bit ripple-carry adder chains together four full-adders to enable adding two four-bit values producing a four-bit sum.</p> <p></p> <p>Review the lecture notes to understand how a four-bit ripple-carry adder implements binary addition. This specific ripple-carry adder includes a dedicated carry input port (<code>cin</code>) since we are going to want to chain multiple instances of the ripple carry adder together to create even larger adders.</p> <p>To implement the ripple-carry adder, we need to take a four-bit input port and use bit slicing to connect each bit of the input port to a different full adder module. We also need to take four one-bit outputs from the four full adders and use bit slicing to connect them to each bit of the four-bit output port. In the above block-level diagram, we indicate bit slicing with a small diagonal line and which bit is being sliced in brackets.</p> <p>Implement a four-bit ripple-carry adder in <code>AdderRippleCarry_4b_GL.v</code> by instantiating four <code>FullAdder_GL</code> modules and correctly connecting all of the ports. You will need three internal wires to implement the carry chain.</p>"},{"location":"ece2300-lab2p1-calc/#14-eight-bit-ripple-carry-adder","title":"1.4. Eight-Bit Ripple-Carry Adder","text":"<p>We can implement an eight-bit ripply-carry adder by simply chaining together two four-bit ripple carry adders.</p> <p></p> <p>We again need to use bit slicing to connect four-bit slices of the input and output ports to the four-bit ripple carry adders.</p> <p>Implement an eight-bit ripple-carry adder in <code>AdderRippleCarry_8b_GL.v</code> by instantiating <code>AdderRippleCarry_4b_GL</code> modules and correctly connecting all of the ports. You will need an internal wire to implement the carry chain.</p>"},{"location":"ece2300-lab2p1-calc/#15-one-bit-two-to-one-multiplexor","title":"1.5. One-Bit Two-to-One Multiplexor","text":"<p>A one-bit two-to-one multiplexor has two input ports and a select input port which chooses which input port should be assigned to the output port.</p> <p></p> <p>Review the lecture notes to derive the truth table for a one-bit two-to-one multiplexor and implement this truth table in <code>Mux2_1b_GL.v</code>. Use either an explicit gate-level network or Boolean equations.</p>"},{"location":"ece2300-lab2p1-calc/#16-four-bit-two-to-one-multiplexor","title":"1.6. Four-Bit Two-to-One Multiplexor","text":"<p>A four-bit two-to-one multiplexor has two four-bit input ports and a selec tinput which chooses which input port should be assigned to the four-bit output port.</p> <p></p> <p>We can implement a four-bit two-to-one multiplexor by using four one-bit two-to-one multiplexors in parallel. The top-level select input is connected to every child mux's select input. In the diagram above, we are using \"fly over\" connections where the select signal \"flys over\" each mux; the arrow heads indicate where the fly over connects to each mux's select input. We use bit slicing to connect each bit of the four-bit input and output ports to the appropropriate one-bit input and output ports of the child muxes.</p> <p>Implement a four-bit two-to-one multiplexor in <code>Mux2_4b_GL.v</code> by instantiating four <code>Mux2_1b_GL</code> modules and correctly connecting all of the ports.</p>"},{"location":"ece2300-lab2p1-calc/#17-eight-bit-two-to-one-multiplexor","title":"1.7. Eight-Bit Two-to-One Multiplexor","text":"<p>We can implement an eight-bit two-to-one multiplexor by simply instantiating two four-bit two-to-one multiplexors.</p> <p></p> <p>We again need to use bit slicing to connect four-bit slices of the input and output ports to the four-bit muxes.</p> <p>Implement an eight-bit two-to-one multiplexor in <code>Mux2_8b_GL.v</code> by instantiating <code>Mux2_4b_GL</code> modules and correctly connecting all of the ports.</p>"},{"location":"ece2300-lab2p1-calc/#18-eight-bit-carry-select-adder","title":"1.8. Eight-Bit Carry-Select Adder","text":"<p>An eight-bit carry-select adder has the same interface as an eight-bit ripple-carry adder but a very different implementation. An eight-bit carry-select adder breaks the addition operation into two parts: a four-bit lower ripple-carry adder is used to calculate the lower four bits of the sum output. Two four-bit upper ripple-carry adders are used to redundantly calculate the sum of the upper four bits; one assumes the carry out from the lower adder is zero and the other assumes the carry out from the lower adder is one. In this way all three four-bit ripple-carry adders can operate in parallel. Once we know the carry output from the lower adder we can use a four-bit two-to-one mux to quickly choose the correct sum for the upper four bits.</p> <p>Review the lectures notes on carry-select adders and implement an eight-bit carry-select adder in <code>AdderCarrySelect_8b_GL</code> by instantiating three <code>AdderRippleCarry_4b_GL</code> modules, one <code>Mux2_4b_GL</code> module, and one <code>Mux2_1b_GL</code> module and then correctly connecting all of the ports. You will likely need some internal wires.</p>"},{"location":"ece2300-lab2p1-calc/#19-eight-bit-register-transfer-level-adder","title":"1.9. Eight-Bit Register-Transfer-Level Adder","text":"<p>All of work in the lab assignments so far has involved using gate-level networks and/or Boolean equations. We will gradually start to experiment with using register-transfer-level (RTL) modeling throughout the rest of the lab assignments. RTL modeling involves working at a higher-level of abstraction. This can drastically increase designer productivity but only if the designer always keeps in mind the hardware we are actually modeling! It is possible to use Verilog RTL which does not model any kind of real hardware.</p> <p>When using Boolean equations, we are only allowed to use a very limited number of Verilog operators (<code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>). The simplest form of RTL modeling enables using more sophisticated operators. For example, instead of implementing an eight-bit ripple-carry adder or an eight-bit carry-select adder, we can use RTL modeling through the <code>+</code> operator to implement an eight-bit adder in a single line of Verilog.</p> <p>For example, here is an eight-bit RTL adder without a carry input or carry output:</p> <pre><code>module Adder_8b_RTL\n(\n  input  logic [7:0] in0,\n  input  logic [7:0] in1,\n  output logic [7:0] sum\n);\n\n  assign sum = in0 + in1;\n\nendmodule\n</code></pre> <p>Notice how we use <code>logic</code> instead of <code>wire</code> in RTL modeling; the <code>logic</code> datatype is meant for modeling at high levels of abstraction. Clearly this is much more productive than implementing a ripple-carry or carry-select adder using a gate-level network or Boolean equations. However, we have also given up control over the exact adder implementation. When using RTL modeling, we usually give the FPGA tools more freedom to choose the detailed implementation of some combinational building blocks like adders.</p> <p>In this lab assignment, we want our adders to have carry input and carry output ports. We can use the following RTL to achieve implement this kind of adder.</p> <pre><code>module Adder_8b_RTL\n(\n  input  logic [7:0] in0,\n  input  logic [7:0] in1,\n  input  logic       cin,\n  output logic       cout,\n  output logic [7:0] sum\n);\n\n  assign {cout,sum} = in0 + in1 + {7'b0,cin};\n\nendmodule\n</code></pre> <p>We must zero extend <code>cin</code> since Verilator will not allow us to add signals of different bitwidths. We assign the output to a concetentation of two signals so we can retrieve the carry output.</p> <p>Implement an eight-bit RTL adder in <code>Adder_8b_RTL</code>.</p>"},{"location":"ece2300-lab2p1-calc/#110-one-bit-by-eight-bit-multiplier","title":"1.10. One-bit by Eight-Bit Multiplier","text":"<p>A one-bit by eight-bit multiplier multiplies an eight-bit input value by a one-bit input value to determine an eight-bit product output. Review the lecture notes for more on multipliers and then implement this simple multiplier in <code>Multiplier_1x8b_GL</code>. Use either an explicit gate-level network or Boolean equations.</p>"},{"location":"ece2300-lab2p1-calc/#111-two-bit-by-eight-bit-multiplier","title":"1.11. Two-bit by Eight-Bit Multiplier","text":"<p>A two-bit by eight-bit multiplier multiplies an eight-bit input value by a two-bit input value to determine an eight-bit product output.</p> <p>We use two one-bit by eight-bit multipliers to create the two partial products, and then we use an eight-bit adder to sum these two partial products to get the final result. If the output overflows then the implementation should truncate by using the lower eight bits of the product.</p> <p>Review the lecture nodes for more on multipliers and then implement this multiplier in <code>Multiplier_2x8b_GL</code> by instantiating two <code>Multiplier_1x8b_GL</code> modules and one <code>AdderCarrySelect_8b_GL</code> and correctly connecting all of the ports. You will likely need some internal wires. Note that you may also have some unused signals (i.e., the carry output from the adder and the most significant bit of the sum). These unused signals will cause <code>verilator</code> linting errors. If a signal has <code>unused</code> in its name, then <code>verilator</code> will assume the designer explicitly wants this signal to be unused. So you can use the following Verilog snippet to avoid unused signal errors for a wire named <code>foo</code>.</p> <pre><code>wire foo_unused;\nassign foo_unused = foo;\n</code></pre> <p>Feel free to use such snippets with an associated comment if you are confident that the signal really should be unused.</p>"},{"location":"ece2300-lab2p1-calc/#112-two-bit-by-eight-bit-register-transfer-level-multiplier","title":"1.12. Two-bit by Eight-Bit Register-Transfer-Level Multiplier","text":"<p>Similar to our eight-bit RTL adder, we can also implement a two-bit by eight-bit RTL multplier. Instead of implementing the multiplier by instantiating various hardware modules, we can use RTL modeling through the <code>*</code> operator to implement an eight-bit multiplier in a single line of Verilog. Implement such a two-bit by eight-bit RTL multiplier in <code>Multiplier_8b_RTL</code>.</p>"},{"location":"ece2300-lab2p1-calc/#113-two-function-calculator","title":"1.13. Two-Function Calculator","text":"<p>We can now put our adder and multiplier together using an eight-bit two-to-one mux to create a two-function calculator. The calculator has an <code>op</code> input to select which operation we want to perform. If <code>op</code> is zero then we perform addition; if <code>op</code> is one then we perform multiplication. Note that you will need to connect just the least-significant two bits of input <code>in1</code> to the multiplier's input <code>in1</code>.</p> <p>Implement the calculator in <code>Calculator_GL.v</code> by instantiating an <code>AdderCarrySelect_8b_GL</code> module, an <code>Multiplier_2x8b_GL</code> module, and a <code>Mux2_8b_GL</code> module and then correctly connecting all of the ports. You will likely need some internal wires. You may also need to use an extra Verilog snippet to avoid unused signal errors.</p>"},{"location":"ece2300-lab2p1-calc/#114-two-function-calculator-with-seven-segment-displays","title":"1.14. Two-Function Calculator with Seven-Segment Displays","text":"<p>We are finally now ready to implement the complete calculator with the seven-segnment displays. The inputs are only five bits, so you will need to zero extend these values when connecting them to the inputs of the calculator. Both inputs and the output of the calculator should be attached to an instance of the five-bit numeric display module you developed in the previous lab. Implement the complete calculator in <code>CalculatorDisplay_GL.v</code> by instantiating a <code>Calculator_GL</code> module and three <code>Display_GL</code> modules and then correctly connecting all of the ports.</p>"},{"location":"ece2300-lab2p1-calc/#2-testing-strategy","title":"2. Testing Strategy","text":"<p>You are responsible for developing an effective testing strategy to ensure all implementations are correct. Writing tests is one of the most important and challenging aspects of designing hardware. Hardware engineers often spend far more time implementing tests than they do implementing the actual hardware design.</p>"},{"location":"ece2300-lab2p1-calc/#21-basic-testing","title":"2.1. Basic Testing","text":"<p>We will be using the same lightweight testing framework from Lab 1. For each hardware module, we provide a test bench for you to use along with one basic test case. Unlike in Lab 1, we will now be using an automated build system to simplify linting, compiling, and running tests. You can run the basic tests for all hardware modules using the generated <code>Makefile</code>.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc/build\n% make check\n</code></pre> <p>You can also build and run a single test simulator.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc/build\n% make BinaryToSevenSeg_GL-test\n% ./BinaryToSevenSeg_GL-test\n</code></pre> <p>You can specify which specific test case to run on the command line and also dump waveforms that can be viewed using Surfer.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc/build\n% make BinaryToSevenSeg_GL-test\n% ./BinaryToSevenSeg_GL-test +test-case=1\n% ./BinaryToSevenSeg_GL-test +test-case=1 +dump-vcd=waves.vcd\n</code></pre>"},{"location":"ece2300-lab2p1-calc/#22-exhaustive-testing","title":"2.2. Exhaustive Testing","text":"<p>The following test benches are for hardwware modules with a limited number of inputs, and thus you can (and should) use exhaustive testing:</p> <ul> <li><code>BinaryToSevenSeg_GL-test.v</code></li> <li><code>BinaryToBinCodedDec_GL-test.v</code></li> <li><code>Display_GL-test.v</code></li> <li><code>FullAdder_GL-test.v</code></li> <li><code>Mux2_1b_GL-test.v</code></li> </ul> <p>To get started, you should copy your exhaustive test cases from Lab 1 into <code>BinaryToSevenSeg_GL-test.v</code>, <code>BinaryToBinCodedDec_GL-test.v</code>, and <code>Display_GL-test.v</code>. Verify that all of your basic and exhaustive tests for these modules are passing.</p>"},{"location":"ece2300-lab2p1-calc/#23-directed-testing","title":"2.3. Directed Testing","text":"<p>The remaining hardware modules all have many more inputs and thus would required hundreds or even thousands of checks to implement exhaustive testing. So for the remaining hardware modules you can use directed testing to check for specific corner cases. You should implement a few directed test cases for each hardware module where exhaustive testing is not applicable. Each directed test case should focus on testing a very specific kind of functionality and they should contain 2-10 checks. Be sure to add your tests cases to the list in the <code>initial</code> block and to check the output of the test simulator to confirm that your directed test cases are running and testing what you expect them to. Consider purposefully inserting a bug in your designs to see if your directed test cases will catch the bug.</p>"},{"location":"ece2300-lab2p1-calc/#24-random-testing","title":"2.4. Random Testing","text":"<p>Directed testing is useful for testing the known unknowns, but what about the unknown unknowns? How should we test for corner cases we have not even thought of yet? Random testing can help increase our testing coverage and increase our confident that our hardware design is functionally correct. You should implement one random test case for each hardware module where exhaustive testing is not applicable. Random test cases should include a for loop with approximately 50 iterations. Each iteration should: (1) generate random input values; (2) use Verilog test code to programmatically determine the correct output values; and (3) use the <code>check</code> task to ensure the design-under-test produces the correct outputs give the corresponding random inputs.</p>"},{"location":"ece2300-lab2p1-calc/#23-simulator","title":"2.3. Simulator","text":"<p>We have provided you a simple calculator simulator which will emulate what you will prototype during the Lab 2 FPGA week. After finishing your implementation for the complete two-function calculator, you can build and run the calculator simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab2-calc/build\n% make calculator-sim\n% ./calculator-sim +in0-switches=00100 +in1-switches=00011 +button=0\n% ./calculator-sim +in0-switches=00100 +in1-switches=00011 +button=1\n</code></pre> <p>The switches are connected to the inputs of the calculator, andt he button is connected to the <code>op</code> input of the calculator. The calculator simulator will show what the six seven segment displays would look like on the FPGA prototype.</p>"},{"location":"ece2300-lab2p1-calc/#3-lab-code-submission","title":"3. Lab Code Submission","text":"<p>Your code quality score will be based on the way you format the text in your source files, proper use of comments, deletion of instructor comments, and uploading the correct files to GitHub (only source files should be uploaded, no generated build files). Note that students must remove unnecessary comments that are provided by instructors in the code distributed to students. Students must not commit executable binaries or any other unnecessary files.</p> <p>To submit your code you simply upload it to GitHub. Your design code will be assessed both in terms of functionality and code quality. Your functionality score will be determined by running your code against a series of tests developed by the instructors to test its correctness. Your test bench code will also be assessed both in terms of verification quality and code quality. Here is how we will be testing your code submission for Lab 2 Part A:</p> <pre><code>% mkdir -p ${HOME}/ece2300/submissions\n% cd ${HOME}/ece2300/submissions\n% git clone git@github.com:cornell-ece2300/groupXX\n\n% cd ${HOME}/ece2300/submissions/groupXX/lab2-calc\n% mkdir -p build\n% cd build\n% ../configure\n% make check-partA\n</code></pre> <p>Here is how we will be testing your code submission for Lab 2 Part B:</p> <pre><code>% mkdir -p ${HOME}/ece2300/submissions\n% cd ${HOME}/ece2300/submissions\n% git clone git@github.com:cornell-ece2300/groupXX\n\n% cd ${HOME}/ece2300/submissions/groupXX/lab2-calc\n% mkdir -p build\n% cd build\n% ../configure\n% make check\n</code></pre>"},{"location":"ece2300-lab3ab-music/","title":"Lab 3 (Parts A &amp; B): Music Player - Implementation and Verification","text":"<p>Lab 3 will give you experience designing, implementing, testing, and prototyping combinational and sequential logic using the Verilog hardware description language. The lab reinforces several lecture topics including sequential logic gates, finite-state machines (FSMs), and sequential building blocks. More specifically, the lab will give students experience with: latches, flip-flops, and registers; Moore and Mealy FSMs; and counters. The lab will continue to provide opportunities to leverage the three key abstraction principles: modularity, hierarchy, and regularity. The lab will also enable students to better understand the connection between simulation and prototyping.</p> <p>You will be implementing a music player that takes as input a song selection (via the switches) and a start song signal (via a push button). The music player will then play the chosen song by generating a square wave at appropriate note frequencies suitable for use with a piezoelectric buzzer. An idle signal is displayed using an LED so that user knows when the player is ready to play a new song. The music player will make use of the adders and muxes from Lab 2. The song selection and the current note are both displayed using seven-segment displays from Lab 1.</p> <p>This lab also serves as a transition from lower-level gate-level (GL) modeling to higher-level register-transfer-level (RTL) modeling. Some of parts of your design will use explicit GL modeling or Boolean equations, while other parts of your design will use RTL modeling. Students will have a chance to appreciate how RTL modeling can improve productivity but with less control over the final hardware implementation.</p> <p>The lab includes four parts:</p> <ul> <li>Part A: Note Player Implementation and Verification</li> <li>Part B: Music Player Implementation and Verification</li> <li>Part C: Music Player FPGA Analysis and Prototyping</li> <li>Part D: Music Player Report</li> </ul> <p>Parts A and B are submitted by simply pushing the appropriate code to GitHub. Part A is due on Thursday, October 17 at 11:59pm. Part B is due on Thursday, October 24 at 11:59pm. Even though Part B does not need to be submitted on GitHub until Thursday, October 24, students still must have Part B completed before their lab session during the FPGA week in order to complete Part C! Students can use the time after their lab session to continue improving their code and verification quality. Part D is due three days after the student's assigned lab session. All parts must be done with your assigned lab partner. You can confirm your assigned partner on Canvas (Click on People, then Groups, then search for your name to find your lab group).</p> <p>This handout assumes that you have read and understand the course tutorials and that you have attended the discussion sections. To get started, use VS Code to log into an <code>ecelinux</code> server, source the setup script, and clone your individual remote repository from GitHub:</p> <pre><code> % source setup-ece2300.sh\n % mkdir -p ${HOME}/ece2300\n % cd ${HOME}/ece2300\n % git clone git@github.com:cornell-ece2300/groupXX\n % cd ${HOME}/ece2300/groupXX\n % tree\n</code></pre> <p>where <code>XX</code> should be replaced with your group number. You can both pull and push to your remote repository. If you have already cloned your remote repository, then use <code>git pull</code> to ensure you have any recent updates before working on your lab assignment.</p> <pre><code> % cd ${HOME}/ece2300/groupXX\n % git pull\n % tree\n</code></pre> <p>Go ahead and create a build directory in the <code>lab3-music</code> directory for this lab, and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>Your repo contains the following files which are part of the automated build system:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> </ul> <p>The following table shows all of the hardware modules you will be working with in Lab 3.</p> <p></p> <p>Before starting, you should copy over all of the listed hardware modules and the associated test benches for the seven-segment display from Lab 1 and the eight-bit ripple-carry adder and multiplexors from Lab 2. Make sure all of these hardware modules pass all of your test cases.</p> <p>Lab 3 requires implementing and verifying 23 hardware modules. While this might seem like a daunting task, many of these hardware modules require less than five lines of Verilog code. For many of the test benches we provide students with a template so they need only enter the expected outputs. Test cases are reused across the GL and RTL versions of the same hardware module. Start from the D latch and systematically work your way down the table. Implement the GL and RTL versions at the same time. Never move on to the next row in the table until you have thoroughly tested the previous row.</p> <p>Remember that GL implementations must be implemented using either explicit gate-level modeling or Boolean equations. For these designs, students are only allowed to use these Verilog constructs:</p> <ul> <li><code>wire</code>, <code>assign</code></li> <li><code>not</code>, <code>and</code>, <code>nand</code>, <code>or</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code></li> <li><code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code></li> <li><code>1'b0</code>, <code>1'b1</code>, <code>1'd0</code>, <code>1'd1</code>, and other literals</li> <li><code>{}</code> (concatenation operator)</li> <li><code>{N{}}</code> (repeat operator)</li> <li>module instantiation</li> </ul> <p>Hardware modules marked in the table as GL* must only use explicit gate-level modeling (i.e., you cannot use <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>).</p> <p>RTL implementations can use all of the GL constructs in addition to the following Verilog constructs.</p> <ul> <li><code>logic</code></li> <li><code>+</code>, <code>-</code></li> <li><code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;&gt;</code></li> <li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li> <li><code>&amp;</code>, <code>~&amp;</code>, <code>|</code>, <code>~|</code>, <code>^</code>, <code>^~</code> (reduction operators)</li> <li><code>?:</code> (ternary operator)</li> <li><code>always_comb</code>, <code>always_ff @(posedge clk)</code></li> <li><code>if</code>, <code>else if</code>, <code>endif</code></li> <li><code>case</code>, <code>default</code>, <code>endcase</code></li> </ul> <p>Note that some hardware modules have more specific restrictions; see the source comments for more details. Using unallowed Verilog constructs will result in significant penalties for code functionality and code quality. If you have any questions on what Verilog constructs can and cannot be used, please ask an instructor. There are no restrictions on Verilog constructs in test benches.</p> <p>It is critical for students to work together to complete the lab assignment. It is unlikely one student can complete the entire lab on their own. A very productive approach is to have one student work on the design of a few hardware modules while the other student works on the test benches for those same hardware modules. Then work together to test and debug these modules. Then switch roles and move on the next few modules.</p>"},{"location":"ece2300-lab3ab-music/#1-interface-and-implementation-specification","title":"1. Interface and Implementation Specification","text":"<p>You will be implementing and composing a variety of combinational and sequential hardware modules including adders, muxes, latches, flip-flops, registers, subtractors, and counters; ultimately you will be composing these hardware modules to implement a music player. This section describe the required interface (i.e., the ports for the module and the module's functional behavior) before describing the required implementation (i.e., what goes inside the module) for each hardware module.</p>"},{"location":"ece2300-lab3ab-music/#11-latches-and-flip-flops","title":"1.1. Latches and Flip-Flops","text":"<p>You will need to implement a GL latch and three GL/RTL flip-flops:</p> <ul> <li><code>DLatch</code>: D latch (level high, transparent when clock is one)</li> <li><code>DFF</code>: D flip-flop (positive edge triggered)</li> <li><code>DFFR</code>: D flip-flop with reset signal</li> <li><code>DFFRE</code>: D flip-flop with reset and enable signals</li> </ul> <p>You should consult the lecture notes for the GL implementation of these latches and flip-flops. You just need to directly map the implementation from the lecture notes using explicit gate-level modeling. Do not use Boolean equations when implementing these latches and flip-flops!</p> <p>Recall from the discussion sections that we will need to make use of an <code>always_ff</code> block for RTL modeling of sequential logic. Here is an example of how to implement a D flip-flop using an <code>always_ff</code> block:</p> <pre><code>  always_ff @( posedge clk ) begin\n    q &lt;= d;\n  end\n</code></pre> <p>This <code>always_ff</code> block will execute on the positive edge (<code>posedge</code>) of the clock signal (<code>clk</code>). We are using a special non-blocking assignment (<code>&lt;=</code>) which is meant to be used in <code>always_ff</code> blocks. The semantics of a non-block assignment are: (1) right before the rising edge, the right-hand side of every non-blocking assignment in the entire design is evaluated and the result is saved; (2) right after the rising edge, the saved values are assigned to the signal on the left-hand side. This enables us to model flip-flops.</p> <p>Note that this the only form of an <code>always_ff</code> block you are allowed to use in this course. You are not allowed to use <code>negedge</code> and you are not allowed to trigger an <code>always_ff</code> with any other signals (e.g., in this course, you are not allowed to include reset (<code>rst</code>) in the sensitivity list for an <code>always_ff</code>).</p> <p>You can use other RTL operations within an <code>always_ff</code> block. For example, you can use an if/else conditional operation within an <code>always_ff</code> block to model a D flip-flop with a (synchronous) reset signal:</p> <pre><code>  always_ff @( posedge clk ) begin\n    if ( rst )\n      q &lt;= 0;\n    else\n      q &lt;= d;\n  end\n</code></pre> <p>Note that in this course we will only allow using an <code>always_ff</code> block in very specific modules. Namely within the implementation of single-bit flip-flops (i.e., <code>DFF_RTL</code>, <code>DFFR_RTL</code>, <code>DFFRE_RTL</code>) and within the implementation of the multi-bit registers (e.g., <code>Register_8b_RTL</code>, <code>Register_16b_RTL</code>). Students are not allowed to use an <code>always_ff</code> anywhere else in their hardware designs. If a hardware design needs sequential logic, then the design should instantiate one of these single-bit flip-flops or multi-bit registers. This restriction is critical to enabling new Verilog designers to know exactly what hardware is being implemented. Arbitrarily using <code>always_ff</code> blocks can quickly lead to incredibly complicated hardware models with no hope of understanding what hardware we are actually implementing.</p> <p>Once you have finished implementing all of the latches and flip-flops, take a minute to appreciate the relationship between the GL and RTL implementations. The RTL implementations are just a different way of modeling the hardware within the GL implementation. The FPGA tools will synthesize the RTL implementation into hardware very similar to what is in the GL implementation.</p>"},{"location":"ece2300-lab3ab-music/#12-multi-bit-registers","title":"1.2. Multi-Bit Registers","text":"<p>As discussed in lecture, we can create a GL multi-bit register by simply instantiating a number of GL flip-flops in parallel. The data input (<code>d</code>) and data output (<code>q</code>) of each flip-flop should be connected to their corresponding bit of the register's multi-bit input and output ports. The clock, reset, and enable signals should be connected to each flip-flop. We need an GL eight-bit register for use in the GL count-down counter.</p> <p>For RTL multi-bit registers there is no need to instantiate a number of RTL flip-flops. We can instead model a multi-bit register using a single <code>always_ff</code> block. A single non-blocking assignment can be used to assign the multi-bit input to the multi-bit output on the rising edge of the clock. We need RTL eight-bit and 16-bit registers for use in various more complex RTL hardware modules.</p>"},{"location":"ece2300-lab3ab-music/#13-eight-bit-subtractor","title":"1.3. Eight-Bit Subtractor","text":"<p>We need a GL eight-bit subtractor to implement the count-down counter. Our subtractor will represent negative numbers using the two's complement number system, which means we can efficiently implement a two's complement subtractor using the same eight-bit ripple-carry adder you developed in Lab 2. Our subtractor does not need a carry input nor a carry output.</p>"},{"location":"ece2300-lab3ab-music/#14-count-down-counters","title":"1.4. Count-Down Counters","text":"<p>The count-down counter has the following interface:</p> <p></p> <p>The reset input (<code>rst</code>) should reset the internal counter to zero. When the load input (<code>load</code>) is high, then the counter should load the value on the input (<code>in</code>) into the internal counter.</p> <p>When <code>load</code> is not high (no new value is being loaded), the counter should decrement by one every cycle until it reaches zero, at which point the done output (<code>done</code>) should be set to one. Once the counter is done, it should no longer decrement until a new value is loaded.</p> <p>The input (<code>in</code>) must be positive. Since we are using a two's complement number representation, the maximum allowed value for the input is 127.</p> <p>Here is a trace of the expected output when counting down from three.</p> <pre><code>cyc  rst load in        in     count    count done\n  0: 0   0    00000000 (  0) &gt; 00000000 (  0) 1\n  1: 0   1    00000011 (  3) &gt; 00000000 (  0) 1\n  2: 0   0    00000000 (  0) &gt; 00000011 (  3) 0\n  3: 0   0    00000000 (  0) &gt; 00000010 (  2) 0\n  4: 0   0    00000000 (  0) &gt; 00000001 (  1) 0\n  5: 0   0    00000000 (  0) &gt; 00000000 (  0) 1\n</code></pre> <p>Pay careful attention to the exact cycle the output count is set to three and the exact cycle the done signal is set to one. Your counter must produce the exact same cycle-level behavior.</p> <p>You are responsible for designing your own GL eight-bit counter that meets this specification. Your GL implementation must make use of the GL muxes, GL registers, and GL subtractor. Do not put any logic on the reset signal. The reset signal should be directly attached to the reset input port of the register without any logic. Do not put any logic on the clock. The clock signal should be directly attached to the clock input port of the register without any logic. Start by drawing a block-level diagram. You will need to show this diagram in lab for Part C and include this diagram in the report for Part D.</p> <p>You are also responsible for designing your own RTL eight-bit and 16-bit counters that meet this specification. Your RTL counters must explicitly instantiate an RTL register for the sequential logic, and then use a single <code>always_comb</code> block for your combinational logic. You cannot directly use an <code>always_ff</code> block in your RTL counter. You must explicitly instantiate an RTL register. Do not put any logic on the reset signal. The reset signal should be directly attached to the reset input port of the register without any logic. Do not put any logic on the clock. The counters are examples of flat RTL modules, since they do not instantiate any hardware modules other than the a register.</p>"},{"location":"ece2300-lab3ab-music/#15-note-player","title":"1.5. Note Player","text":"<p>The note player generates a square wave at a given frequency forever. It includes a control unit and a count-down counter.</p> <p></p> <p>The clock and reset signals are not shown in the above block diagram. The period is provided as an input port and is assumed to never change after reset. The control unit should be implemented using the following five-state Moore FSM.</p> <p></p> <p>The outputs are specified in each state: cl stands for <code>count_load</code> and n stands for <code>note</code>. The FSM must use the following state encoding:</p> <pre><code> State      Encoding\n---------------------\n RESET      4'b0000\n LOAD_HIGH  4'b1000\n WAIT_HIGH  4'b0100\n LOAD_LOW   4'b0010\n WAIT_LOW   4'b0001\n</code></pre> <p>In the LOAD_HIGH state, the FSM should load the period into the count-down counter, set the note output to be high, and move into the WAIT_HIGH. In the WAIT_HIGH state, the FSM should continue to set the note output to be high. Once the counter is done, the FSM should move into the LOAD_LOW state. In the LOAD_LOW state, the FSM should load the period into the count-down counter, set the note output to be low, and move into the WAIT_LOW. In the WAIT_LOW state, the FSM should continue to set the note output to be low. Once the counter is again done, the FSM should move back to the LOAD_HIGH state to repeat the sequence.</p> <p>Here is a trace of the expected output when the period is five.</p> <pre><code>cyc  rst period     state state      note\n------------------------------------------\n  0: 0   00000101 &gt; 0000 (RESET    ) 0\n  1: 0   00000101 &gt; 1000 (LOAD_HIGH) 1\n  2: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  3: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  4: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  5: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  6: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  7: 0   00000101 &gt; 0100 (WAIT_HIGH) 1\n  8: 0   00000101 &gt; 0010 (LOAD_LOW ) 0\n  9: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 10: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 11: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 12: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 13: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 14: 0   00000101 &gt; 0001 (WAIT_LOW ) 0\n 15: 0   00000101 &gt; 1000 (LOAD_HIGH) 1\n</code></pre> <p>Pay careful attention to the exact cycle of each state transition and the exact cycles the note is high and low. When you load the count-down counter with the value five it will be zero on the sixth cycle. Your note player must produce the exact same cycle-level behavior.</p> <p>The GL version of the note player control unit should instantiate four <code>DFFRE_GL</code> modules to store the four-bit FSM state. The next state combinational logic and output combinational logic should be implemented using Boolean equations. The GL version of the note player just composes the GL note player control unit with the GL count-down counter.</p> <p>The RTL version of the note player control unit should instantiate four <code>DFFRE_RTL</code> modules to store the four-bit FSM state. The next state combinational logic should be implemented using a single, dedicated <code>always_comb</code> block. The output combinational logic should be implemented using a separate <code>always_comb</code> block. The control unit is an example of a flat RTL module, since it does not instantiate any hardware modules other than the flip-flops. The RTL version of the note player just composes the RTL note player control unit with the RTL count-down counter.</p>"},{"location":"ece2300-lab3ab-music/#16-multi-note-player","title":"1.6. Multi-Note Player","text":"<p>The multi-note player can produce one of seven notes or a rest for a specified duration by composing a counter, mux, register, and seven note players.</p> <p></p> <p>The clock and reset signals are not shown in the above block diagram. The periods are provided as an input ports and are assumed to never change after reset. We will only be implementing an RTL version of the multi-note player, and so we will use the RTL version of each of these hardware modules. This is an example of structural RTL, since it does not directly include any <code>always_comb</code> blocks and instead just instantiates other RTL modules.</p> <p>To play a note using the multi-note player, the <code>play_note</code> input is set to the desired note (i.e., which of the seven note period inputs to use), the <code>play_duration</code> input is set to the desired duration, and the <code>play_load</code> input is set high for one cycle. The desired note is produced on the <code>note</code> output and when the duration is done the <code>play_done</code> output is set high. The <code>note_sel</code> output is provided for debugging.</p> <p>Note that when the note select (<code>note_sel</code>) is zero, then the multi-note player should produce a rest (i.e., the note should stay low). You will need to implement a RTL eight-bit 2-to-1 multiplexor and a RTL one-bit 8-to-1 multiplexor. Once these are implemented and tested you can compose them with your RTL eight-bit count-down counter and your RTL note players.</p>"},{"location":"ece2300-lab3ab-music/#17-music-player","title":"1.7. Music Player","text":"<p>The music player plays a song stored in memory. It includes a control unit and a multi-note player.</p> <p></p> <p>The clock and reset signals are not shown in the above block diagram. The periods are provided as an input ports and are assumed to never change after reset. We will only be implementing an RTL version of the music player. The music player control unit will include a Mealy FSM which should be implemented using flat RTL.</p> <p>Songs are stored in memory as a sequence of notes. The memory is arranged as 64K 4-byte words. The memory interface has a memory request valid port (<code>memreq_val</code>) and a memory address port (<code>memreq_addr</code>). The memory address is a byte address. To read a value from memory, we need to set the memory address to the desired byte address and set the memory request valid signal high. The data will be returned combinationally (i.e., on that same cycle) on the <code>memresp_data</code> port.</p> <p>Our music payer can play songs with up to seven notes and a rest. Each note is stored in one 4-byte word using the following encoding:</p> <pre><code> NOTE      Encoding\n------------------------\n REST      32'h00000000\n NOTE_G    32'h00000001\n NOTE_A    32'h00000002\n NOTE_B    32'h00000003\n NOTE_C    32'h00000004\n NOTE_D    32'h00000005\n NOTE_E    32'h00000006\n NOTE_F    32'h00000007\n SONG_END  32'hffffffff\n</code></pre> <p>Each song can have a maximum of 128 notes. The value <code>32'hFFFF_FFFF</code> (i.e., all ones) is used to indicate the end of a song. The music player can play up to 32 songs; so the music player will only use \\(32 \\text{ songs} \\cdot \\frac{128 \\text{ notes}}{\\text{song}} \\cdot \\frac{4B}{\\text{note}} = 16KB\\) of storage. The song memory map (i.e., how the songs are arranged in memory) looks like this:</p> <pre><code> address song note\n-------------------\n 0x0000  0    0    start of song 0\n 0x0004  0    1\n 0x0008  0    2\n ...\n 0x01fc  0    127\n 0x0200  1    0    start of song 1\n 0x0204  1    1\n 0x0204  1    1\n ...\n 0x03fc  1    127\n 0x0400  2    0    start of song 2\n ...\n</code></pre> <p>The control unit will need its own memory address counter to keep track of the memory address of the note we are currently playing. This counter is initialized using the song select input (<code>song_sel</code>). From the above memory map, we can see that the starting memory address for a song is just:</p> <pre><code>  { 2'b0, song_sel, 9'b0 }\n</code></pre> <p>The counter will then need to increment this memory by four (because we are using memory byte addresses and each note is four bytes) so the music player can read the next note. This counter should be implemented by instantiating a register and then using flat combinational logic within the music player. You cannot use your previously developed counter since you need to increment by four each time.</p> <p>The control unit should be implemented using the following four-state Mealy FSM.</p> <p></p> <p>The FSM must use the following state encoding:</p> <pre><code> State      Encoding\n---------------------\n RESET      2'b00\n IDLE       2'b01\n SET_NOTE   2'b10\n WAIT_NOTE  2'b11\n</code></pre> <p>In the IDLE state, the music player should initialize the memory address counter to the desired song using the song select input (<code>song_sel</code>), wait until start song is high, and then move into the SET_NOTE state. In the SET_NOTE state, the FSM should read the next note from memory by using the address from the memory address counter and setting the memory request valid signal high. Since the memory is combinational, the SET_NOTE state should also handle the memory response. If the note read from memory is SONG_END, then the FSM should return to the IDLE state. Otherwise, the FSM should set the control signals for the multi-note player appropriately, increment the memory address counter, and move into the WAIT_NOTE state. In the WAIT_NOTE state, the FSM should wait until the multi-note player is done before moving back into the SET_NOTE state to read the next note from memory.</p> <p>We recommend taking an incremental approach as opposed to just implementing the entire FSM and counter at once. Start by implementing just implementing the FSM without support for playing more than one note nor support for playing more than one song. Have your FSM go from RESET, to IDLE, to SET_NOTE, to WAIT_NOTE and just stay in WAIT_NOTE forever. Get this working and look at the trace and waveforms to confirm that your FSM is moving through the states correctly and setting the control signals for the multi-note player correctly. Then incrementally add support for moving from WAIT_NOTE back to SET_NOTE but without a counter. This should just play the same note over and over. Once this is working, incrementally add support for the counter. Once this is working, incrementally add support for moving from SET_NOTE back to IDLE and being able to play more than one song.</p>"},{"location":"ece2300-lab3ab-music/#2-testing-strategy","title":"2. Testing Strategy","text":"<p>You are responsible for developing an effective testing strategy to ensure all implementations are correct. Writing tests is one of the most important and challenging aspects of designing hardware. Hardware engineers often spend far more time implementing tests than they do implementing the actual hardware design.</p>"},{"location":"ece2300-lab3ab-music/#21-basic-testing","title":"2.1. Basic Testing","text":"<p>We will be using the same lightweight testing framework from the previous labs. For each hardware module, we provide a test bench for you to use along with one basic test case. We will be using the same automated build system from Lab 2 to simplify linting, compiling, and running tests. You can run the basic tests for all hardware modules using the generated <code>Makefile</code>.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make check\n</code></pre> <p>You can also build and run a single test simulator.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make DLatch_GL-test\n% ./DLatch_GL-test\n</code></pre> <p>You can specify which specific test case to run on the command line and also dump waveforms that can be viewed using Surfer.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make DLatch_GL-test\n% ./DLatch_GL-test +test-case=1\n% ./DLatch_GL-test +test-case=1 +dump-vcd=waves.vcd\n</code></pre>"},{"location":"ece2300-lab3ab-music/#22-exhaustive-testing","title":"2.2. Exhaustive Testing","text":"<p>The following test benches are for hardware modules with a limited number of inputs, and thus you can (and should) use exhaustive testing:</p> <ul> <li><code>DLatch_GL-test.v</code></li> <li><code>DFF_GL-test.v</code>, <code>DFF_RTL-test.v</code></li> </ul> <p>We provide test case templates for these test benches so all you need to do is fill in the expected output. You do not need to add any more test cases. Notice that <code>DFF_GL</code> and <code>DFF_RTL</code> have the exact same interface and thus will use the exact same test cases. We have refactored the test cases for these hardware modules into <code>DFF-test-cases.v</code> and then included these test cases in <code>DFF_GL-test.v</code> and <code>DFF_RTL-test.v</code>. This way we only need to write the test cases once.</p>"},{"location":"ece2300-lab3ab-music/#23-directed-testing","title":"2.3. Directed Testing","text":"<p>The remaining hardware modules all have many more inputs and thus would required hundreds or even thousands of checks to implement exhaustive testing. So for the remaining hardware modules you can use directed testing to check for specific corner cases.</p> <p>We provide test case templates for the following test benches so all you need to do is fill in the expected output. You do not need to add any more test cases.</p> <ul> <li><code>DFFR_GL-test.v</code>, <code>DFFR_RTL-test.v</code></li> <li><code>DFFRE_GL-test.v</code>, <code>DFFRE_RTL-test.v</code></li> <li><code>Register_8b_GL-test.v</code>, <code>Register_8b_RTL-test.v</code></li> <li><code>Register_16b_RTL-test.v</code></li> </ul> <p>For some of these these we have again refactored the test cases for these hardware modules into a separate <code>-test-cases.v</code> file. You must write your own directed test cases for the following test benches:</p> <ul> <li><code>Subtractor_8b_GL-test.v</code></li> <li><code>Counter_8b_GL-test.v</code>, <code>Counter_8b_RTL-test.v</code>, <code>Counter_16b_RTL-test.v</code></li> <li><code>Mux2_8b_RTL-test.v</code>, <code>Mux8_1b_RTL-test.v</code></li> <li><code>NotePlayerCtrl_GL-test.v</code>, <code>NotePlayerCtrl_RTL-test.v</code></li> <li><code>NotePlayer_GL-test.v</code>,<code>NotePlayer_RTL_RTL-test.v</code></li> <li><code>MultiNotePlayer_RTL-test.v</code></li> </ul> <p>You do not need to unit test <code>MusicPlayerCtrl_RTL</code> and we provide you tests for <code>MusicPlayer_RTL</code>.</p> <p>Remember, each directed test case should focus on testing a very specific kind of functionality and they should contain 2-10 checks. Be sure to add your tests cases to the list in the <code>initial</code> block and to check the output of the test simulator to confirm that your directed test cases are running and testing what you expect them to. Consider purposefully inserting a bug in your designs to see if your directed test cases will catch the bug.</p>"},{"location":"ece2300-lab3ab-music/#24-random-testing","title":"2.4. Random Testing","text":"<p>Directed testing is useful for testing the known unknowns, but what about the unknown unknowns? How should we test for corner cases we have not even thought of yet? Random testing can help increase our testing coverage and increase our confident that our hardware design is functionally correct. You should implement one random test case for each of the following hardware modules:</p> <ul> <li><code>Subtractor_8b_GL-test.v</code></li> <li><code>Counter_8b_GL-test.v</code>, <code>Counter_8b_RTL-test.v</code>, <code>Counter_16b_RTL-test.v</code></li> <li><code>Mux2_8b_RTL-test.v</code>, <code>Mux8_1b_RTL-test.v</code></li> <li><code>NotePlayer_GL-test.v</code>,<code>NotePlayer_RTL_RTL-test.v</code></li> </ul> <p>Random test cases should include a for loop. Each iteration should: (1) generate random input values; (2) use Verilog test code to programmatically determine the correct output values; and (3) use the <code>check</code> task to ensure the design-under-test produces the correct outputs give the corresponding random inputs.</p>"},{"location":"ece2300-lab3ab-music/#23-simulator","title":"2.3. Simulator","text":"<p>We have provided you four simulator which will emulate the FPGA prototype you will be demoing in Part C of the lab. After finishing implementing and thoroughly testing your RTL counter, you can build and run the simulator for the counter like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make counter-sim\n% ./counter-sim +switches=00111\n</code></pre> <p>The switches are connected to the counter input. The counter simulator will display the input and the output of the count-down counter by showing what the six seven segment displays would look like on the FPGA prototype. You can press enter to emulate the clock toggling.</p> <p>After finishing implementing and thoroughly testing your RTL note player, you can build and run the simulator for the note player like this:</p> <pre><code>% make note-player-sim\n% ./note-player-sim +switches=0100_0100\n</code></pre> <p>The switches will set the period of the note player. Here is a table showing the mapping from inputs to notes.</p> <pre><code>                   period period    freq\nswitches  hex  dec (cycs)   (ms)    (Hz) note\n0111_1011 0x7b 123    250   5.12  195.31 G3\n0110_1101 0x6d 109    222   4.55  219.95 A3\n0110_0001 0x61  97    198   4.06  246.61 B3\n0101_1011 0x5b  91    186   3.81  262.52 C4\n0101_0001 0x51  81    166   3.40  294.15 D4\n0100_1000 0x48  72    148   3.03  329.92 E4\n0100_0100 0x44  68    140   2.87  348.77 F4\n</code></pre> <p>The simulator will generate a VCD file that you can then open using Surfer to look at the note output waveform. You can measure period between rising edges of the note output to verify that the note player is indeed generating the note at the proper frequency. For example, this is what the output looks like when setting the switches to 0100_0100. The period is 2.86ms which is 348Hz or the note F4. Try other notes!</p> <p></p> <p>After finishing implementing and thoroughly testing your RTL multi-note player, you can build and run the simulator for the multi-note player like this:</p> <pre><code>% make multi-note-player-sim\n% ./multi-note-player-sim +switches=111\n</code></pre> <p>The switches now select which note to play according to the following table.</p> <pre><code>             period period    freq\nsw  hex  dec (cycs)   (ms)    (Hz) note\n000                                rest\n001 0x7b 123    250   5.12  195.31 G3\n010 0x6d 109    222   4.55  219.95 A3\n011 0x61  97    198   4.06  246.61 B3\n100 0x5b  91    186   3.81  262.52 C4\n101 0x51  81    166   3.40  294.15 D4\n110 0x48  72    148   3.03  329.92 E4\n111 0x44  68    140   2.87  348.77 F4\n</code></pre> <p>This simulator will also generate a VCD file that you can then open using Surfer to look at the note output waveform. Try selecting different notes and verifying that the period is as expected.</p> <p>After finishing implementing and thoroughly testing your RTL music player, you can build and run the simulator for the music player like this:</p> <pre><code>% make music-player-sim\n% ./music-player-sim +switches=001\n</code></pre> <p>The switches now select which song to play. Here is what the output looks like for song 1. You will figure out which song this is in Part C of the lab.</p> <p></p>"},{"location":"ece2300-lab3ab-music/#3-lab-code-submission","title":"3. Lab Code Submission","text":"<p>Your code quality score will be based on the way you format the text in your source files, proper use of comments, deletion of instructor comments, and uploading the correct files to GitHub (only source files should be uploaded, no generated build files). Note that students must remove unnecessary comments that are provided by instructors in the code distributed to students. Students must not commit executable binaries or any other unnecessary files.</p> <p>To submit your code you simply upload it to GitHub. Your design code will be assessed both in terms of functionality and code quality. Your functionality score will be determined by running your code against a series of tests developed by the instructors to test its correctness. Your test bench code will also be assessed both in terms of verification quality and code quality. Here is how we will be testing your code submission for Lab 3 (Part A):</p> <pre><code>% mkdir -p ${HOME}/ece2300/submissions\n% cd ${HOME}/ece2300/submissions\n% git clone git@github.com:cornell-ece2300/groupXX\n\n% cd ${HOME}/ece2300/submissions/groupXX/lab3-music\n% mkdir -p build\n% cd build\n% ../configure\n% make check-partA\n</code></pre> <p>Here is how we will be testing your code submission for Lab 3 (Part B):</p> <pre><code>% mkdir -p ${HOME}/ece2300/submissions\n% cd ${HOME}/ece2300/submissions\n% git clone git@github.com:cornell-ece2300/groupXX\n\n% cd ${HOME}/ece2300/submissions/groupXX/lab3-music\n% mkdir -p build\n% cd build\n% ../configure\n% make check-partB\n</code></pre>"},{"location":"ece2300-lab3cd-custom-song/","title":"Lab 3 (Parts C &amp; D) Optional Add-On: Custom Song","text":"<p>Complete After Parts C and D</p> <p>This section is an optional add-on to the main lab, and is meant for students who have already completed Parts C and D. If you have not already completed Parts C and D, please go back and do so first.</p> <p>As part of Lab 3, students have the option to play a song of their creation/choosing on the FPGA. Students will need to modify the provided music memory to encode the notes they wish to play, then re-compile their design for the FPGA.</p>"},{"location":"ece2300-lab3cd-custom-song/#1-adding-a-song-to-memory","title":"1. Adding a Song to Memory","text":"<p>For this lab, the memory that stores music notes is implemented in <code>lab3-music/hw/MusicMem_RTL.v</code>. Open this file and look inside the <code>MusicMem_RTL</code> module. You should see a large statement that looks like:</p> <pre><code>  always_comb begin\n    case( memreq_addr )\n\n      //----------------------------------------------------------------\n      // Song 0\n      //----------------------------------------------------------------\n\n      16'h0000: memresp_data = NOTE_B;\n      16'h0004: memresp_data = REST;\n      16'h0008: memresp_data = NOTE_A;\n      16'h000C: memresp_data = REST;\n      16'h0010: memresp_data = NOTE_G;\n      16'h0014: memresp_data = REST;\n      16'h0018: memresp_data = NOTE_A;\n      16'h001C: memresp_data = REST;\n\n      ...\n\n      16'h00FC: memresp_data = SONG_END;\n\n      //----------------------------------------------------------------\n      // Song 1\n      //----------------------------------------------------------------\n\n      16'h0200: memresp_data = NOTE_B;\n      16'h0204: memresp_data = REST;\n\n      ...\n\n    endcase\n    if ( !memreq_val )\n        memresp_data = 32'b0;\n  end\n</code></pre> <p>Here, we can see that our memory is implemented as a (rather large) look-up table. The notes are defined as <code>NOTE_G</code> up to <code>NOTE_F</code>, with  <code>REST</code> signifying to play no sound. When <code>MusicMem_RTL</code> gets a request, it checks the address given by <code>memreq_addr</code>, and sets <code>memresp_data</code> to be the corresponding note. You'll see that the memory range for each song ends with <code>SONG_END</code>, to signify to our player that the song is finished.</p> <p>As part of this memory, we've left a range (corresponding to Song #2) for you as the student to implement a song of your choice, if you'd like. In <code>MusicMem_RTL</code>, you can find the following section:</p> <pre><code>      //----------------------------------------------------------------\n      // Song 2\n      //----------------------------------------------------------------\n      // OPTIONAL: Replace note values to make a new song!\n\n      16'h0400: memresp_data = SONG_END;\n      16'h0404: memresp_data = SONG_END;\n      16'h0408: memresp_data = SONG_END;\n      16'h040C: memresp_data = SONG_END;\n      16'h0410: memresp_data = SONG_END;\n      16'h0414: memresp_data = SONG_END;\n      16'h0418: memresp_data = SONG_END;\n      16'h041C: memresp_data = SONG_END;\n\n      ...\n</code></pre> <p>You can see that each note in the song is currently <code>SONG_END</code>. To write a custom song, you should replace as many of these values as needed with the notes for your song. Keep in mind that notes will lead directly into each other; if you want a break between notes, you will have to include a <code>REST</code> between them</p> <p>Implement a Song</p> <p>Using the template above, implement a new song as Song #2 in the music memory. If you don't have a song in mind, you can use  \"Hot Cross Buns\", given below and starting \"B\", \"B\", \"R\", \"R\", ...  (with R representing <code>REST</code>, and E representing <code>SONG_END</code>):</p> <p></p>"},{"location":"ece2300-lab3cd-custom-song/#2-playing-your-custom-song","title":"2. Playing Your Custom Song","text":"<p>Once you've created your custom song, you can re-synthesize your overall design (including <code>MusicMem_RTL.v</code>) and put your design on the FPGA, as described in the main handout. From there, use the switches to select Song #2. You should hopefully be able to hear your song being played by your music player!</p>"},{"location":"ece2300-lab3cd-music/","title":"Lab 3 (Parts C &amp; D): Music Player - FPGA Analysis/Prototype and Report","text":"<p>Lab 3 is meant to give you experience designing, implementing, testing, and prototyping combinational and sequential logic using the Verilog hardware description language. The lab reinforces several lecture topics including sequential logic gates, finite-state machines (FSMs), and sequential building blocks. More specifically, the lab will give students experience with: latches, flip-flops, and registers; Moore and Mealy FSMs; and counters. The lab will continue to provide opportunities to leverage the three key abstraction principles: modularity, hierarchy, and regularity. The lab will also enable students to better understand the connection between simulation and prototyping.</p> <p>With the introduction of sequential logic, our designs can now model more complex and interesting designs; in particular, designs that can have real-world applications. You should have already worked in simulation to verify your music player and all of the submodules in Lab 3 Parts A and B. In Lab 3 Part C, we will be using the FPGA to emulate these designs, connecting them to real-world phenomena such as music. By the end of the lab, you should be able to play a simple song using your design, and understand the digital logic that allows it to happen.</p> <p>This handout assumes that you have read and understand the course tutorials, attended the discussion sections, and successfully completed Labs 1-2. Here are the steps to get started:</p> <ul> <li>Step 1. Find your lab partner</li> <li>Step 2. Find a free workstation</li> <li>Step 3. Ask the TAs for a lab check-off sheet (each student needs     their own check-off sheet)</li> </ul> <p>Throughout this handout you will see two kinds tasks: lab check-off tasks and lab report tasks.</p> <p>For each lab report task you must take some notes, save a screenshot, and/or record some data for your lab report. Students can start working on their lab report during their lab session, but will likely need to continue working on their lab report after the lab session. The lab report is due three days after your lab session at 11:59pm.</p> <p>For each lab check-off task you must raise your hand and have a TA come to check-off your work. The TA will ask you the questions included as part of the lab check-off task and the assess your understanding using the following rubric: mastery; accomplished; emerging; beginning. If the TA and students together feel the students have not mastered the lab check-off task, the students are encouraged to take a few minutes and try again.</p> <p>In contrast to previous labs, Lab 3 is much more application-oriented. We will spend less time exploring the design space, and more time exploring the applications of our design. Because of this, you will need some additional hardware:</p> <ul> <li>A piezoelectric (\"piezo\") buzzer. This is a tiny speaker that can    play our notes</li> <li>Four jumper wires:<ul> <li>Two F-M jumper wires. These have one \"input\" and one \"output\"</li> <li>Two F-F jumper wires. These have two \"inputs\"</li> </ul> </li> <li>A USB Drive. Some of the lab report tasks will require you to    capture waveforms from the oscilloscope. You should follow the    instructions to save these on your USB Drive, and transfer them to    your own laptop before leaving the lab.</li> </ul> <p></p> <p>Real hardware can often be delicate and fragile. As a general rule, please do not \"force\" anything together, and take time and caution when connecting different components. If you have any questions or need assistance, please ask the TAs.</p> <p>Lab Check-Off Task 1: Setup FPGA Board and Hardware Supplies</p> <p>Request an FPGA board and the hardware supplies from the TAs. The TAs will record the board number and the hardware supply kit number on your check-off sheet. Use the power cord to plug the FPGA board into an outlet, and use the USB cable to plug the FPGA board into the workstation. Do not use the other hardware supplies until instructed to do so.</p>"},{"location":"ece2300-lab3cd-music/#1-simulation-of-a-music-player","title":"1. Simulation of a Music Player","text":"<p>Before starting to work on an FPGA prototype, you must make sure you have a working Verilog hardware design that has been thoroughly tested in simulation. One student should start VS Code on the workstation, log into the <code>ecelinux</code> servers, source the setup script, and make sure their individual remote repository is up to date.</p> <pre><code>% source setup-ece2300.sh\n% cd ${HOME}/ece2300/groupXX\n% git pull\n% tree\n</code></pre> <p>Where <code>XX</code> is your group number. Now run all of the tests from a clean build to ensure your design is fully functional.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music\n% trash build\n% mkdir build\n% cd build\n% ../configure\n% make check\n</code></pre> <p>We now need to get the files for your design from <code>ecelinux</code> onto the workstation. This requires multiple steps.</p> <ul> <li> <p>Step 1. Click Microsoft Edge on the desktop to open a web-browser on    the workstation to log into GitHub and then find your repository</p> </li> <li> <p>Step 2. Start PowerShell by clicking the Start menu then searching    for Windows PowerShell</p> </li> <li> <p>Step 3. Clone your repo onto the workstation by using this command in    PowerShell (where <code>netid</code> is your Cornell NetID, notice we are using    https!):</p> </li> </ul> <pre><code>% git clone https://github.com/cornell-ece2300/groupXX\n</code></pre> <ul> <li> <p>Step 4. In the Connect to GitHub pop-up, click Sign in with your    browser</p> </li> <li> <p>Step 5. You may be asked for your GitHub username again and you may be    asked to authorize the Git Credential Manager; click authorize    git-ecosystem</p> </li> <li> <p>Step 6. Verify that you have successfully cloned your repo by changing    into your repo and using <code>tree</code> on the workstation:</p> </li> </ul> <pre><code>% cd groupXX\n% tree\n</code></pre> <p>Lab Check-Off Task 2: Verify Tests</p> <p>Show a TA that your hardware designs are passing all of your tests. The TA will ask one student to explain the purpose of the note player control FSM and to show the TA specific lines of code in the GL and RTL implementation that make this a Moore FSM. The TA will ask the other student to explain the purpose of the music player control FSM and to show the TA specific lines of code in the RTL implementation that make this a Mealy FSM.</p>"},{"location":"ece2300-lab3cd-music/#2-setup-quartus-project","title":"2. Setup Quartus Project","text":"<p>Click Quartus (Quartus Prime 19.1) on the desktop to start Quartus, and click Run the Quartus Prime software. You might need to try starting Quartus twice. Setup a new Quartus project using the New Project Wizard:</p> <ul> <li>Directory, Name, Top-Level Entity<ul> <li>Working directory: <code>C:\\Users\\netid\\lab3</code></li> <li>Name of this project: <code>lab3</code></li> <li>Name of top-level design entity: <code>lab3</code></li> <li>Click Next</li> </ul> </li> <li>Directory does not exist. Do you want to create it?<ul> <li>Click yes</li> </ul> </li> <li>Project Type<ul> <li>Choose Empty Project</li> <li>Click Next</li> </ul> </li> <li>Add Files<ul> <li>Click triple dots to right of File name</li> <li>Click on This PC, then navigate to your cloned repo by choosing    Windows (C:) &gt;  Users &gt; netid &gt; netid where netid is your    Cornell NetID</li> <li>Shift-click on every Verilog hardware design file (do not include    any test files)</li> <li>Click Open</li> <li>Click Next</li> </ul> </li> <li>Family, Device, and Board Settings<ul> <li>Click Board tab</li> <li>Family: Cyclone V</li> <li>Select DE0-CV Development Board</li> <li>Make sure Create top-level design file is checked</li> <li>Click Next</li> </ul> </li> <li>EDA Tool Settings<ul> <li>Click Next</li> </ul> </li> <li>Summary<ul> <li>Click Finish</li> </ul> </li> </ul> <p>Since we are now using RTL modeling, there is one new step, similar to Lab 2. You must choose Assignments &gt; Settings from the menu. Then select the category Compiler Settings &gt; Verilog HDL Input and under Verilog version click SystemVerilog. Then click OK.</p>"},{"location":"ece2300-lab3cd-music/#3-synthesize-analyze-integrate-and-configure-counters","title":"3. Synthesize, Analyze, Integrate, and Configure Counters","text":"<p>We will start by synthesizing and analyzing the two different counter implementations. Once we better understand the tradeoffs in these implementations, we can make high-level conclusions about their tradeoffs.</p> <p>Lab Report Task 1: Gate-Level Counter Block Diagram</p> <p>Make sure you have the block diagram for your gate-level counter which you prepared in Part A. If you did not draw a block diagram in Part A, the you must draw a diagram now. Save this diagram since you will be annotating it later in the lab.</p> <p>Lab Check-Off Task 3: Discuss Gate-Level Counter Block Diagram</p> <p>Show a TA your block diagram. Explain how loading a new value works. Explain how the done signal is implemented.</p>"},{"location":"ece2300-lab3cd-music/#31-synthesize-and-analyze-gl-counter","title":"3.1. Synthesize and Analyze GL Counter","text":"<p>To synthesize and analyze the gate-level counter in isolation first find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>Counter_8b_GL.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>Counter_8b_GL</code> is shown as the only entity.</p> <p>As in Lab 2, we need to create a timing constraint file. Unlike in Lab 2, we also now need to inform the tools that there is a clock signal as part of our design. Identifying the clock signal will make the tools work to ensure that our design has no setup or hold time violations. Similar to Lab 2, when finished, the design will either \"meet timing\" (i.e., the actual critical path delay is less than the constraint and there are no hold time violations) or \"not meet timing\" (i.e., the actual critical path delay is greater than the constraint or there are hold time violations).</p> <p>Here are the steps to create a timing constraint file:</p> <ul> <li>Choose File &gt; New from the menu</li> <li>Click Synopsys Design Constraints File</li> <li>Click OK</li> <li>Enter the constraints shown below</li> <li>Click File &gt; Save from the menu</li> <li>Name the file timing.sdc</li> <li>Save the file in the lab3 directory</li> </ul> <p>We will use the following initial constraints:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -name clk -period 20 [get_ports {clk}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay  -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay  -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>These constraints tell the FPGA tools that:</p> <ul> <li>Our critical path delay constraint is <code>20ns</code> from all inputs to all    outputs as well</li> <li>We have a clock signal named <code>clk</code><ul> <li>There should be setup time violations with respect to   <code>clk</code> when the period is <code>20ns</code></li> <li>There should be no hold time violations with respect to <code>clk</code></li> </ul> </li> <li>The output ports have a setup time of 0 (max constraint) and a hold    time of 0 (min constraint)</li> <li>The input ports have clock-to-port propagation delay of 0 (max    constraint) and a clock-to-port contamination delay of 0 (min    constraint)</li> </ul> <p>Now use the following steps to synthesize your design and then look at the RTL viewer, technology map viewer, and chip planner.</p> <ul> <li>Choose Processing &gt; Start Compilation from the menu</li> <li>Wait 2-3 minutes for synthesis to complete</li> <li>RTL Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; RTL Viewer from the menu</li> <li>Drill down in the hierarchy to see the netlist for the counter</li> <li>Does the RTL viewer match your expectations?</li> <li>Choose File &gt; Close from menu to close the RTL viewer</li> </ul> </li> <li>Technology Map Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; Technology Map Viewer (Post-Fitting)</li> <li>Drill down into the subtractor all the way to see the    implementation of the full adder</li> <li>Does the technology viewer match your expectations?</li> <li>Choose File &gt; Close from the menu to close the technology map    viewer</li> </ul> </li> <li>Chip Planner<ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located    in the FPGA</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> </li> </ul> <p>The next step is to analyze the area of your design.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu</li> <li>Under Table of Contents choose Fitter &gt; Resource Section &gt; Resource    Usage Summary</li> <li>Look through the report to determine the number of combinational ALUTs    (configurable look-up tables) that are used for your design</li> <li>Look through the report to determine the number of dedicated logic    registers that are used for your design</li> </ul> <p>You will be working to fill in this data table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1b0Ep9hQOy_K2F6YslZt8ExoQcgabWJIXPrI3lRXn1mI/edit?gid=0#gid=0</li> </ul> <p>Make a copy of this table, and enter in the data for your ripple-carry adder with a 20ns critical path delay constraint. You can find the number of 7-input ALUts, 6-input ALUts, etc in the area report. You can find the dedicated logic registers also in the area report.</p> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>Clocks - From clock: clk</li> <li>Clocks - To clock: clk</li> <li>Targets - From: [get_registers *]</li> <li>Targets - To: [get_registers *]</li> <li>Report number of paths: 100</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the propagation delay of the displayed path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one of the inputs through your     design to one of the outputs</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Note that your GL counter will not meet timing. This is because the FPGA tools do not understand that your gate-level flip-flop is actually a register (check the number of dedicated logic registers in the area report to confirm this). The FPGA tools are designed to recognize specific RTL patterns and infer appropriate sequential logic, but they are simply not designed to recognize specific GL patterns. Even so, we can still analyze the critical path in our design.</p> <p>We will use the following conventions when analyzing the critical path based on FPGA timing reports. The FPGA timing report will have three parts:</p> <ul> <li> <p>The clock part of the data arrival path: this is the delay from the    clock pin to the flip-flop at the start of the path.</p> </li> <li> <p>The data part of the data arrival path: this is the actual propagation    path delay from one flip-flop to another flop-flop.</p> </li> <li> <p>The clock part of the data required path: this is the delay from the    clock pin to the flip-flop at the end of the path.</p> </li> </ul> <p>The following timing report illustrates these three parts:</p> <p></p> <p>The above image shows that you should count the delay from the start of the path until the signal leaves the initial flip-flop or register module as the clock-to-q delay, and you should count the delay from when the signal enters the final flip-flop until the end of the path as the setup time. If you select multiple cells in the Incr column and hover your mouse it will display a pop-up showing the sum of the delays along that portion of the path.</p> <p>Also notice that the propagation path delay and the slack do not add up to the clock constraint. This is due to clock skew. Clock skew means the clock reaches the initial and final flip-flops at a different times. You can calculate the effective clock skew as follows:</p> \\[t_{skew} = t_{pathdelay} + t_{slack} - t_{constraint}\\] <p>The effective clock skew is different from what you will see in the timing report because the tools are using a more complicated calculation. For our purposes you should always use the effective clock skew as calculated above. A negative effective clock skew means the clock reaches the final flip-flop before it reaches the initial flip-flop. A positive effective clock skew means the clock reaches the initial flip-flop before it reaches the final flip-flop.</p> <p>Enter the slack and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Lab Report Task 2: Collect Data for Gate-Level Counter</p> <p>Save your completed data table with your analysis of the gate-level counter and include it in your report. </p> <ul> <li>When generating your timing report, select \"File name\" to save    your timing report</li> <li>You will only need to collect 1 path for this portion</li> </ul> <p>Draw the critical path on your block-level diagram. Annotate the clock-to-q delay, the propagation delay of each block along the critical path, and the setup time on your block level diagram. Save the critical path timing report text file and include it in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. You might need to delete some rows from the critical path to make it fit. Try to make sure that the remaining rows still clearly show where the critical path goes. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Check-Off Task 4: Discuss Gate-Level Counter Critical Path</p> <p>Show a TA your data table and timing report. Explain why there are no dedicated logic registers. Show a TA the critical path on your block diagram and clearly show how the delays in the timing report correspond to the delays annotated on the block diagram.</p>"},{"location":"ece2300-lab3cd-music/#32-synthesize-and-analyze-rtl-counter","title":"3.2. Synthesize and Analyze RTL Counter","text":"<p>Use the same process to synthesize and analyze the RTL counter in isolation. Remember to change that hardware module to be the top-level entity. So find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>Counter_8b_RTL.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>Counter_8b_RTL</code> is shown as the only entity.</p> <p>Go through the same process of looking at the RTL Viewer, Technology Map Viewer, and the Chip Planner. Spend time looking at the Technology Map Viewer and try to figure out how the blocks in the Technology Map Viewer connect to your Verilog implementation. Go through the same process of determining the area utilization. Do the number of dedicated logic registers match your expectation? Go through the same process of conducting a timing analysis. Enter the area, slack, and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Your RTL counter should meet timing. This is because the FPGA tools do understand that your RTL flip-flop is actually a register (check the number of dedicated logic registers in the area report to confirm this). As mentioned above, the FPGA tools are designed to recognize specific RTL patterns and infer appropriate sequential logic. You will likely observe that the area is much less than the GL implementation and the critical path is much shorter. This because for the GL counter the tools were not able to actually do any timing optimization because they did not understand how the timing constraints connected to the GL flip-flop, while for the RTL counter the FPGA tools are able to do standard timing optimization.</p> <p>Lab Report Task 3: Collect Data for RTL Counter</p> <p>Save your completed data table with your analysis of the RTL counter and include it in your report. Save a screenshot of the technology mapper view for your RTL counter. Annotate this screen shot by circling what logic implements:</p> <ul> <li>(1) The storage element that keeps track of the current count</li> <li>(2) The logic that determines the subtracted count</li> <li>(3) The logic that determines what should be the next stored count</li> <li>(4) The logic that determines whether the counter is done</li> </ul> <p>Clearly label each circle with the corresponding Verilog code snippet. Save the critical path timing report text file and include it in your report. You only want to save the Data Arrival Path from the timing report text file. Do NOT include anything else from the timing report text file. You must format the critical path with a fixed-width font and size the font such that it fits on a single page. If you do not follow this requirements then we will ignore your critical path in the lab report.</p> <p>Lab Check-Off Task 5: Discuss RTL Counter Technology Mapping</p> <p>Show a TA your data table and timing report. Justify why the number of dedicated logic registers makes sense. Show a TA your technology map screen shot annotated with Verilog code snippets. Explain to the TA the connection between the Verilog code and the actual low-level logic gates. Are we convinced that RTL modeling does indeed turn into low-level logic gates?</p>"},{"location":"ece2300-lab3cd-music/#33-integrate-rtl-counter","title":"3.3. Integrate RTL Counter","text":"<p>We are now ready to demonstrate a counter FPGA prototype using the RTL implementation. We need to change the top-level entity to be <code>DE0_CV_golden_top.v</code>. Find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>DE0_CV_golden_top.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>DE0_CV_golden_top</code> is shown as the only entity.</p> <p>The New Project Wizard creates a top-level Verilog module for us which has ports for all of the switches, LEDs, seven-segment displays, and pins on the FPGA development board. We want to implement a counter FPGA prototype with the following specification:</p> <p></p> <ul> <li><code>clk</code> should be connected to the first button</li> <li><code>rst</code> should be connected to the reset button on the board</li> <li><code>load</code> should be connected to the second button</li> <li><code>done</code> should be assigned to the first LED</li> <li>Two seven-segment displays for the current input <code>in</code> to the counter</li> <li>Two seven-segment displays for the current count</li> </ul> <p>Note that FPGA's reset (<code>RESET_N</code>) and all of the buttons are active-low. Unpressed buttons output a logic one and pressed buttons output a logic zero. Here is a template you can use for your top-level design.</p> <pre><code>  Counter_8b_RTL counter\n  (\n    .clk      (),\n    .rst      (),\n    .load     (),\n    .in       (),\n    .count    (),\n    .done     ()\n  );\n\n  Display_GL display0\n  (\n    .in       (),\n    .seg_tens (),\n    .seg_ones ()\n  );\n\n  Display_GL display1\n  (\n    .in       (),\n    .seg_tens (),\n    .seg_ones ()\n  );\n</code></pre> <p>You just need to copy this code into the DE0_CV_golden_top.v file and connect the ports appropriately. You may need to declare additional internal wires. Look carefully at the labels on the board to figure out how the switches, buttons, and seven-segment displays correspond to ports in the top-level Verilog module. We also need to update our timing constraint file as follows:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -name clk -period 20 [get_ports {KEY[0]}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay  -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay  -add_delay -clock clk -min 0 [all_inputs]\n</code></pre>"},{"location":"ece2300-lab3cd-music/#34-synthesize-and-configure-the-rtl-counter","title":"3.4. Synthesize and Configure the RTL Counter","text":"<p>From here, choose  Processing &gt; Start Compilation from the menu to synthesize your design. Once completed, we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>Additionally, on <code>ecelinux</code>, go ahead and build and run the counter interactive simulator:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make counter-sim\n% ./counter-sim +switches=00111\n</code></pre> <p>Try out your counter simulator for a few values, and make sure that the FPGA behaves identically.</p> <p>Lab Check-Off Task 6: Demonstrate the RTL Counter</p> <p>First, show a TA the counter interactive simulator, demonstrating its functionality. The TA will give you a switch configuration. You should first predict what your counter will do, then demonstrate it in simulation. Then demonstrate that your counter on the FPGA produces identical results for the same stimulus. Additionally, demonstrate that your counter can take in new values at any time, and will stop counting down once it reaches 0. Clearly explain to the TA why the counter prototype is different from the calculator prototype in Lab 2; explain how the counter prototype illustrates sequential logic.</p>"},{"location":"ece2300-lab3cd-music/#4-synthesize-and-analyze-note-players","title":"4. Synthesize and Analyze Note Players","text":"<p>In this part, we will synthesize and analyze the gate-level and RTL note players to continue to understand the connection between gate-level and RTL modeling.</p>"},{"location":"ece2300-lab3cd-music/#41-synthesize-and-analyze-gl-note-player","title":"4.1. Synthesize and Analyze GL Note Player","text":"<p>Use the same process to synthesize and analyze the GL note player in isolation that we used with the GL counter. Remember to change that hardware module to be the top-level entity. So find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>NotePlayer_GL.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>NotePlayer_GL</code> is shown as the only entity.</p> <p>You will need to use the following constraints.</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -name clk -period 20 [get_ports {clk}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay  -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay  -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>Go through the same process of determining the area utilization. Do the number of dedicated logic registers match your expectation? You can go to Table of Contents and choose Fitter &gt; Resource Section &gt; Resource Utilization by Entity to determine how many logic gates and registers are used in every module in your design. Go through the same process of conducting a timing analysis. As mentioned before, your GL design will not meet timing, but we can still look at the critical path. Enter the area, slack, and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Lab Report Task 4: Collect Data for GL Note Player</p> <p>Save your completed data table with your analysis of the GL note player and include it in your report.</p>"},{"location":"ece2300-lab3cd-music/#42-synthesize-and-analyze-rtl-note-player","title":"4.2. Synthesize and Analyze RTL Note Player","text":"<p>Use the same process to synthesize and analyze the RTL note player in isolation that we used with the RTL counter. Remember to change that hardware module to be the top-level entity. So find the Project Navigator pane and click on Hierarchy to display the drop-down list. Choose Files and select the <code>NotePlayer_RTL.v</code> file. Right click on the file and choose Select as Top-Level Entity. Then click on Files to display the drop-down list again. Choose Hierarchy and confirm that <code>NotePlayer_RTL</code> is shown as the only entity.</p> <p>Go through the same process of determining the area utilization. Do the number of dedicated logic registers match your expectation? You can go to Table of Contents and choose Fitter &gt; Resource Section &gt; Resource Utilization by Entity to determine how many logic gates and registers are used in every module in your design. Go through the same process of conducting a timing analysis. As mentioned before, your RTL design should meet timing. Enter the area, slack, and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Lab Report Task 5: Collect Data for RTL Note Player</p> <p>Save your completed data table with your analysis of the RTL note player and include it in your report.</p> <p>Lab Check-Off Task 7: Discuss GL vs RTL Note Players</p> <p>Show a TA your data table and timing report. Justify why the number of dedicated logic registers makes sense. Are we convinced that RTL modeling does indeed turn into low-level logic gates?</p>"},{"location":"ece2300-lab3cd-music/#5-integrate-synthesize-and-configure-multi-note-player","title":"5. Integrate, Synthesize, and Configure Multi-Note Player","text":"<p>Once we've analyzed our note player, we can move on to using our multi-note player and actually begin to play notes!</p>"},{"location":"ece2300-lab3cd-music/#51-integrate","title":"5.1. Integrate","text":"<p>Similar to before, make sure that <code>DE0_CV_golden_top</code> is the top-level entity. We want to implement a multi-note player FPGA prototype with the following specification:</p> <p></p> <ul> <li><code>clk</code> and <code>rst</code> are connected appropriately</li> <li><code>note1_period</code>, <code>note2_period</code>, etc are set as described below</li> <li><code>play_load</code> is connected to the first push button</li> <li><code>play_note</code> is connected to the right three switches</li> <li><code>play_duration</code> is set to <code>16'hBEBC</code> (resulting in a one second duration)</li> <li><code>play_done</code> is connected to the first LED</li> <li><code>note</code> is connected to the <code>GPIO_0[0]</code> pin</li> <li>One seven-segment display for <code>play_note</code> (note specified on switches)</li> <li>One seven-segment display for <code>note_sel</code> (currently playing note)</li> </ul> <p>The note periods should be set according to the following table (see Part A for more details):</p> <pre><code>                   period   freq\nport         hex     (ms)   (Hz) note\nnote1_period 8'h7b   5.12 195.31 G3\nnote2_period 8'h6d   4.55 219.95 A3\nnote3_period 8'h61   4.06 246.61 B3\nnote4_period 8'h5b   3.81 262.52 C4\nnote5_period 8'h51   3.40 294.15 D4\nnote6_period 8'h48   3.03 329.92 E4\nnote7_period 8'h44   2.87 348.77 F4\n</code></pre> <p>Note that FPGA's reset (<code>RESET_N</code>) and all of the buttons are active-low. Unpressed buttons output a logic one and pressed buttons output a logic zero. Here is a template you can use for your top-level design.</p> <pre><code>  logic clk;\n\n  ClockDiv_RTL#(9) clock_div\n  (\n    .clk_in  (CLOCK_50),\n    .rst     (~RESET_N),\n    .clk_out (clk)\n  );\n\n  MultiNotePlayer_RTL note_player\n  (\n    .clk           (clk),\n    .rst           (),\n\n    .note1_period  (8'h7b),\n    .note2_period  (8'h6d),\n    .note3_period  (8'h61),\n    .note4_period  (8'h5b),\n    .note5_period  (8'h51),\n    .note6_period  (8'h48),\n    .note7_period  (8'h44),\n\n    .play_load     (),\n    .play_note     (),\n    .play_duration (),\n    .play_done     (),\n    .note_sel      (),\n    .note          ()\n  );\n\n  Display_GL display0\n  (\n    .in       (),\n    .seg_tens (/* not used */),\n    .seg_ones ()\n  );\n\n  Display_GL display1\n  (\n    .in       (),\n    .seg_tens (/* not used */),\n    .seg_ones ()\n  );\n</code></pre> <p>Notice we are using a clock divider. The on-board clock signal (<code>CLOCK_50</code>) is a 50MHz clock. This is far too fast to have our notes be audible. The <code>ClockDiv</code> module divides the clock (decreases the frequency) by a parametrizable amount. To perform the necessary clock division by a factor of \\(2^{10}\\) for our desired clock frequency of \\(\\approx48828\\text{Hz}\\) we need to set the <code>ClockDiv</code> parameter to 9.</p> <p>You just need to copy this code into the DE0_CV_golden_top.v file and connect the ports appropriately. You may need to declare additional internal wires. Look carefully at the labels on the board to figure out how the switches, buttons, and seven-segment displays correspond to ports in the top-level Verilog module. We also need to update our timing constraint file as follows:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -period 20 [get_ports {CLOCK_50}]\ncreate_clock -name clk -period 20 [get_nets {ClockDiv_RTL:clock_div|count[9]}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>Note that we still specify <code>clk</code> to be <code>20ns</code>; this is over-constrained based on our actual clock signal, but for our designs, it shouldn't make a difference.</p>"},{"location":"ece2300-lab3cd-music/#52-synthesize-and-configure","title":"5.2. Synthesize and Configure","text":"<p>From here, choose Processing &gt; Start Compilation from the menu to synthesize your design. Go through the same process of determining the area utilization. Do the number of dedicated logic registers match your expectation? You can go to Table of Contents and choose Fitter &gt; Resource Section &gt; Resource Utilization by Entity to determine how many logic gates and registers are used in every module in your design. Go through the same process of conducting a timing analysis. Enter the area, slack, and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Now configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>Additionally, on <code>ecelinux</code>, go ahead and build and run the multi-note player interactive simulator:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make multi-note-player-sim\n% ./multi-note-player-sim +switches=111\n</code></pre> <p>Open the resulting <code>multi-note-player-sim.vcd</code> in VSCode using Surfer. You must display these signals in this order: <code>clk</code>, <code>play_note</code>, <code>note_sel</code>, <code>note7_player.state</code>, and <code>note</code>. Select the note signal in the waveform viewer. Right-click on a rising edge of <code>note</code> to place a marker there, and use the arrow keys to navigate your cursor to the next rising edge to measure the period of the note (one rising edge to the next). Choose Settings &gt; Time Unit &gt; ms to display the period in milliseconds. Take a screen shot and record the period.</p> <p>We will now determine the period for our FPGA prototype using an oscilloscope. An oscilloscope is a kind of electronic test equipment that graphically displays analog signals (i.e., voltage). We first need to connect wires to the pin which produces the note and a reference ground. Recall that the <code>note</code> port was connected to pin <code>GPIO_0[0]</code> on the FPGA board. The excerpt from the manual below shows where the <code>GPIO_0[0]</code> pin is located.</p> <p></p> <p>Connect the two F-M Jumper Wires:</p> <ul> <li>Connect the input of one to the first GPIO of <code>GPIO_0</code> (look on the    board for the label)</li> <li>Connect the input of the other to ground</li> </ul> <p>Now we need to connect these wires to the oscilloscope. Use the button on the top of the oscilloscope (on the left) to turn it on and find the main probe and the ground clip attached to Channel 1.</p> <p></p> <p>Now carefully follow these steps (ask a TA if you need help):</p> <ul> <li>There is a small slide switch on the probe that chooses between 1x and     10x; make sure it is set to 10x</li> <li>Connect the main probe of <code>CH 1</code> to <code>GPIO_0[0]</code></li> <li>Connect the ground clip of <code>CH 1</code> to ground</li> <li>Click on DEFAULT SETUP to first go to the default setup for the    oscilloscope</li> <li>Click the CH 2 MENU button<ul> <li>Clicking this repeatedly will toggle whether Channel 2 is displayed   We only need one channel; turn Channel 2 off, then click MEASURE   to return to the main measurement window</li> </ul> </li> <li>Adjust the VOLTS/DIV dial of <code>CH 1</code> to achieve a scale of 1.00V    (referencing the bottom-left of the display)</li> <li>Adjust the POSITION dial of <code>CH 1</code> so that the static bar is about    25% of the way from the bottom of the display</li> <li>Adjust the SEC/DIV dial to achieve a time division of 2.50ms    (referencing the bottom-middle of the display)</li> <li>Press TRIG MENU<ul> <li>Make sure that Type is <code>EDGE</code>, Source is <code>CH 1</code>, and Slope   is <code>RISING</code> (adjusting any if needed). Once done, click MEASURE   to go back to the main measurement window</li> </ul> </li> <li>Using the LEVEL dial of the Trigger setup, adjust the trigger to    be 1.00V (referencing the bottom-right of the display). This tells    the oscilloscope at what value to capture a signal change.</li> </ul> <p>You should initially see static. Try playing a note using your multi-note FPGA prototype; you should see a waveform! Try different notes. Now, let's capture this data from the oscilloscope:</p> <ul> <li>Press SINGLE SEQ to start a single capture</li> <li>Play a note on the FPGA. You should see the captured waveform on the    oscilloscope</li> <li>Press CURSOR:<ul> <li>Change Type to <code>TIME</code> by pressing the button next to it repeatedly</li> <li>Using the buttons to the right of the display, click on Cursor 1.   Using the large dial next the display, adjust the cursor to be on a   positive edge of the note. Similarly, adjust Cursor 2 to be on a   neighboring positive edge</li> <li>Note the value of \\(\\Delta t\\) shown on the side - does it match your   simulation?</li> </ul> </li> </ul> <p>Lab Report Task 6: Collect Data for Multi-Note Player</p> <p>Save your completed data table with your analysis of the multi-note player and include it in your report. Save a screenshot of your simulated waveform for a specific note which clearly shows the period of that note. Save a screenshot of your actual waveform from the oscilloscope for the same note which clearly shows the period of this same note. To obtain a screen capture from the oscilloscope use these steps:</p> <ul> <li>Insert the USB Drive into the port on the front of the oscilloscope</li> <li>Get the waveform you want to capture<ul> <li>This image should include both cursors, as well as the value of   \\(\\Delta t\\)</li> </ul> </li> <li>Press \"PRINT\" on the oscilloscope to save a screen capture to the    USB Drive<ul> <li>A clock will appear on the side panel. This will take a minute   to save; just be patient.</li> </ul> </li> </ul> <p>This image will save in a new folder on the drive as a <code>.BMP</code> file (for which there are converters online to other image types). Once saved, you can connect the drive to either your own computer or the lab machine to get the image.</p> <p>We are now ready to play notes using our multi-note FPGA prototype!</p> <ul> <li>Swap the F-M Jumper Wires for F-F Jumper Wires, connected    similarly</li> <li>Connect the other ends of the jumper wires to the piezo buzzer</li> </ul> <p>Now, when you play a note, you should be able to hear the piezo buzzer make a sound. Vary the switches, and verify that the resulting note differs in frequency.</p> <p>Lab Check-Off Task 8: Demonstrate the Multi-Note Player</p> <p>The TA will give you a configuration for the switches. First, simulate the configuration with your <code>multi-note-player-sim</code> and show the simulated waveform. You must find the state output for the note payer that corresponds to the note you are playing and explain how the states of the note payer FSM correspond to the generated note waveform. Next, connect the FPGA to the oscilloscope and show the waveform on the oscilloscope for the same note. Finally, connect the piezo buzzer to the FPGA, and demonstrate that you can play the desired note. You do not need to measure the period for the TA, but make sure you have that data for your lab report.</p>"},{"location":"ece2300-lab3cd-music/#5-integrate-synthesize-and-configure-music-player","title":"5. Integrate, Synthesize, and Configure Music Player","text":"<p>We are finally ready to play some tunes with our music player!</p>"},{"location":"ece2300-lab3cd-music/#51-integrate_1","title":"5.1. Integrate","text":"<p>Similar to before, make sure that <code>DE0_CV_golden_top</code> is the top-level entity. We want to implement a music player FPGA prototype with the following specification:</p> <p></p> <ul> <li><code>clk</code> and <code>rst</code> are connected appropriately</li> <li><code>note1_period</code>, <code>note2_period</code>, etc are set as in multi-note player</li> <li><code>song_sel</code> is connected to the right five switches</li> <li><code>start_song</code> is connected to the first push button</li> <li><code>idle</code> is connected to the first LED</li> <li><code>note_duration</code> is set to <code>16'h2000</code> (resulting in a short but audible note)</li> <li><code>note</code> is connected to the <code>GPIO_0[0]</code> pin</li> <li>Two seven-segment displays for <code>song_sel</code> (song specified on switches)</li> <li>Two seven-segment displays for <code>note_sel</code> (currently playing note)</li> </ul> <p>We provide you the appropriate top-level connections to implement this specification below.</p> <pre><code>  logic clk;\n\n  ClockDiv_RTL#(9) clock_div\n  (\n    .clk_in  (CLOCK_50),\n    .rst     (~RESET_N),\n    .clk_out (clk)\n  );\n\n  logic  [2:0] note_sel;\n  logic        memreq_val;\n  logic [15:0] memreq_addr;\n  logic [31:0] memresp_data;\n\n  MusicPlayer_RTL player\n  (\n    .clk           (clk),\n    .rst           (~RESET_N),\n    .song_sel      (SW[4:0]),\n    .start_song    (~KEY[0]),\n    .state         (/* not used */),\n    .idle          (LEDR[0]),\n\n    .note_duration (16'h2000),\n    .note1_period  (8'h7B),\n    .note2_period  (8'h6D),\n    .note3_period  (8'h61),\n    .note4_period  (8'h5B),\n    .note5_period  (8'h51),\n    .note6_period  (8'h48),\n    .note7_period  (8'h44),\n    .note_sel      (note_sel),\n    .note          (GPIO_0[0]),\n\n    .memreq_val    (memreq_val),\n    .memreq_addr   (memreq_addr),\n    .memresp_data  (memresp_data)\n  );\n\n  MusicMem_RTL mem\n  (\n    .memreq_val    (memreq_val),\n    .memreq_addr   (memreq_addr),\n    .memresp_data  (memresp_data)\n  );\n\n  Display_GL display0\n  (\n    .in       (note_sel),\n    .seg_tens (HEX1),\n    .seg_ones (HEX0)\n  );\n\n  Display_GL display1\n  (\n    .in       (SW[4:0]),\n    .seg_tens (HEX3),\n    .seg_ones (HEX2)\n  );\n\n  // turn off remaining seven segment displays\n  assign HEX4 = 7'b1111111;\n  assign HEX5 = 7'b1111111;\n</code></pre> <p>You just need to copy this code into the DE0_CV_golden_top.v file. Our timing constraint file should be the same as in the multi-note player.</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -period 20 [get_ports {CLOCK_50}]\ncreate_clock -name clk -period 20 [get_nets {ClockDiv_RTL:clock_div|count[9]}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay -add_delay -clock clk -min 0 [all_inputs]\n</code></pre>"},{"location":"ece2300-lab3cd-music/#52-synthesize-and-configure_1","title":"5.2. Synthesize and Configure","text":"<p>From here, choose Processing &gt; Start Compilation from the menu to synthesize your design. Go through the same process of determining the area utilization. Do the number of dedicated logic registers match your expectation? You can go to Table of Contents and choose Fitter &gt; Resource Section &gt; Resource Utilization by Entity to determine how many logic gates and registers are used in every module in your design. Go through the same process of conducting a timing analysis. Enter the area, slack, and critical path delay in the data table. The spreadsheet will calculate effective clock skew for you.</p> <p>Now configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>Additionally, on <code>ecelinux</code>, go ahead and build and run the music player interactive simulator:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab3-music/build\n% make music-player-sim\n% ./music-player-sim +switches=000\n</code></pre> <p>Open the resulting <code>multi-note-player-sim.vcd</code> in VSCode using Surfer. You must display these signals in this order: <code>clk</code>, <code>song_sel</code>, <code>note_sel</code>, and <code>note</code>. Zoom in so you can see the first three or four notes. Take a screen shot.</p> <p>Confirm that the piezo buzzer is wired correctly to the FPGA board.</p> <ul> <li>Swap the F-M Jumper Wires for F-F Jumper Wires, connected    similarly</li> <li>Connect the other ends of the jumper wires to the piezo buzzer</li> </ul> <p>Now try playing song zero. Then try playing song one. What songs is your music player playing?</p> <p>Lab Report Task 7: Collect Data for Multi-Note Player</p> <p>Save your completed data table with your analysis of the music player and include it in your report. Save a screenshot of your simulated waveform for the the first song which clearly shows the first three or four notes.</p> <p>Lab Check-Off Task 9: Demonstrate the Music Player</p> <p>The TA will ask you to use your music player to play song 0 and song 1. To demonstrate mastery, you must clearly explain to the TA how the counter, note player FSM, and music player FSM all work together to play these songs. The TA will then ask you to play a hidden song and identify what song it is.</p> <p>Lab Check-Off Task 10: Turn In FPGA Board</p> <p>When you are finished with your demo, pack up your FPGA development board. Neatly put the board, power cable, and USB cable back in the box. Make sure to copy the oscilloscope screenshot from the USB drive to your laptop. Please delete any images that are on the USB drive. Put the piezo buzzer, jumper wires, and the USB drive back in the zip lock. Return the box to a TA who will then record the board number on your check-off sheet, initial the final check-off, and then collect your check-off sheet.</p>"},{"location":"ece2300-lab3cd-music/#6-lab-report-submission","title":"6. Lab Report Submission","text":"<p>Students should work with their partner to prepare a short lab report that conveys what they have learned in this lab assignment. The lab report should start with no more than two pages of text. Students should include all figures, tables, and diagrams after these two pages in an appendix. The appendix can be as many pages as necessary. Do not interleave the text, figures, tables, and diagrams. There should be two pages of text and then the appendix with all of the text, figures, tables, and diagrams.</p> <p>There are no restrictions on font size, margins, or line spacing, but please make sure your report is readable. We recommend using 10pt Times or 10pt Palintino with 0.75in to 1in margins. Please make sure you include a title, your names, and your NetIDs at the top of the first page. Do not include a title page.</p> <p>The lab report must include the following numbered sections. Please number your sections and use these specific titles. Please follow the guidelines on the number of paragraphs, the content of each paragraph, and which figures/tables to include. Some paragraphs might just be 2-3 sentences.</p>"},{"location":"ece2300-lab3cd-music/#section-1-introduction-one-paragraph","title":"Section 1. Introduction (one paragraph)","text":"<ul> <li>Include 2-3 sentences explaining what the lab involves</li> <li>Include one sentence explaining the purpose of this lab (why are     students doing this lab?)</li> <li>Include one sentence explicitly connecting the lab to one or more     lecture topics; be specific on which lecture topics this lab     reinforces with experiential learning</li> </ul>"},{"location":"ece2300-lab3cd-music/#section-2-gate-level-counter-design-one-paragraph","title":"Section 2. Gate-Level Counter Design (one paragraph)","text":"<ul> <li>Include a sentence referencing your block diagram</li> <li>Include one sentence describing how you implemented your subtractor</li> <li>Include 2-3 sentences that describe how your counter works including     how it loads in new counter values and how to implements the done     signal</li> </ul>"},{"location":"ece2300-lab3cd-music/#section-3-gate-level-vs-rtl-design-two-paragraphs","title":"Section 3. Gate-Level vs RTL Design (two paragraphs)","text":"<ul> <li> <p>Paragraph 1: Analyzing the Gate-Level Counter and Note Player</p> <ul> <li>Include a sentence referencing the critical path of your GL counter</li> <li>Discuss the delay of the various components along the critical path   (you must mention clock-to-q and setup time)</li> <li>Explain why the GL counter and GL note players do not meet timing    and do not have any dedicated logic registers</li> </ul> </li> <li> <p>Paragraph 2: Analyzing the RTL Counter and Note Player</p> <ul> <li>Include a sentence referencing your technology map screenshot</li> <li>Discuss how the various Verilog constructs turn into specific    low-level hardware in the FPGA</li> <li>Discuss whether or not the number of dedicated logic registers in    the RTL counter and RTL note player as expected</li> <li>Be specific and count registers in your Verilog and argue why the    number of dedicated logic registers is correct in both the counter    and the note player</li> </ul> </li> </ul>"},{"location":"ece2300-lab3cd-music/#section-4-multi-note-and-music-player-one-paragraph","title":"Section 4: Multi-Note and Music Player (one paragraph)","text":"<ul> <li>Briefly reference your simulated waveforms and your oscilloscope    waveforms for your multi-note player</li> <li>Explain what note you tried, the expected note period, the measured    note period in simulation, and the measured note period using the    oscilloscope</li> </ul>"},{"location":"ece2300-lab3cd-music/#section-5-conclusion-one-paragraph","title":"Section 5: Conclusion (one paragraph)","text":"<ul> <li>Include 2-3 sentences that summarizes all of the data and analysis     in this lab assignment</li> <li>Include a sentence that draws a high-level conclusion; how will     what you have learned impact your design work throughout the rest     of the semester?</li> </ul>"},{"location":"ece2300-lab3cd-music/#appendix","title":"Appendix","text":"<ul> <li>FPGA Data Table</li> <li>Block diagram for GL counter with highlighted critical path and      annotated delays</li> <li>Technology map viewer for RTL counter annotated with Verilog code snippets</li> <li>Critical path report for GL counter (1 page max, fixed width font!)</li> <li>Critical path report for RTL counter (1 page max, fixed width font!)</li> <li>Simulated waveform screenshot for multi-note player clearly showing     note period</li> <li>Oscilloscope waveform screenshot for multi-note player clearly showing     note period</li> <li>Simulated waveform screenshot for first song which clearly shows the     first few notes</li> </ul>"},{"location":"ece2300-lab4ab-proc/","title":"Lab 4 (Parts A, B, C): TinyRV1 Processor - Implementation and Verification","text":"<p>Lab 4 will give you experience designing, implementing, testing, and prototyping a single-cycle processor microarchitecture and a specialized accelerator. The processor will implement the TinyRV1 instruction set. The instruction set manual is located here:</p> <ul> <li>https://cornell-ece2300.github.io/ece2300-docs/ece2300-tinyrv1-isa</li> </ul> <p>The lab reinforces several lecture topics including instruction set architectures, single-cycle processors, and finite-state machines. The lab will continue to provide opportunities to leverage the three key abstraction principles: modularity, hierarchy, and regularity.</p> <p>The lab includes six parts:</p> <ul> <li>Part A: Processor Datapath Components Implementation and Verification</li> <li>Part B: Single-Cycle TinyRV1 Processor Implementation and Verification</li> <li>Part C: Accumulator Accelerator Implementation and Verification</li> <li>Part D: Single-Cycle TinyRV1 Processor FPGA Analysis and Prototyping</li> <li>Part E: Processor vs Accelerator FPGA Analysis and Prototyping</li> <li>Part F: TinyRV1 Processor Report</li> </ul> <p>Parts A, B, and C are submitted by simply pushing the appropriate code to GitHub. Part A is due on Thursday, November 7 at 11:59pm. Part B is due on Thursday, November 14 at 11:59pm. Part C is due on Tuesday, November 26th at 11:59pm.</p> <p>This handout assumes that you have read and understand the course tutorials, discussion sections, and successfully completed Labs 1-3. To get started, use VS Code to log into an <code>ecelinux</code> server, source the setup script, and clone your individual remote repository from GitHub:</p> <pre><code> % source setup-ece2300.sh\n % mkdir -p ${HOME}/ece2300\n % cd ${HOME}/ece2300\n % git clone git@github.com:cornell-ece2300/groupXX\n % cd ${HOME}/ece2300/groupXX\n % tree\n</code></pre> <p>where <code>XX</code> should be replaced with your group number. You can both pull and push to your remote repository. If you have already cloned your remote repository, then use <code>git pull</code> to ensure you have any recent updates before working on your lab assignment.</p> <pre><code> % cd ${HOME}/ece2300/groupXX\n % git pull\n % tree\n</code></pre> <p>Go ahead and create a build directory in the <code>lab4-proc</code> directory for this lab, and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>Your repo contains the following files which are part of the automated build system:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> </ul> <p>The following table shows all of the hardware modules you will be working with in Lab 4.</p> <p></p> <p>Before starting, you should copy over all of the listed hardware modules and the associated test benches for the seven-segment display from Lab 1 and the adders and multiplexors from Lab 2. Make sure all of these hardware modules pass all of your test cases.</p> <p>Remember that GL implementations must be implemented using either explicit gate-level modeling or Boolean equations. For these designs, students are only allowed to use these Verilog constructs:</p> <ul> <li><code>wire</code>, <code>assign</code></li> <li><code>not</code>, <code>and</code>, <code>nand</code>, <code>or</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code></li> <li><code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code></li> <li><code>1'b0</code>, <code>1'b1</code>, <code>1'd0</code>, <code>1'd1</code>, and other literals</li> <li><code>{}</code> (concatenation operator)</li> <li><code>{N{}}</code> (repeat operator)</li> <li>module instantiation</li> </ul> <p>Hardware modules marked in the table as GL* must only use explicit gate-level modeling (i.e., you cannot use <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>).</p> <p>RTL implementations can use all of the GL constructs in addition to the following Verilog constructs.</p> <ul> <li><code>logic</code></li> <li><code>+</code>, <code>-</code>, <code>*</code></li> <li><code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;&gt;</code></li> <li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li> <li><code>&amp;</code>, <code>~&amp;</code>, <code>|</code>, <code>~|</code>, <code>^</code>, <code>^~</code> (reduction operators)</li> <li><code>?:</code> (ternary operator)</li> <li><code>always_comb</code>, <code>always_ff @(posedge clk)</code></li> <li><code>if</code>, <code>else if</code>, <code>endif</code></li> <li><code>case</code>, <code>default</code>, <code>endcase</code></li> </ul> <p>Note that some hardware modules have more specific restrictions; see the source comments for more details. Using unallowed Verilog constructs will result in significant penalties for code functionality and code quality. If you have any questions on what Verilog constructs can and cannot be used, please ask an instructor. There are no restrictions on Verilog constructs in test benches.</p> <p>It is critical for students to work together to complete the lab assignment. It is unlikely one student can complete the entire lab on their own. A very productive approach is to have one student work on the design of a few hardware modules while the other student works on the test benches for those same hardware modules. Then work together to test and debug these modules. Then switch roles and move on the next few modules.</p>"},{"location":"ece2300-lab4ab-proc/#1-interface-and-implementation-specification","title":"1. Interface and Implementation Specification","text":"<p>This section describe the required interface (i.e., the ports for the module and the module's functional behavior) before describing the required implementation (i.e., what goes inside the module) for each hardware module.</p>"},{"location":"ece2300-lab4ab-proc/#11-processor-datapath-components","title":"1.1. Processor Datapath Components","text":"<p>You will need to implement multiplexors, registers, four arithmetic units, immediate generation unit, and two register files.</p> <p>Parameterized Multiplexors and Registers</p> <p>Implement 2-to-1, 4-to-1, and 8-to-1 multiplexors using RTL modeling. Each multiplexor should be parameterized by the bitwidth of the corresponding input and output ports.</p> <p>Implement a multi-bit register which supports reset and enable using RTL modeling. The register should be parameterized by the bitwidth of the corresponding input and output ports.</p> <p>Arithmetic Units</p> <p>Implement four arithmetic units.</p> <ul> <li> <p>Implement a 32-bit adder by instantiating four 8-bit carry select    adders from Lab 2. The 32-bit adder will be the only module    implemented at the gate-level in your final processor implementation.</p> </li> <li> <p>Implement a 32-bit equality comparator using RTL modeling.</p> </li> <li> <p>Compose the adder, the equality comparator, and a 2-to-1 multiplexor    to create a simple ALU. The ALU takes as <code>op</code> input port which    specifies whether the ALU should do an add (<code>op</code> is zero) or an    equality comparison (<code>op</code> is one).</p> </li> <li> <p>Implement a 32-bit by 32-bit multiplier using RTL modeling.</p> </li> </ul> <p>** Immediate Generation Unit**</p> <p>Implement an immediate generation unit suitable for use in generating immediates from TinyRV1 instructions. The immediate generation unit uses the following encoding for the <code>imm_type</code> input:</p> <ul> <li><code>imm_type == 0</code>: I-type (ADDI)</li> <li><code>imm_type == 1</code>: S-type (SW)</li> <li><code>imm_type == 2</code>: J-type (JAL)</li> <li><code>imm_type == 3</code>: B-type (BNE)</li> </ul> <p>See the TinyRV1 ISA manual for more details.</p> <p>Register Files</p> <p>Implement two different register files. Both register files have 32 32-bit registers. For both register files, reading register 0 should always return the value zero. For both register files, writing and reading the same register results in reading the old value. The key difference is one register file provides one read port and one write port, while the other register file provides two read ports and one write port.</p>"},{"location":"ece2300-lab4ab-proc/#12-tinyrv1-processor-interface","title":"1.2. TinyRV1 Processor Interface","text":"<p>The single-cycle TinyRV1 processor has the following interface:</p> <pre><code>module Proc\n(\n  (* keep=1 *) input  logic        clk,\n  (* keep=1 *) input  logic        rst,\n\n  // Memory Interface\n\n  (* keep=1 *) output logic        imemreq_val,\n  (* keep=1 *) output logic [31:0] imemreq_addr,\n  (* keep=1 *) input  logic [31:0] imemresp_data,\n\n  (* keep=1 *) output logic        dmemreq_val,\n  (* keep=1 *) output logic        dmemreq_type,\n  (* keep=1 *) output logic [31:0] dmemreq_addr,\n  (* keep=1 *) output logic [31:0] dmemreq_wdata,\n  (* keep=1 *) input  logic [31:0] dmemresp_rdata,\n\n  // I/O Interface\n\n  (* keep=1 *) input  logic [31:0] in0,\n  (* keep=1 *) input  logic [31:0] in1,\n  (* keep=1 *) input  logic [31:0] in2,\n\n  (* keep=1 *) output logic [31:0] out0,\n  (* keep=1 *) output logic [31:0] out1,\n  (* keep=1 *) output logic [31:0] out2,\n\n  // Trace Interface\n\n  (* keep=1 *) output logic        trace_val,\n  (* keep=1 *) output logic [31:0] trace_addr,\n  (* keep=1 *) output logic [31:0] trace_data\n);\n</code></pre> <p></p> <p>Memory Interface</p> <p>The memory interface includes two parts. The instruction memory interface is used to read instructions similar to how we read notes in Lab 3. To read an instruction set the <code>imemreq_val</code> output port high and the <code>imemreq_addr</code> output port to the desired instruction address; the instruction will be returned via the <code>imemresp_data</code> input port combinationally (i.e., in the same cycle). The data memory interface enables load and store instructions to read and write memory. It is similar to the instruction memory interface except now we have an additional <code>dmemreq_type</code> output port which specifies whether we want to read memory (i.e., <code>dmemreq_type</code> is zero) or write memory (i.e., <code>dmemreq_type</code> is one). We also need the <code>dmemreq_wdata</code> output port for the write data.</p> <p>I/O Interface</p> <p>The input/output (I/O) interface enables the processor to send and receive data from the system. We will eventually be connecting the I/O ports to the switches, push buttons, LEDs, and seven-segment displays. We can read the input I/O ports using CSRR instructions and we can write the output I/O ports using CSRW instructions. See the TinyRV1 ISA manual for more information.</p> <p>Trace Interface</p> <p>The trace interface is used for verification and should produce a \"trace\" of all instructions executed by the processor. Whenever the processor executes an instruction it should set the <code>trace_val</code> output high and also set the <code>trace_addr</code> output port to the address of the executed instruction and the <code>trace_data</code> output port to be the data written to the register file by that instruction. If the instruction does not write the register file then the <code>trace_data</code> output is undefined.</p>"},{"location":"ece2300-lab4ab-proc/#12-tinyrv1-single-cycle-processor-implementation","title":"1.2. TinyRV1 Single-Cycle Processor Implementation","text":"<p>The TinyRV1 single-cycle processor implementation will be decomposed into a datapath and a control unit. The datapath must be implemented structurally without any always blocks or non-trivial logic. The control unit will be implemented using flat RTL via a single always block.</p> <p>The following diagram illustrates the complete TinyRV1 single-cycle processor datapath. Note that this diagram is slightly different from lecture, since in lab we need to implement the CSRR/CSRW instructions, the I/O interface, and the trace interface. Again, the datapath should be implemented structurally by instantiating and connecting the processor datapath components developed in Part A.</p> <p></p> <p>The blue arrows are control/status signals between the control unit and the datapath. Control signals go from the control unit to the datapath while status signals go from the datapath to the control unit. Here is a list of all of the control signals you will need for your single-cycle processor implementation (all signals are one bit unless otherwise specified):</p> <ul> <li><code>c2d_pc_sel</code> (2 bits)</li> <li><code>c2d_imm_type</code> (2 bits)</li> <li><code>c2d_op2_sel</code></li> <li><code>c2d_alu_func</code></li> <li><code>c2d_wb_sel</code> (3 bits)</li> <li><code>c2d_rf_wen</code></li> <li><code>c2d_imemreq_val</code></li> <li><code>c2d_dmemreq_val</code></li> <li><code>c2d_dmemreq_type</code></li> <li><code>c2d_out0_en</code></li> <li><code>c2d_out1_en</code></li> <li><code>c2d_out2_en</code></li> </ul> <p>There is one status signal for the single-cycle processor implementation which indicates the branch outcome:</p> <ul> <li><code>d2c_eq</code></li> </ul> <p>The control unit essentially needs to implement a control signal table just like in lecture. We will use the following stylized approach to implement this control signal table:</p> <pre><code>  always_comb begin\n    if ( rst )\n      cs( '0, '0, '0, '0, '0, '0, '0, '0, '0 );\n    else begin\n      casez ( d2c_inst )\n                          //    pc  imm    op2 alu  wb  rf  imem dmem dmem\n                          //    sel type   sel func sel wen val  val  type\n        `TINYRV1_INST_ADDI: cs( 'x, imm_i, 'x, add, 'x, 1,  1,   0,   'x   );\n\n        default:            cs( 'x, 'x,    'x, 'x,  'x, 'x, 1,   'x,  'x   );\n      endcase\n    end\n  end\n</code></pre> <p>There should be one row per instruction and one column for each control signal. You should declare appropriate <code>localparams</code> (e.g., <code>imm_i</code>, <code>add</code>) to make the control signal table more readable.</p> <p>The single-cycle processor should be able to fetch a new instruction from memory, decode this instruction, read the register file, perform arithmetic, access memory, and write the result to the register file all in a single cycle.</p>"},{"location":"ece2300-lab4ab-proc/#13-accumulator-accelerator","title":"1.3. Accumulator Accelerator","text":"<p>Your TinyRV1 single-cycle processor is programmable meaning it can perform different functionality simply by executing different assembly level programs. We will also be implementing a specialized accelerator which can only perform a single function. We will then do a comparative analysis to understand the performance and area of both our general-purpose programmable processor and a specialized accelerator.</p> <p>Our accelerator will perform an accumulation function. It will accumulate 32-bit integer values stored in an array in memory to produce a single sum. You should assume the array starts at memory address 0x00000. The interface for our accelerator is shown below.</p> <pre><code>module AccumXcel\n(\n  (* keep=1 *) input  logic        clk,\n  (* keep=1 *) input  logic        rst,\n\n  (* keep=1 *) input  logic        go,\n  (* keep=1 *) input  logic [13:0] size,\n\n  (* keep=1 *) output logic        result_val,\n  (* keep=1 *) output logic [31:0] result,\n\n  (* keep=1 *) output logic        memreq_val,\n  (* keep=1 *) output logic [15:0] memreq_addr,\n  (* keep=1 *) input  logic [31:0] memresp_data\n);\n</code></pre> <p></p> <p>The memory interface is very similar to the processor memory interface except our accumulator accelerator will only use a 16-bit address. The accelerator will assume the array starts at address zero in the memory. The accelarator also includes a <code>size</code> input port which is used to specify the number of elements stored in the array; note that the size is specified in elements not bytes. So if the size is 4 then the accumulator should read the values stored at memory addresses 0x000, 0x004, 0x008, and 0x00c. The accelerator should wait until the <code>go</code> input port is high; the accelerator should then start its computation. When the accelerator has finished it should set the <code>result</code> output to the final sum and the <code>result_val</code> output high. Your accelerator does not need to be able to support multiple transactions. The accelerator will perform a single accumulation and then stop. We will need to reset the accelerator if we with to perform another accumulation. The waveform below shows an example transaction, assuming that the values at addresses 0x000, 0x004, and 0x008 sum to 6:</p> <p></p> <p>You must implement your accelerator using a datapath (<code>hw/AccumXcelDpath.v</code>) and a control unit (<code>hw/AccumXcelCtrl.v</code>). We have very specific requirements on what kind of hardware modeling is permitted in these two files.</p> <ul> <li> <p>Datapath Rules: The datapath must be completely structural RTL.    You can use any of the components developed in Part A. You should only    instantiate and connect RTL modules that you have implemented and    tested separately. The only exception is if you need to use an adder    you should use the Adder_32b_GL module. This means you cannot directly    use any logic in this module; no always blocks and nothing in an    assign statement other than basic connectivity.</p> </li> <li> <p>Control Unit Rules: The control unit must include just a    finite-state machine. It must have three parts: the state register    which should be implemented using a <code>Register_RTL</code>, an <code>always_comb</code>    block to implement the combinational state transition logic, and an    <code>always_comb</code> block to implement the combinational output logic. There    should be no other logic in the control unit. No <code>always_ff1 blocks    (explicitly instantiate</code>Register_RTL<code>for the state register), no    other</code>always_comb<code>blocks, and nothing in an</code>assign` statement other    than basic connectivity.</p> </li> </ul> <p>You are free to structure your datapath however you like, and you are free to use any kind of finite-state-machine for the control unit; but you must follow the above rules. The provided <code>hw/AccumXcel.v</code> file composes the datapath and control units. You will need to modify this file to add new control and/or status signals.</p>"},{"location":"ece2300-lab4ab-proc/#2-testing-strategy","title":"2. Testing Strategy","text":"<p>You will need to use a variety of different testing strategies to ensure your TinyRV1 processor is full functional.</p>"},{"location":"ece2300-lab4ab-proc/#21-testing-the-processor-datapath-components","title":"2.1. Testing the Processor Datapath Components","text":"<p>It is critical we take a test-driven approach. You must thoroughly verify each processor datapath component using exhaustive, directed, and/or random testing as appropriate. You can use a very similar approach as in the previous labs. Do not under any circumstances start implementing your processor until you are absolutely positive all of your processor datapath components are fully functional.</p>"},{"location":"ece2300-lab4ab-proc/#22-testing-the-processor","title":"2.2. Testing the Processor","text":"<p>Testing the processor is more complex than testing individual hardware blocks. We have provided you some testing infrastructure to simplify the process, but students should still expect to dedicated significant time to verifying their processor correctly implements the TinyRV1 ISA.</p> <p>We have provided you a functional-level FL processor model (also called an instruction set simulator) located in <code>test/ProcFL.v</code>. The FL processor model executes the instruction semantics behaviorally using high-level Verilog. It is not meant to model hardware. The FL processor model can be used to make sure your tests are correct before you run those tests on your single-cycle processor.</p> <p>The test cases for the processor is located in these test files:</p> <ul> <li><code>test/Proc-addi-test-cases.v</code></li> <li><code>test/Proc-add-test-cases.v</code></li> <li><code>test/Proc-mul-test-cases.v</code></li> <li><code>test/Proc-lw-test-cases.v</code></li> <li><code>test/Proc-sw-test-cases.v</code></li> <li><code>test/Proc-jal-test-cases.v</code></li> <li><code>test/Proc-jr-test-cases.v</code></li> <li><code>test/Proc-bne-test-cases.v</code></li> <li><code>test/Proc-csr-test-cases.v</code></li> </ul> <p>Each file should only test a single instruction. Processor test cases look like this:</p> <pre><code>task test_case_1_basic();\n  t.test_case_begin( \"test_case_1_basic\" );\n\n  // Write assembly program into memory\n\n  asm( 'h000, \"addi x1, x0, 2\"   );\n  asm( 'h004, \"addi x2, x1, 2\"   );\n\n  // Check each executed instruction\n\n  check_trace( 'h000, 'h0000_0002 ); // addi x1, x0, 2\n  check_trace( 'h004, 'h0000_0004 ); // addi x2, x1, 2\n\nendtask\n</code></pre> <p>Every processor test case includes two parts.</p> <ul> <li> <p><code>asm</code> tasks are used to write instructions into the memory. The <code>asm</code>    task takes two arguments: the address for the instruction and an    assembly instruction represented as a string. The <code>asm</code> task will take    care of converting the assembly instruction into a machine    instruction. The <code>asm</code> tasks represent the static instruction    sequence (i.e., what instructions are stored in memory before the    processor starts executing).</p> </li> <li> <p><code>check_trace</code> tasks are like the <code>check</code> tasks you have seen    elsewhere, but <code>check_trace</code> tasks will wait for the <code>trace_val</code>    signal to be high before checking to see if the <code>trace_addr</code> and    <code>trace_data</code> outputs from the processor match the desired values. The    <code>check_trace</code> tasks are used to check the dynamic instruction    sequence (i.e., what instructions the processor actually executes at    runtime).</p> </li> </ul> <p>The above basic test case for the ADDI instruction uses the trace to make sure the first ADDI instruction writes the value 2 to the register file and the second ADDI instruction writes the value 4 to the register file. When writing register X0, the trace data is undefined. We do not want to enforce that the register write data is zero when writing X0 since this would require special hardware to handle this case. Here is how you might test reading and writing register X0.</p> <pre><code>task test_case_2_regX0();\n  t.test_case_begin( \"test_case_2_regX0\" );\n\n  // Write assembly program into memory\n\n  asm( 'h000, \"addi x1, x0, 0\"   );\n  asm( 'h004, \"addi x0, x1, 0\"   );\n\n  // Check each executed instruction\n\n  check_trace( 'h000, 'h0000_0000 ); // addi x1, x0, 0\n  check_trace( 'h004, 'x          ); // addi x0, x1, 0\n\nendtask\n</code></pre> <p>Processor test cases for memory can include an additional part:</p> <pre><code>task test_case_1_basic();\n  t.test_case_begin( \"test_case_1_basic\" );\n\n  // Write assembly program into memory\n\n  asm( 'h000, \"addi x1, x0, 0x100\" );\n  asm( 'h004, \"lw   x2, 0(x1)\"     );\n\n  // Write data into memory\n\n  data( 'h100, 32'hdead_beef );\n\n  // Check each executed instruction\n\n  check_trace( 'h000, 'h0000_0100 ); // addi x1, x0, 0x100\n  check_trace( 'h004, 'hdead_beef ); // lw   x2, 0(x1)\n\nendtask\n</code></pre> <p>In addition to the <code>asm</code> tasks and <code>check_trace</code> tasks, we can also use a <code>data</code> task to write data into the memory. The above basic test case for the LW instruction first uses an ADDI instruction to get the memory address 0x100 into register x1. The test case then performs a LW instruction to load the data from address 0x100 into register x2. The <code>check_trace</code> tasks verify that the ADDI instruction correctly writes the address to the register file, and that the LW instruction correctly loads the value 0xdeadbeef from memory address 0x100.</p> <p>The <code>check_trace</code> tasks become particularly important when testing control flow instructions. The following test case is for the JAL instruction:</p> <pre><code>task test_case_1_basic();\n  t.test_case_begin( \"test_case_1_basic\" );\n\n  // Write assembly program into memory\n\n  asm( 'h000, \"addi x1, x0, 1\" );\n  asm( 'h004, \"jal  x2, 0x00c\" );\n  asm( 'h008, \"addi x1, x0, 2\" );\n  asm( 'h00c, \"addi x1, x0, 3\" );\n\n  // Check each executed instruction\n\n  check_trace( 'h000, 'h0000_0001 ); // addi x1, x0, 1\n  check_trace( 'h004, 'h0000_0008 ); // jal  x2, 0x00c\n  check_trace( 'h00c, 'h0000_0003 ); // addi x1, x0, 3\n\nendtask\n</code></pre> <p>Here we can see the static instruction sequence includes four instructions, but the dynamic instruction sequence only includes three instructions because the JAL instruction jumps over the instruction at address 0x008. Note that in the assembly format used for testing our processor, the literal in a JAL and BNE instruction is the absolute address of the target not the actual immediate. The assembler will take care of creating the appropriate PC relative immediate.</p> <p>You can run the test cases for the ADDI instruction on the FL processor model like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make ProcFL-addi-test\n% ./ProcFL-addi-test\n</code></pre> <p>You can run those same test cases for the ADDI instruction on the single-cycle processor like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make ProcScycle-addi-test\n% ./ProcScycle-addi-test\n</code></pre> <p>You will need to add more tests cases to the appropriate <code>-test-cases.v</code> file, and also add corresponding calls to these test cases in the <code>ProcFL-*-test.v</code> and <code>ProcScycle-*-test.v</code>. Do not simple have a single directed test case (i.e., a single task); you must have many directed test cases (i.e., many tasks). Each directed test case should focus on testing a different aspect of the corresponding instruction. Remember to always make sure your tests pass on the FL processor model before attempting to run those tests on your single-cycle processor model!</p>"},{"location":"ece2300-lab4ab-proc/#23-testing-the-accelerator","title":"2.3. Testing the Accelerator","text":"<p>We provide you some simple tests for your accumulator accelerator. You can run those tests like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make AccumXcel-test\n% ./AccumXcel-test\n</code></pre> <p>While not required, feel free to write more tests if you like.</p>"},{"location":"ece2300-lab4ab-proc/#3-getting-started","title":"3. Getting Started","text":"<p>We cannot stress enough how important it is to take an incremental approach on this lab!</p>"},{"location":"ece2300-lab4ab-proc/#31-getting-started-on-the-processor","title":"3.1. Getting Started on the Processor","text":"<p>Do not implement the entire datapath, then implement the entire control unit, and then try to run your first test! You must take an incremental approach. Start by implementing just what you need in the datapath to execute an ADDI instruction, then add the corresponding row to the control signal table in the control unit. Then add many directed test cases to ensure your ADDI instruction is executing correctly. Then move on to the next instruction. We recommend you implement and test the instructions in this order:</p> <ul> <li>ADDI</li> <li>ADD</li> <li>MUL</li> <li>LW</li> <li>SW</li> <li>JAL</li> <li>JR</li> <li>BNE</li> <li>CSRR/CSRW</li> </ul> <p>To get you started we have provided you a functional datapath (see below) and control unit capable of executing ADDI instructions. Your first task should be to add many more directed tests for the ADDI instruction. Remember to make sure these tests pass on the FL processor model! Once your design is passing these tests and you are confident your design is functional then you can move on and add just what you need in the datapath to executed ADD instructions. Then add the corresponding row to the control signal table in the control unit.</p> <p></p>"},{"location":"ece2300-lab4ab-proc/#32-getting-started-on-the-accelerator","title":"3.2. Getting Started on the Accelerator","text":"<p>Do not implement the entire datapath, then implement the entire control unit, and then try to run your first test! You must take an incremental approach. We provide you a simple basic test case which can help. You can run this basic test case and look at the waveforms like this:</p> <pre><code>   % make AccumXcel-test\n   % ./AccumXcel-test +test-case=1 +dump-vcd=waves.vcd\n   % code waves.vcd\n</code></pre> <p>This test case does not actually check anything. It just sets <code>size</code> to 4, sets <code>go</code> to 1, and then waits 6 cycles. It is useful because you can look at the waveforms to see if your design is performing as expected as you use an incremental design approach. We recommend you develop your accelerator using the following three steps (this is exactly what the course staff did!):</p> <ul> <li> <p>Step 1: Fetch: Implement a datapath and FSM that just fetches data    from memory and never stops. Run this basic test case, dump the    waveforms, then look at the waveforms in Surfer. See if your    accelerator is correctly fetching each element from memory.</p> </li> <li> <p>Step 2: Fetch and Stop: Augment your datapath and FSM so that it    fetches data from memory and stop once it fetches <code>size</code> elements.    Run this basic test case, dump the waveforms, then look at the    waveforms in Surfer. See if your accelerator is correctly fetching    each element from memory and also stops after fetching four elements.</p> </li> <li> <p>Step 2: Fetch, Accumulate, and Stop: Now that you know your    accelerator can fetch data correctly, augment your datapath and FSM so    that it fetches data from memory, does the accumulation, and stops    once it fetches <code>size</code> elements. Run this basic test case, dump the    waveforms, then look at the waveforms in Surfer. See if your    accelerator is correctly fetching each element from memory,    accumulating the values, stops after fetching four elements, and    outputs the correct sum.</p> </li> </ul> <p>Once you have completed all three steps then you can try the rest of the test cases.</p>"},{"location":"ece2300-lab4d-proc/","title":"Lab 4 (Part D): TinyRV1 Processor - FPGA Analysis/Prototype","text":"<p>Lab 4 will give you experience designing, implementing, testing, and prototyping a single-cycle processor microarchitecture and a specialized accelerator. The processor will implement the TinyRV1 instruction set. The instruction set manual is located here:</p> <ul> <li>https://cornell-ece2300.github.io/ece2300-docs/ece2300-tinyrv1-isa</li> </ul> <p>The lab reinforces several lecture topics including instruction set architectures, single-cycle processors, and finite-state machines. The lab will continue to provide opportunities to leverage the three key abstraction principles: modularity, hierarchy, and regularity.</p> <p>You should have already worked in simulation to verify all processor components and your single-processor in Lab 4 Parts A and B. In Lab 4 Part D, we will be using the FPGA to prototype the single-cycle processor and demonstrate the processor running two TinyRV1 assembly programs. In Lab 4 Part E, you will study an accumulation workload executing on both the single-cycle TinyRV1 processor and a specialized accelerator.</p> <p>This handout assumes that you have read and understand the course tutorials, discussion sections, and successfully completed Labs 1-3. Here are the steps to get started:</p> <ul> <li>Step 1. Find your lab partner</li> <li>Step 2. Find a free workstation</li> <li>Step 3. Ask the TAs for a lab check-off sheet (each student needs     their own check-off sheet)</li> </ul> <p>Throughout this handout you will see two kinds tasks: lab check-off tasks and lab report tasks.</p> <p>For each lab report task you must take some notes, save a screenshot, and/or record some data for your lab report. The lab report is due in the during the last week of classes.</p> <p>For each lab check-off task you must raise your hand and have a TA come to check-off your work. The TA will ask you the questions included as part of the lab check-off task and the assess your understanding using the following rubric: mastery; accomplished; emerging; beginning. If the TA and students together feel the students have not mastered the lab check-off task, the students are encouraged to take a few minutes and try again.</p> <p>Lab Check-Off Task 1: Setup FPGA Board</p> <p>Request an FPGA board from the TAs. The TAs will record the board number on your check-off sheet. Use the power cord to plug the FPGA board into an outlet, and use the USB cable to plug the FPGA board into the workstation.</p>"},{"location":"ece2300-lab4d-proc/#1-verifying-single-cycle-tinyrv1-processor","title":"1. Verifying Single-Cycle TinyRV1 Processor","text":"<p>Before starting to work on an FPGA prototype, you must make sure you have a working Verilog hardware design that has been thoroughly tested in simulation. One student should start VS Code on the workstation, log into the <code>ecelinux</code> servers, source the setup script, and make sure their group repository is up to date.</p> <pre><code>% source setup-ece2300.sh\n% cd ${HOME}/ece2300/groupXX\n% git pull\n% tree\n</code></pre> <p>Where <code>XX</code> is your group number. Now run all of the tests from a clean build to ensure your design is fully functional.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc\n% trash build\n% mkdir build\n% cd build\n% ../configure\n% make check\n</code></pre> <p>We now need to get the files for your design from <code>ecelinux</code> onto the workstation. This requires multiple steps.</p> <ul> <li> <p>Step 1. Click Microsoft Edge on the desktop to open a web-browser on    the workstation to log into GitHub and then find your repository</p> </li> <li> <p>Step 2. Start PowerShell by clicking the Start menu then searching    for Windows PowerShell</p> </li> <li> <p>Step 3. Clone your repo onto the workstation by using this command in    PowerShell (where <code>netid</code> is your Cornell NetID, notice we are using    https!):</p> </li> </ul> <pre><code>% git clone https://github.com/cornell-ece2300/groupXX\n</code></pre> <ul> <li> <p>Step 4. In the Connect to GitHub pop-up, click Sign in with your    browser</p> </li> <li> <p>Step 5. You may be asked for your GitHub username again and you may be    asked to authorize the Git Credential Manager; click authorize    git-ecosystem</p> </li> <li> <p>Step 6. Verify that you have successfully cloned your repo by changing    into your repo and using <code>tree</code> on the workstation:</p> </li> </ul> <pre><code>% cd groupXX\n% tree\n</code></pre> <p>Lab Check-Off Task 2: Verify Tests</p> <p>Show a TA that your hardware designs are passing all of your tests. The TA will ask the students to explain their testing strategy for two different instructions. Students should show the TA their tests and explain how these tests ensure correct functionality of the TinyRV1 processor.</p>"},{"location":"ece2300-lab4d-proc/#2-setup-quartus-project","title":"2. Setup Quartus Project","text":"<p>Click Quartus (Quartus Prime 19.1) on the desktop to start Quartus, and click Run the Quartus Prime software. You might need to try starting Quartus twice. Setup a new Quartus project using the New Project Wizard:</p> <ul> <li>Directory, Name, Top-Level Entity<ul> <li>Working directory: <code>C:\\Users\\netid\\lab4</code></li> <li>Name of this project: <code>lab4</code></li> <li>Name of top-level design entity: <code>lab4</code></li> <li>Click Next</li> </ul> </li> <li>Directory does not exist. Do you want to create it?<ul> <li>Click yes</li> </ul> </li> <li>Project Type<ul> <li>Choose Empty Project</li> <li>Click Next</li> </ul> </li> <li>Add Files<ul> <li>Click triple dots to right of File name</li> <li>Click on This PC, then navigate to your cloned repo by choosing    Windows (C:) &gt;  Users &gt; netid &gt; netid where netid is your    Cornell NetID</li> <li>Shift-click on every Verilog hardware design file (do not include    any test files)</li> <li>Click Open</li> <li>Click Next</li> </ul> </li> <li>Family, Device, and Board Settings<ul> <li>Click Board tab</li> <li>Family: Cyclone V</li> <li>Select DE0-CV Development Board</li> <li>Make sure Create top-level design file is checked</li> <li>Click Next</li> </ul> </li> <li>EDA Tool Settings<ul> <li>Click Next</li> </ul> </li> <li>Summary<ul> <li>Click Finish</li> </ul> </li> </ul> <p>Since we are now using RTL modeling, there is one new step, similar to Labs 2 and 3. You must choose Assignments &gt; Settings from the menu. Then select the category Compiler Settings &gt; Verilog HDL Input and under Verilog version click SystemVerilog. Then click OK.</p>"},{"location":"ece2300-lab4d-proc/#3-demonstrating-simple-tinyrv1-program","title":"3. Demonstrating Simple TinyRV1 Program","text":"<p>We will start by verifying your TinyRV1 processor running a very simple program that we provide for you.</p>"},{"location":"ece2300-lab4d-proc/#31-simulate-simple-tinyrv1-program","title":"3.1. Simulate Simple TinyRV1 Program","text":"<p>We provide you two simulators which emulate what will happen when your processor is configured on the FPGA. These simulators and the actual FPGA will use the following connections:</p> <ul> <li><code>in0[4:0]</code> is connected to first five switches</li> <li><code>in1[4:0]</code> is connected to second five switches</li> <li><code>in2[0]</code> is connected to a push-button</li> <li><code>out0[4:0]</code> is connected to the two seven-segment displays</li> <li><code>out1[4:0]</code> is connected to the two seven-segment displays</li> <li><code>out2[4:0]</code> is connected to the two seven-segment displays</li> </ul> <p>Take a look at the <code>sim/proc-sim-prog1.v</code> file on <code>ecelinux</code> using VS Code.</p> <pre><code>task proc_sim_prog1();\n\n  asm( 'h000, \"addi x1, x0, 2\"   );\n  asm( 'h004, \"addi x2, x1, 2\"   );\n  asm( 'h008, \"csrw out0, x2\"    );\n  asm( 'h00c, \"jal  x0, 0x00c\"   );\n\nendtask\n</code></pre> <p>The programs that run on the simulator look very similar to the tests you wrote in Lab 4 Part B. One key difference is that our processor prototypes will be using a very small 256-byte memory which only has space for 64 32-bit words. This means we need to keep our programs pretty short for now! Before continuing, make sure you understand the expected behavior of this assembly program.</p> <p>You can run this program on the FL processor simulator on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=1\n</code></pre> <p>Confirm that the behavior is as expected. Now run the program on the single-cycle processor simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=1\n</code></pre> <p>Ideally, an effective testing strategy will ensure that your single-cycle processor is fully correct by the time we start using these interactive simulators. However, if the behavior is not as expected then you will have no choice but to try and debug what has gone wrong. You will need to use waveforms to carefully examine each cycle. You can dump waveforms using the <code>+dump-vcd=waves.vcd</code> command line option. You should probably use what you learn to add more directed tests cases.</p> <p>The simulators support up to three different programs located in <code>sim/proc-sim-prog1.v</code>, <code>sim/proc-sim-prog2.v</code>, and <code>sim/proc-sim-prog3.v</code>. Once you have verified a program works, then we need to take an extra step to choose which program will actually run on the processor once it has been configured to the FPGA. The program which will run on the processor once it has been configured to the FPGA is located in the <code>hw/ProcMem.v</code> module. Go ahead and take a look at this file on <code>ecelinux</code> using VS Code. You will see a region of the module that looks like this:</p> <pre><code>   if ( rst ) begin\n      mem[   0] &lt;= 32'h00200093; // 00000000 addi x1, x0, 2\n      mem[   1] &lt;= 32'h00208113; // 00000004 addi x2, x1, 2\n      mem[   2] &lt;= 32'h7c211073; // 00000008 csrw out0, x2\n      mem[   3] &lt;= 32'h0000006f; // 0000000c jal  x0, 0x00c\n    end\n</code></pre> <p>This is where we ensure the memory has the desired program when the FPGA is reset. Writing this by hand would be tedious, so our simulators provide the <code>+dump-bin</code> command line option which will dump out what you need to copy into <code>hw/ProcMem.v</code>. For example,</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=1 +dump-bin\n\n      mem[   0] &lt;= 32'h00200093; // 00000000 addi x1, x0, 2\n      mem[   1] &lt;= 32'h00208113; // 00000004 addi x2, x1, 2\n      mem[   2] &lt;= 32'h7c211073; // 00000008 csrw out0, x2\n      mem[   3] &lt;= 32'h0000006f; // 0000000c jal  x0, 0x00c\n</code></pre> <p>So once you have verified one of your assembly programs works, use <code>+dump-bin</code> and then copy-and-paste the resulting lines into <code>hw/ProcMem.v</code>. You can use program number 0 to verify that the program currently stored in <code>hw/ProcMem.v</code> works as expected:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0\n</code></pre> <p>Lab Check-Off Task 3: Simulate Simple Program</p> <p>Show a TA the provided simple assembly program running on (1) the FL processor simulator; (2) the single-cycle processor simulator; and (3) the single-cycle processor simulator with the <code>ProcMem</code>. Here are the steps you need to show the TA.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% make proc-scycle-sim\n% ./proc-fl-sim     +prog-num=1\n% ./proc-scycle-sim +prog-num=1\n% ./proc-scycle-sim +prog-num=0\n</code></pre>"},{"location":"ece2300-lab4d-proc/#32-synthesize-and-analyze-single-cycle-tinyrv1-processor","title":"3.2. Synthesize and Analyze Single-Cycle TinyRV1 Processor","text":"<p>Now that we know our single-cycle processor can successfully execute the simple assembly program in simulation, we want to see if we can verify the same program running on the processor FPGA prototype. As in previous labs, the New Project Wizard creates a top-level Verilog module for us which has ports for all of the switches, LEDs, seven-segment displays, and pins on the FPGA development board. Here is the code you can use for your top-level design.</p> <pre><code>  logic clk;\n  assign clk = CLOCK_50;\n\n  logic        imemreq_val;\n  logic [31:0] imemreq_addr;\n  logic [31:0] imemresp_data;\n\n  logic        dmemreq_val;\n  logic        dmemreq_type;\n  logic [31:0] dmemreq_addr;\n  logic [31:0] dmemreq_wdata;\n  logic [31:0] dmemresp_rdata;\n\n  logic [31:0] proc_out0;\n  logic [31:0] proc_out1;\n  logic [31:0] proc_out2;\n\n  logic        proc_trace_val_unused;\n  logic [31:0] proc_trace_addr_unused;\n  logic [31:0] proc_trace_data_unused;\n\n  ProcScycle proc\n  (\n    .clk             (clk),\n    .rst             (~RESET_N),\n\n    .imemreq_val     (imemreq_val),\n    .imemreq_addr    (imemreq_addr),\n    .imemresp_data   (imemresp_data),\n\n    .dmemreq_val     (dmemreq_val),\n    .dmemreq_type    (dmemreq_type),\n    .dmemreq_addr    (dmemreq_addr),\n    .dmemreq_wdata   (dmemreq_wdata),\n    .dmemresp_rdata  (dmemresp_rdata),\n\n    .in0             ({27'b0,SW[9:5]}),\n    .in1             ({27'b0,SW[4:0]}),\n    .in2             ({31'b0,~KEY[0]}),\n\n    .out0            (proc_out0),\n    .out1            (proc_out1),\n    .out2            (proc_out2),\n\n    .trace_val       (proc_trace_val_unused),\n    .trace_addr      (proc_trace_addr_unused),\n    .trace_data      (proc_trace_data_unused)\n  );\n\n  ProcMem mem\n  (\n    .clk             (clk),\n    .rst             (~RESET_N),\n\n    .imemreq_val     (imemreq_val),\n    .imemreq_addr    (imemreq_addr),\n    .imemresp_data   (imemresp_data),\n\n    .dmemreq_val     (dmemreq_val),\n    .dmemreq_type    (dmemreq_type),\n    .dmemreq_addr    (dmemreq_addr),\n    .dmemreq_wdata   (dmemreq_wdata),\n    .dmemresp_rdata  (dmemresp_rdata)\n  );\n\n  Display_GL proc_out0_display\n  (\n    .in       (proc_out0[4:0]),\n    .seg_tens (HEX5),\n    .seg_ones (HEX4)\n  );\n\n  Display_GL proc_out1_display\n  (\n    .in       (proc_out1[4:0]),\n    .seg_tens (HEX3),\n    .seg_ones (HEX2)\n  );\n\n  Display_GL proc_out2_display\n  (\n    .in       (proc_out2[4:0]),\n    .seg_tens (HEX1),\n    .seg_ones (HEX0)\n  );\n</code></pre> <p>Spend a few minutes making sure you understand this top-level composition. Once you are happy with your understanding, you just need to copy this code into the DE0_CV_golden_top.v. After understanding the top-level, try compiling and synethsizing the design. Before continuing, STOP!!! Double check your ProcSCycle module for any inferred latches. The compilation will emit warnings regarding inferred latches. These warnings are confusingly in green text. Check out this Ed post for some more information on how to fix common issues, including inferred latches, we have seen this week in lab this week.</p> <p>As in previous labs, we need to create a timing constraint file. Here are the steps to create an initial timing constraint file:</p> <ul> <li>Choose File &gt; New from the menu</li> <li>Click Synopsys Design Constraints File</li> <li>Click OK</li> <li>Enter the constraints shown below</li> <li>Click File &gt; Save from the menu</li> <li>Name the file timing.sdc</li> <li>Save the file in the lab4 directory</li> </ul> <p>We will use the following initial constraints:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -name clk -period 20 [get_ports {CLOCK_50}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay  -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay  -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>These constraints tell the FPGA tools that:</p> <ul> <li>Our critical path delay constraint is <code>20ns</code> from all inputs to all    outputs as well</li> <li>We have a clock signal named <code>clk</code><ul> <li>There should be setup time violations with respect to   <code>clk</code> when the period is <code>20ns</code></li> <li>There should be no hold time violations with respect to <code>clk</code></li> </ul> </li> <li>The output ports have a setup time of 0 (max constraint) and a hold    time of 0 (min constraint)</li> <li>The input ports have clock-to-port propagation delay of 0 (max    constraint) and a clock-to-port contamination delay of 0 (min    constraint)</li> </ul> <p>Choose Processing &gt; Start Compilation from the menu to synthesize your design. You will need to wait 5-10 minutes for synthesis to complete. Be patient!</p> <p>It is very likely that your design will not meet timing, so go ahead and analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>Clocks - From clock: clk</li> <li>Clocks - To clock: clk</li> <li>Targets - From: [get_registers *]</li> <li>Targets - To: [get_registers *]</li> <li>Report number of paths: 1</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the propagation delay of the displayed path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one of the inputs through your     design to one of the outputs</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Since our design did not meet timing we need to slow down the clock frequency. We have provided you a clock divider in <code>hw/ClockDiv_RTL.v</code> which will reduce the clock frequency by a factor of four. Go ahead and instantiate the clock divider at the top-level like this:</p> <pre><code>  logic clk;\n  // assign clk = CLOCK_50;\n  ClockDiv_RTL clock_div\n  (\n    .clk_in  (CLOCK_50),\n    .clk_out (clk)\n  );\n</code></pre> <p>We also need to update the timing constraints to tell the tools that the processor now only needs to meet an 80ns (12.5MHz) timing constraint. update the timing constraint file as follows.</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -period 20 [get_ports {CLOCK_50}]\ncreate_clock -name clk -period 80 [get_nets {ClockDiv_RTL:clock_div|count[1]}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay  -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay  -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>Now re-synthesize your design and confirm it meets timing. Look at the critical path using the Timing Analyzer.</p> <p>Lab Check-Off Task 4: Successfully Synthesize Single-Cycle Processor</p> <p>Show a TA your top-level design with the clock divider and the final timing report. Use the final timing report to discuss with the TA where the critical path goes through the single-cycle processor.</p>"},{"location":"ece2300-lab4d-proc/#33-configure-tinyrv1-processor-and-run-simple-program","title":"3.3. Configure TinyRV1 Processor and Run Simple Program","text":"<p>Now we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>You probably need to press the reset button on the FPGA board to start the execution of the assembly program. Confirm that the seven-segment displays show the exact same output as the simulation.</p> <p>Lab Check-Off Task 5: Demonstrate TinyRV1 Processor Running Simple Program</p> <p>First, show the TA the same simulation you did earlier on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0\n</code></pre> <p>Then press the reset button the FPGA board to show the TA that your FPGA prototype produces the expected output.</p>"},{"location":"ece2300-lab4d-proc/#4-demonstrate-complex-tinyrv1-programs","title":"4. Demonstrate Complex TinyRV1 Programs","text":"<p>In the previous part, we provided you the simple assembly program. In this part, you will demonstrate a more complex TinyRV1 program that you write on your own. The program must use all three arithmetic instructions (<code>addi</code>, <code>add</code>, <code>mul</code>), must use both memory instructions (<code>lw</code>, <code>sw</code>), and must use the <code>bne</code> instruction. The program should get at least one input value from the switches using a <code>csrr</code> instruction and should write one to three output values using <code>csrw</code> instructions. We recommend ending your assembly program with an infinite loop like this:</p> <pre><code>  asm( 'h00c, \"jal  x0, 0x00c\"   );\n</code></pre> <p>Note that you will obviously need to use a different instruction address. This way your processor will stop executing new instructions when it reaches the infinite loop. Students can experiment with smaller programs if they like, but the final program for the lab check-off needs to follow the above rules.</p>"},{"location":"ece2300-lab4d-proc/#41-complete-worksheet-for-complex-tinyrv1-program","title":"4.1. Complete Worksheet for Complex TinyRV1 Program","text":"<p>You will start by filling out a paper worksheet with your complex TinyRV1 program. Remember that our FPGA prototype will only have a 256-byte memory which means there are only 64 32-bit memory locations for both instructions and data! The worksheet should show the assembly for each instruction, the values of <code>in0</code>, <code>in1</code>, and <code>in2</code> at the start of the program, the location of the instructions in memory, and any initial data values in memory. You should then go ahead and \"execute\" the assembly program by hand using the worksheet. Use checks next to each instruction and update the register/memory values. Make sure that <code>out0</code>, <code>out1</code>, and <code>out2</code> reflect the expected outputs at the end of the program. You want to make sure that you use either <code>in0</code> or <code>in1</code> to provide input data and that this input data should influence the final output data that is written to <code>out0</code>, <code>out1</code>, or <code>out2</code>.</p> <p>Lab Report Task 1: Complex TinyRV1 Program Worksheet</p> <p>Make sure to keep your worksheet. You will need to include it in your lab report. Feel free to ask for another copy if you want to clean up your worksheet before including it in your lab report.</p> <p>Lab Check-Off Task 6: Complex TinyRV1 Program Worksheet</p> <p>Show a TA your worksheet. Explain how each instruction executes step-by-step. Explain the final expected values for <code>out0</code>, <code>out1</code>, and <code>out2</code>. Explain how the final expected values for <code>out0</code>, <code>out1</code>, and <code>out2</code> would change if we modify <code>in0</code> or <code>in1</code>.</p>"},{"location":"ece2300-lab4d-proc/#42-simulate-complex-tinyrv1-program","title":"4.2. Simulate Complex TinyRV1 Program","text":"<p>Now write your complex TinyRV1 program in the <code>sim/proc-sim-prog2.v</code> file. You can use the <code>data()</code> task to initialize values in memory just like in your tests. Once you have written your program, you can test it on the FL processor simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=2 +in0-switches=00000 +in1-switches=00000\n</code></pre> <p>If this does not produce the expected behavior, then you need to revisit your worksheet or possibly use waveforms to understand the execution of your program. Try different values for <code>in0</code> and <code>in1</code>. Once you are happy with your program, you can test it on the single-cycle processor simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00000 +in1-switches=00000\n</code></pre> <p>If the FL processor simulator produces the expected behavior but the single-cycle processor simulator does not then there might be a bug in your single-cycle processor. Ideally, an effective testing strategy will ensure that your single-cycle processor is fully correct by the time we start using these interactive simulators. However, if the behavior is not as expected then you will have no choice but to try and debug what has gone wrong. You will need to use waveforms to carefully examine each cycle. You can dump waveforms using the <code>+dump-vcd=waves.vcd</code> command line option. You should probably use what you learn to add more directed tests cases.</p> <p>Once your program is producing the expected behavior on both the FL processor and single-cycle processor simulators, you are ready to put the program into the memory which will actually be programmed on the FPGA. Use the <code>+dump-bin</code> command line option like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=2 +dump-bin\n</code></pre> <p>Then copy-and-paste the corresponding code into <code>hw/ProcMem.v</code>. Then verify that your single-cycle processor still produces the expected output when using this memory image.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00000 +in2-switches=00000\n</code></pre> <p>Lab Check-Off Task 7: Complex TinyRV1 Program Simulation</p> <p>Show a TA your assembly program producing the expected output (based on your worksheet) as follows:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% make proc-scycle-sim\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00000 +in1-switches=00000\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00000 +in1-switches=00000\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00000 +in1-switches=00000\n</code></pre> <p>Then you must show the TA how the output changes when you modify the input switches using either <code>+in0-switches</code> and/or <code>+in1-switches</code>.</p>"},{"location":"ece2300-lab4d-proc/#43-synthesize-analyze-and-configure-single-cycle-tinyrv1-processor","title":"4.3. Synthesize, Analyze, and Configure Single-Cycle TinyRV1 Processor","text":"<p>Copy-and-paste your new program from <code>ecelinux</code> to the <code>hw/ProcMem.v</code> file on the lab workstation. Keep the same top-level design and timing constraints as before. Choose Processing &gt; Start Compilation from the menu to synthesize your design. Confirm your design still meetings timing with the 80ns clock constraint.</p> <p>Now we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>You probably need to press the reset button on the FPGA board to start the execution of the assembly program. Confirm that the seven-segment displays show the exact same output as the simulation.</p> <p>Lab Check-Off Task 8: Demonstrate TinyRV1 Processor Running Complex Program</p> <p>First, show the TA the same simulation you did earlier on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00000 +in1-switches=00000\n</code></pre> <p>Then press the reset button the FPGA board to show the TA that your FPGA prototype produces the expected output. Then modify the input switches in simulation and also on the FPGA board and demonstrate that the FPGA prototype produces the same output as the simulation.</p> <p>Lab Check-Off Task 9: Turn In FPGA Board</p> <p>When you are finished with your demo, pack up your FPGA development board. Neatly put the board, power cable, and USB cable back in the box. Return the box to a TA who will then record the board number on your check-off sheet, initial the final check-off, and then collect your check-off sheet.</p>"},{"location":"ece2300-lab4ef-proc/","title":"Lab 4 (Parts E &amp; F): TinyRV1 Processor - FPGA Analysis/Prototype and Report","text":"<p>Lab 4 will give you experience designing, implementing, testing, and prototyping a single-cycle processor microarchitecture and a specialized accelerator. The processor will implement the TinyRV1 instruction set. The instruction set manual is located here:</p> <ul> <li>https://cornell-ece2300.github.io/ece2300-docs/ece2300-tinyrv1-isa</li> </ul> <p>The lab reinforces several lecture topics including instruction set architectures, single-cycle processors, and finite-state machines. The lab will continue to provide opportunities to leverage the three key abstraction principles: modularity, hierarchy, and regularity.</p> <p>You should have already worked in simulation to verify all processor components, your single-processor, and your accumulate accelerator in Lab 4A, 4B, and 4C. You should also have already finished your initial single-cycle FPGA prototype in Lab 4D. In Lab 4E, we will first implement a two-function calculator assembly program before extending this program to support subtraction. We will then implement an accumulate assembly program and quantify the area and performance of this kernel running on your single-cycle processor. Finally, we will quantitatively compare the area and performance of this software implementation to a specialized accumulate accelerator.</p> <p>This handout assumes that you have read and understand the course tutorials, discussion sections, and successfully completed Labs 1-3. Here are the steps to get started:</p> <ul> <li>Step 1. Find your lab partner</li> <li>Step 2. Find a free workstation</li> <li>Step 3. Ask the TAs for a lab check-off sheet (each student needs     their own check-off sheet)</li> </ul> <p>Throughout this handout you will see two kinds tasks: lab check-off tasks and lab report tasks.</p> <p>For each lab report task you must take some notes, save a screenshot, and/or record some data for your lab report. Students can start working on their lab report during their lab session, but will likely need to continue working on their lab report after the lab session. The lab report is due on Monday, Dec 9th at 11:59pm for all groups regardless of your lab session.</p> <p>For each lab check-off task you must raise your hand and have a TA come to check-off your work. The TA will ask you the questions included as part of the lab check-off task and the assess your understanding using the following rubric: mastery; accomplished; emerging; beginning. If the TA and students together feel the students have not mastered the lab check-off task, the students are encouraged to take a few minutes and try again.</p> <p>Lab Check-Off Task 1: Setup FPGA Board</p> <p>Request an FPGA board from the TAs. The TAs will record the board number on your check-off sheet. Use the power cord to plug the FPGA board into an outlet, and use the USB cable to plug the FPGA board into the workstation.</p>"},{"location":"ece2300-lab4ef-proc/#1-verifying-single-cycle-tinyrv1-processor-and-accumulate-accelerator","title":"1. Verifying Single-Cycle TinyRV1 Processor and Accumulate Accelerator","text":"<p>Before starting to work on an FPGA prototype, you must make sure you have a working Verilog hardware design that has been thoroughly tested in simulation. One student should start VS Code on the workstation, log into the <code>ecelinux</code> servers, source the setup script, and make sure their group repository is up to date.</p> <pre><code>% source setup-ece2300.sh\n% cd ${HOME}/ece2300/groupXX\n% git pull\n% tree\n</code></pre> <p>Where <code>XX</code> is your group number. Now run all of the tests from a clean build to ensure your design is fully functional.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc\n% trash build\n% mkdir build\n% cd build\n% ../configure\n% make check\n% source ../scripts/lab4c-run-tests.sh\n</code></pre> <p>We now need to get the files for your design from <code>ecelinux</code> onto the workstation. This requires multiple steps.</p> <ul> <li> <p>Step 1. Click Microsoft Edge on the desktop to open a web-browser on    the workstation to log into GitHub and then find your repository</p> </li> <li> <p>Step 2. Start PowerShell by clicking the Start menu then searching    for Windows PowerShell</p> </li> <li> <p>Step 3. Clone your repo onto the workstation by using this command in    PowerShell (where <code>netid</code> is your Cornell NetID, notice we are using    https!):</p> </li> </ul> <pre><code>% git clone https://github.com/cornell-ece2300/groupXX\n</code></pre> <ul> <li> <p>Step 4. In the Connect to GitHub pop-up, click Sign in with your    browser</p> </li> <li> <p>Step 5. You may be asked for your GitHub username again and you may be    asked to authorize the Git Credential Manager; click authorize    git-ecosystem</p> </li> <li> <p>Step 6. Verify that you have successfully cloned your repo by changing    into your repo and using <code>tree</code> on the workstation:</p> </li> </ul> <pre><code>% cd groupXX\n% tree\n</code></pre> <p>Lab Check-Off Task 2: Verify Tests</p> <p>Show a TA that your hardware designs are passing all of your tests. Show the TA running a single test case for your accumulate accelerator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make AccumXcel-test\n% ./AccumXcel-test +test-case=5 +dump-vcd=waves.vcd\n% code waves.vcd\n</code></pre> <p>The final result should be 36. The TA will first ask the students to explain why the correct answer is 36. The students need to display the <code>clk</code>, <code>rst</code>, <code>go</code>, <code>size</code>, <code>result_val</code>, and <code>result</code> ports as well as the internal state register for the accumulate accelerator FSM in the waveforms. The TA will ask the students to show where in the waveforms the accelerator is producing the value 36. The TA will then ask the students to explain how many cycles it takes to calculate this result and to justify why it takes this many cycles using the waveform.</p>"},{"location":"ece2300-lab4ef-proc/#2-setup-quartus-project","title":"2. Setup Quartus Project","text":"<p>Click Quartus (Quartus Prime 19.1) on the desktop to start Quartus, and click Run the Quartus Prime software. You might need to try starting Quartus twice. Setup a new Quartus project using the New Project Wizard:</p> <ul> <li>Directory, Name, Top-Level Entity<ul> <li>Working directory: <code>C:\\Users\\netid\\lab4e</code></li> <li>Name of this project: <code>lab4e</code></li> <li>Name of top-level design entity: <code>lab4e</code></li> <li>Click Next</li> </ul> </li> <li>Directory does not exist. Do you want to create it?<ul> <li>Click yes</li> </ul> </li> <li>Project Type<ul> <li>Choose Empty Project</li> <li>Click Next</li> </ul> </li> <li>Add Files<ul> <li>Click triple dots to right of File name</li> <li>Click on This PC, then navigate to your cloned repo by choosing    Windows (C:) &gt;  Users &gt; netid &gt; netid where netid is your    Cornell NetID</li> <li>Shift-click on every Verilog hardware design file (do not include    any test files)</li> <li>Click Open</li> <li>Click Next</li> </ul> </li> <li>Family, Device, and Board Settings<ul> <li>Click Board tab</li> <li>Family: Cyclone V</li> <li>Select DE0-CV Development Board</li> <li>Make sure Create top-level design file is checked</li> <li>Click Next</li> </ul> </li> <li>EDA Tool Settings<ul> <li>Click Next</li> </ul> </li> <li>Summary<ul> <li>Click Finish</li> </ul> </li> </ul> <p>Since we are now using RTL modeling, there is one new step, similar to Labs 2 and 3. You must choose Assignments &gt; Settings from the menu. Then select the category Compiler Settings &gt; Verilog HDL Input and under Verilog version click SystemVerilog. Then click OK.</p>"},{"location":"ece2300-lab4ef-proc/#3-three-function-calculator-tinyrv1-program","title":"3. Three-Function Calculator TinyRV1 Program","text":"<p>In this part, we will implement a TinyRV1 assembly program that has the same behavior as the two-function calculator we implemented in Lab 2, and then we will extend the calculator to support subtraction.</p>"},{"location":"ece2300-lab4ef-proc/#31-simulate-simple-tinyrv1-program","title":"3.1. Simulate Simple TinyRV1 Program","text":"<p>We will be using the same simulators we used in the Lab 4D to emulate what will happen when your processor is configured on the FPGA. Recall that these simulators and the actual FPGA will use the following connections:</p> <ul> <li><code>in0[4:0]</code> is connected to first five switches</li> <li><code>in1[4:0]</code> is connected to second five switches</li> <li><code>in2[3:0]</code> is connected to the four push-buttons</li> <li><code>out0[4:0]</code> is connected to the two seven-segment displays</li> <li><code>out1[4:0]</code> is connected to the two seven-segment displays</li> <li><code>out2[4:0]</code> is connected to the two seven-segment displays</li> </ul> <p>Recall that we provided you a very simple TinyRV1 program in the <code>sim/proc-sim-prog1.v</code> file. Take a look at this file on <code>ecelinux</code> using VS Code.</p> <pre><code>task proc_sim_prog1();\n\n  asm( 'h000, \"addi x1, x0, 2\"   );\n  asm( 'h004, \"addi x2, x1, 2\"   );\n  asm( 'h008, \"csrw out0, x2\"    );\n  asm( 'h00c, \"jal  x0, 0x00c\"   );\n\nendtask\n</code></pre> <p>Go ahead and run this program on the FL processor simulator on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=1\n</code></pre> <p>Confirm that the behavior is as expected. Now run the program on the single-cycle processor simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=1\n</code></pre>"},{"location":"ece2300-lab4ef-proc/#32-implement-two-function-calculator-tinyrv1-program","title":"3.2. Implement Two-Function Calculator TinyRV1 Program","text":"<p>We want our two-function calculator TinyRV1 program to exactly emulate the behavior of the specialized two-function calculator we implemented in Lab 2. The two-function calculator should take two inputs: a five-bit value specified with the first five switches and a five-bit value specified with the second five switches. The calculator should then display these two input values on the seven-segment displays. The calculator should perform addition if the push button is not pressed and should perform multiplication if the push button is pressed. The calculator should output the result on the final seven-segment displays. The pseudo-code for our two-function calculator is shown below.</p> <pre><code>while True:\n\n  # read switches and buttons\n\n  in0     = read_in0()\n  in1     = read_in1()\n  buttons = read_in2()\n\n  # display inputs\n\n  write_out0(in0)\n  write_out1(in1)\n\n  # addition\n\n  if buttons == 0b0000:\n    result = in0 + in1\n\n  # multiply\n\n  else:\n    result = in0 * in1\n\n  # display result\n\n  write_out2( result )\n</code></pre> <p>Implement the two-function calculator in assembly in the <code>sim/proc-sim-prog2.v</code> file. We recommend taking an incremental design approach. Start by implementing a calculator that only performs addition. Once this is working, think critically about how to implement an if/else conditional operator in assembly and then add support for multiplication. Note how the calculator is in an infinite loop. This way your calculator will continuously read the inputs and write the outputs. You can implement this with a final JAL instruction which jumps back to the first instruction in the assembly program.</p> <p>In general, we suggest writing out all of the assembly instructions but leave the actual instruction address values until the end. Use <code>???</code> as place holders for the branch and jump target addresses. Once you have all of the assembly instructions finished, then go through and update the address for each assembly instruction. The final step would be to go back and update the branch and jump target addresses.</p> <p>Always simulate your assembly program on the FL processor simulator first as follows:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-fl-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n</code></pre> <p>You can single-step through each assembly instruction one at a time using the <code>+step</code> command line option. Press enter to execute the next instruction, enter <code>r</code> and then press enter to finish the program, and enter <code>q</code> and then press enter to quit.</p> <p>Once you know your assembly program is working on the FL processor simulator, then try it on the single-cycle processor simulator like this.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n</code></pre> <p>Ideally, an effective testing strategy will ensure that your single-cycle processor is fully correct by the time we start using these interactive simulators. However, if the behavior is not as expected then you will have no choice but to try and debug what has gone wrong. You will need to use waveforms to carefully examine each cycle. You can dump waveforms using the <code>+dump-vcd=waves.vcd</code> command line option. You should probably use what you learn to add more directed tests cases.</p> <p>Lab Check-Off Task 3: Simulate Two-Function Calculator Program</p> <p>Show a TA your two-function calculator program running on (1) the FL processor simulator; and (2) the single-cycle processor simulator. The TA will ask you to try some different input data. Here are the steps you need to show the TA.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% make proc-scycle-sim\n\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n</code></pre>"},{"location":"ece2300-lab4ef-proc/#33-implement-three-function-calculator-tinyrv1-program","title":"3.3. Implement Three-Function Calculator TinyRV1 Program","text":"<p>The two-function calculator program running on the single-cycle TinyRV1 processor requires significantly more area and has a much longer execution time compared to the specialized two-function calculator implemented in Lab 2. The real power of a general-purpose processor is the ability to easily program new capabilities without adding any hardware. Modify your two-function calculator program to add support for subtraction. If the user does not press any push buttons the calculator should perform addition. If the user presses the first push button the calculator should perform multiplication. If the user presses the second push button the calculator should perform subtraction. Note that the TinyRV1 instruction set does not include a subtract instruction, so you will need to implement subtraction using just the available arithmetic instructions. Make sure your program works on the FL processor simulator and then verify it works on the single-cycle processor simulator.</p> <p>We also need to take an extra step to choose this program to actually run on the processor once it has been configured to the FPGA. The program which will run on the processor once it has been configured to the FPGA is located in the <code>hw/ProcMem.v</code> module. Go ahead and take a look at this file on <code>ecelinux</code> using VS Code. You will see a region of the module that looks like this although it might look different based on your work in Lab 4D.</p> <pre><code>   if ( rst ) begin\n      mem[   0] &lt;= 32'h00200093; // 00000000 addi x1, x0, 2\n      mem[   1] &lt;= 32'h00208113; // 00000004 addi x2, x1, 2\n      mem[   2] &lt;= 32'h7c211073; // 00000008 csrw out0, x2\n      mem[   3] &lt;= 32'h0000006f; // 0000000c jal  x0, 0x00c\n    end\n</code></pre> <p>This is where we ensure the memory has the desired program when the FPGA is reset. Writing this by hand would be tedious, so our simulators provide the <code>+dump-bin</code> command line option which will dump out what you need to copy into <code>hw/ProcMem.v</code>. For example,</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=2 +dump-bin\n</code></pre> <p>So once you have verified one of your assembly programs works, use <code>+dump-bin</code> and then copy-and-paste the resulting lines into <code>hw/ProcMem.v</code>. You can use program number 0 to verify that the program currently stored in <code>hw/ProcMem.v</code> works as expected:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n</code></pre> <p>Lab Report Task 1: Three-Function Calculator Assembly Program</p> <p>Save your three-function calculator assembly program so you can include it in your lab report. All assembly code should be formatted using a fixed-width font.</p> <p>Lab Check-Off Task 4: Simulate Three-Function Calculator Program</p> <p>Show a TA your thre-function calculator program running on (1) the FL processor simulator; (2) the single-cycle processor simulator; and (3) the single-cycle processor simulator with the <code>ProcMem</code>. Here are the steps you need to show the TA.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% make proc-scycle-sim\n\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n% ./proc-fl-sim     +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0010\n\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n% ./proc-scycle-sim +prog-num=2 +in0-switches=00011 +in1-switches=00010 +buttons=0010\n\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00011 +in1-switches=00010 +buttons=0001\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00011 +in1-switches=00010 +buttons=0010\n</code></pre>"},{"location":"ece2300-lab4ef-proc/#34-synthesize-analyze-and-configure-single-cycle-tinyrv1-processor","title":"3.4. Synthesize, Analyze, and Configure Single-Cycle TinyRV1 Processor","text":"<p>Now that we know our single-cycle processor can successfully execute the three-function calculator assembly program in simulation, we want to see if we can verify the same program running on the processor FPGA prototype. As in previous labs, the New Project Wizard creates a top-level Verilog module for us which has ports for all of the switches, LEDs, seven-segment displays, and pins on the FPGA development board. Here is the code you can use for your top-level design.</p> <pre><code>  logic clk;\n\n  ClockDiv_RTL clock_div\n  (\n    .clk_in  (CLOCK_50),\n    .clk_out (clk)\n  );\n\n  logic rst0;\n  logic rst;\n  always @(posedge clk) begin\n    rst0 &lt;= ~RESET_N;\n    rst  &lt;= rst0;\n  end\n\n  logic        imemreq_val;\n  logic [31:0] imemreq_addr;\n  logic [31:0] imemresp_data;\n\n  logic        dmemreq_val;\n  logic        dmemreq_type;\n  logic [31:0] dmemreq_addr;\n  logic [31:0] dmemreq_wdata;\n  logic [31:0] dmemresp_rdata;\n\n  logic [31:0] proc_out0;\n  logic [31:0] proc_out1;\n  logic [31:0] proc_out2;\n\n  logic        proc_trace_val_unused;\n  logic [31:0] proc_trace_addr_unused;\n  logic [31:0] proc_trace_data_unused;\n\n  ProcScycle proc\n  (\n    .clk             (clk),\n    .rst             (rst),\n\n    .imemreq_val     (imemreq_val),\n    .imemreq_addr    (imemreq_addr),\n    .imemresp_data   (imemresp_data),\n\n    .dmemreq_val     (dmemreq_val),\n    .dmemreq_type    (dmemreq_type),\n    .dmemreq_addr    (dmemreq_addr),\n    .dmemreq_wdata   (dmemreq_wdata),\n    .dmemresp_rdata  (dmemresp_rdata),\n\n    .in0             ({27'b0,SW[9:5]}),\n    .in1             ({27'b0,SW[4:0]}),\n    .in2             ({31'b0,~KEY[3:0]}),\n\n    .out0            (proc_out0),\n    .out1            (proc_out1),\n    .out2            (proc_out2),\n\n    .trace_val       (proc_trace_val_unused),\n    .trace_addr      (proc_trace_addr_unused),\n    .trace_data      (proc_trace_data_unused)\n  );\n\n  ProcMem mem\n  (\n    .clk             (clk),\n    .rst             (rst),\n\n    .imemreq_val     (imemreq_val),\n    .imemreq_addr    (imemreq_addr),\n    .imemresp_data   (imemresp_data),\n\n    .dmemreq_val     (dmemreq_val),\n    .dmemreq_type    (dmemreq_type),\n    .dmemreq_addr    (dmemreq_addr),\n    .dmemreq_wdata   (dmemreq_wdata),\n    .dmemresp_rdata  (dmemresp_rdata)\n  );\n\n  // Out Displays\n\n  Display_GL proc_out0_display\n  (\n    .in       (proc_out0[4:0]),\n    .seg_tens (HEX5),\n    .seg_ones (HEX4)\n  );\n\n  Display_GL proc_out1_display\n  (\n    .in       (proc_out1[4:0]),\n    .seg_tens (HEX3),\n    .seg_ones (HEX2)\n  );\n\n  Display_GL proc_out2_display\n  (\n    .in       (proc_out2[4:0]),\n    .seg_tens (HEX1),\n    .seg_ones (HEX0)\n  );\n</code></pre> <p>Spend a few minutes making sure you understand this top-level composition. Our timing analysis in Lab 4D showed that the single-cycle processor cannot meet timing with a 50MHz clock (i.e., clock constraint of 20ns). So we are using a clock divider which divides the 50MHz clock by four to produce a 12.5MHz clock (i.e., clock constraint of 80ns). We are now using a reset synchronizer which should help address some of the flakiness that students were seeing Lab 4D. Prof. Batten will talk more about reset synchronizers in lecture, but you can also read about synchronizers in Sections 3.5.4 and 3.5.5 of Harris and Harris.</p> <p>Once you are happy with your understanding, you just need to copy this code into the DE0_CV_golden_top.v. As in previous labs, we need to create a timing constraint file. Here are the steps to create an initial timing constraint file:</p> <ul> <li>Choose File &gt; New from the menu</li> <li>Click Synopsys Design Constraints File</li> <li>Click OK</li> <li>Enter the constraints shown below</li> <li>Click File &gt; Save from the menu</li> <li>Name the file timing.sdc</li> <li>Save the file in the lab4 directory</li> </ul> <p>We will use the following initial constraints:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -period 20 [get_ports {CLOCK_50}]\ncreate_clock -name clk -period 80 [get_nets {ClockDiv_RTL:clock_div|count[1]}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>These constraints tell the FPGA tools that:</p> <ul> <li>Our critical path delay constraint is <code>80ns</code> from all inputs to all    outputs</li> <li>We have a clock signal named <code>clk</code><ul> <li>There should be no setup time violations with respect to   <code>clk</code> when the period is <code>80ns</code></li> <li>There should be no hold time violations with respect to <code>clk</code></li> </ul> </li> <li>The output ports have a setup time of 0 (max constraint) and a hold    time of 0 (min constraint)</li> <li>The input ports have clock-to-port propagation delay of 0 (max    constraint) and a clock-to-port contamination delay of 0 (min    constraint)</li> </ul> <p>Make sure to copy-and-paste the three-function calculator program into <code>hw/ProcMem.v</code> within Quartus. Choose Processing &gt; Start Compilation from the menu to synthesize your design. You will need to wait 5-10 minutes for synthesis to complete. Be patient! Students should continue on and start developing their accumulate program on <code>ecelinux</code> while waiting for synthesis to complete.</p> <p>Once synthesis is done, double check that your design does not have any inferred latches! The compilation will emit warnings not errors regarding inferred latches, but you must remove all inferred latches. These warnings are confusingly in green text. Check out this Ed post for some more information on how to fix common issues, including inferred latches, we saw in Lab 4D.</p> <p>Now we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>You probably need to press the reset buttons on the FPGA board to start the execution of the assembly program. Confirm that the seven-segment displays show the exact same output as the simulation.</p> <p>Lab Check-Off Task 5: Demonstrate TinyRV1 Processor Running Three-Function Calculator Program</p> <p>First, show the TA the same simulation you did earlier on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00011 +in1-switches=00010 +buttons=0000\n</code></pre> <p>Then press the reset buttons the FPGA board to show the TA that your FPGA prototype produces the expected output. The TA will ask you to perform different functions on different input data and to compare the output between your simulator and the FPGA prototype. Qualitatively discuss the advantages and disadvantages of your software calculator running on the single-cycle processor compared to the specialized hardware calculator you implemented in Lab 2.</p>"},{"location":"ece2300-lab4ef-proc/#4-accumulate-tinyrv1-program","title":"4. Accumulate TinyRV1 Program","text":"<p>In this part, we will implement a TinyRV1 assembly program that accumulates values stored in an array.</p>"},{"location":"ece2300-lab4ef-proc/#41-implement-accumulate-tinyrv1-program","title":"4.1. Implement Accumulate TinyRV1 Program","text":"<p>Our program should wait for a buttons press and then read the number of elements to accumulate from the first five switches. The program should output the size to the seven-segment displays and output the bottom five bits of the final result to the seven-segment displays. The pseudo-code for our accumulate program is shown below.</p> <pre><code>  # set out1 to zero\n\n  write_out1(0)\n\n  # wait for go\n\nwait:\n  size    = read_in0()\n  buttons = read_in2()\n  if buttons != 1:\n    goto wait\n\n  # display size\n\n  write_out0(size)\n\n  # calc\n\n  sum = 0\n  for i in range(size):\n    sum = sum + a[i]\n\n  # done\n\n  write_out1(sum)\n\n  while True:\n    pass\n</code></pre> <p>Implement the accumulate program in assembly in the <code>sim/proc-sim-prog3.v</code> file. Use the following template which takes care of the wait loop, writing the result, and initializing the input data as an array starting at address 0x080 with 32 elements. The comment next to each element in the array specifies the value of the bottom five bits of the result (i.e., what the seven-segment display should show for a correct execution).</p> <pre><code>task proc_sim_prog3();\n\n  // set out1 to zero\n\n  asm( 'h000, \"csrw out1, x0\"      );\n\n  // wait for go\n\n  asm( 'h004, \"csrr x1, in0\"       );\n  asm( 'h008, \"csrr x2, in2\"       );\n  asm( 'h00c, \"addi x3, x0, 1\"     );\n  asm( 'h010, \"bne  x2, x3, 0x004\" );\n\n  // display size\n\n  asm( 'h014, \"csrw out0, x1\" );\n\n  // fill in the accumulate loop here\n\n  // done (assumes result is in x4)\n\n  asm( ?????, \"csrw out1, x4\"      ); // set address appropriately\n  asm( ?????, \"jal  x0, ?????\"     ); // set address appropriately\n\n  // Input array\n\n                     //  size result seven_seg\n  data( 'h080, 36 ); //     1     36  4\n  data( 'h084, 26 ); //     2     62 30\n  data( 'h088, 69 ); //     3    131  3\n  data( 'h08c, 57 ); //     4    188 28\n  data( 'h090, 11 ); //     5    199  7\n  data( 'h094, 68 ); //     6    267 11\n  data( 'h098, 41 ); //     7    308 20\n  data( 'h09c, 90 ); //     8    398 14\n  data( 'h0a0, 32 ); //     9    430 14\n  data( 'h0a4, 76 ); //    10    506 26\n  data( 'h0a8, 44 ); //    11    550  6\n  data( 'h0ac, 19 ); //    12    569 25\n  data( 'h0b0, 17 ); //    13    586 10\n  data( 'h0b4, 59 ); //    14    645  5\n  data( 'h0b8, 99 ); //    15    744  8\n  data( 'h0bc, 49 ); //    16    793 25\n  data( 'h0c0, 65 ); //    17    858 26\n  data( 'h0c4, 12 ); //    18    870  6\n  data( 'h0c8, 55 ); //    19    925 29\n  data( 'h0cc,  0 ); //    20    925 29\n  data( 'h0d0, 51 ); //    21    976 16\n  data( 'h0d4, 42 ); //    22   1018 26\n  data( 'h0d8, 82 ); //    23   1100 12\n  data( 'h0dc, 23 ); //    24   1123  3\n  data( 'h0e0, 21 ); //    25   1144 24\n  data( 'h0e4, 54 ); //    26   1198 14\n  data( 'h0e8, 83 ); //    27   1281  1\n  data( 'h0ec, 31 ); //    28   1312  0\n  data( 'h0f0, 16 ); //    29   1328 16\n  data( 'h0f4, 76 ); //    30   1404 28\n  data( 'h0f8, 21 ); //    31   1425 17\n  data( 'h0fc,  4 ); //    32   1429 21\n\nendtask\n</code></pre> <p>We recommend taking an incremental design approach. Start by ignoring the wait loop. Simply write a loop to accumulate the first four elements in the array, output the result to the seven-segment displays, and end with an infinite loop. Use the <code>+step</code> command line option to ensure the processor is executing the instructions as you expect. Once this is working, add support for the initial wait loop. Use the <code>+buttons=00000</code> and <code>+step</code> command line option to ensure the processor is executing the instructions as you expect when it is waiting for a button to be pushed.</p> <p>In general, we suggest writing out all of the assembly instructions but leave the actual instruction address values until the end. Use <code>???</code> as place holders for the branch and jump target addresses. Once you have all of the assembly instructions finished, then go through and update the address for each assembly instruction. The final step would be to go back and update the branch and jump target addresses.</p> <p>Always simulate your assembly program on the FL processor simulator first as follows:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% ./proc-fl-sim +prog-num=3 +in0-switches=00100 +buttons=0000\n% ./proc-fl-sim +prog-num=3 +in0-switches=00100 +buttons=0001\n</code></pre> <p>From the comment above, the result when accumulating the first four elements should be 188 and the seven-segment display should shown 28. Once you know your assembly program is working on the FL processor simulator, then try it on the single-cycle processor simulator like this.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=3 +in0-switches=00100 +buttons=0000\n% ./proc-scycle-sim +prog-num=3 +in0-switches=00100 +buttons=0001\n</code></pre> <p>Once you have verified your assembly program works, use <code>+dump-bin</code> and then copy-and-paste the resulting lines into <code>hw/ProcMem.v</code>. You can use program number 0 to verify that the program currently stored in <code>hw/ProcMem.v</code> works as expected:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00100 +buttons=0000\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00100 +buttons=0001\n</code></pre> <p>Let's run a full experiment to accumulate 31 elements.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=11111 +buttons=0001\n</code></pre> <p>The correct result is 1425 and the seven-segment display should show 17. The simulator will print out the <code>cycle_count</code>. This is the number of cycles it takes to execute the accumulate program. You will be working to fill in this data table:</p> <ul> <li>https://docs.google.com/spreadsheets/d/1u30pax9gSaYgxfGzijZ16sxKd5bPucyl2BFsVvLCns4</li> </ul> <p>Make a copy of this table, and enter in the cycle count for your single-cycle processor into the fpga-perf-data tab. The cycle count starts from the beginning of the program and stops once out1 is no longer zero.</p> <p>Lab Report Task 2: Accumulate Assembly Program and Cycle Count</p> <p>Save your accumulate assembly program so you can include it in your lab report. All assembly code should be formatted using a fixed-width font. Make sure to save your completed data table with the cycle count number for accumulating 31 elements.</p> <p>Lab Check-Off Task 6: Simulate Accumulate Program</p> <p>Show a TA your accumulate program running on (1) the FL processor simulator; (2) the single-cycle processor simulator; and (3) the single-cycle processor simulator with the <code>ProcMem</code>. The TA will ask you why the cycle count is reasonable if the given size if 4. The TA will ask you to try a different size. Here are the steps you need to show the TA.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-fl-sim\n% make proc-scycle-sim\n\n% ./proc-fl-sim     +prog-num=3 +in0-switches=00100 +buttons=0000\n% ./proc-fl-sim     +prog-num=3 +in0-switches=00100 +buttons=0001\n\n% ./proc-scycle-sim +prog-num=3 +in0-switches=00100 +buttons=0000\n% ./proc-scycle-sim +prog-num=3 +in0-switches=00100 +buttons=0001\n\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00100 +buttons=0000\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00100 +buttons=0001\n</code></pre>"},{"location":"ece2300-lab4ef-proc/#42-synthesize-and-analyze-single-cycle-tinyrv1-processor","title":"4.2. Synthesize and Analyze Single-Cycle TinyRV1 Processor","text":"<p>Now that we know our single-cycle processor can successfully execute the accumulate assembly program in simulation, we want to see if we can verify the same program running on the processor FPGA prototype. Copy-and-paste the accumulate program into <code>hw/ProcMem.v</code> within Quartus. Choose Processing &gt; Start Compilation from the menu to synthesize your design. You will need to wait 5-10 minutes for synthesis to complete. Be patient! Students should continue on and start experimenting with the accumulate accelerator interactive simulator on <code>ecelinux</code> while waiting for synthesis to complete.</p> <ul> <li>RTL Viewer<ul> <li>Choose Tools &gt; Netlist Viewer &gt; RTL Viewer from the menu</li> <li>Use the Netlist Navigator to gradually drill down in the hierarchy as follows:</li> <li>ProcScycle</li> <li>ProcScycleDpath</li> <li>ALU_GL</li> <li>Adder_32b_GL</li> <li>AdderCarrySelect_8b_GL</li> <li>AdderRippleCarry_4b_GL</li> <li>FullAdder_GL</li> <li>Appreciate how far we have come this semester!</li> <li>Choose File &gt; Close from menu to close the RTL viewer</li> </ul> </li> <li>Chip Planner<ul> <li>Choose Tools &gt; Chip Planner from the menu</li> <li>Identify where the logic used to implement your design is located    in the FPGA</li> <li>Choose File &gt; Close from the menu to close the chip planner</li> </ul> </li> </ul> <p>The next step is to analyze the area of your design.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu</li> <li>Under Table of Contents choose Fitter &gt; Resource Section &gt; Resource    Usage Summary</li> <li>Look through the report to determine the number of combinational ALUTs    (configurable look-up tables) that are used for your design</li> <li>Look through the report to determine the number of dedicated logic    registers that are used for your design</li> </ul> <p>Add the area data to the data table. You can find the number of 7-input ALUTs, 6-input ALUTs, etc in the area report. You can find the dedicated logic registers also in the area report.</p> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>Clocks - From clock: clk</li> <li>Clocks - To clock: clk</li> <li>Targets - From: [get_registers *]</li> <li>Targets - To: [get_registers *]</li> <li>Report number of paths: 1</li> <li>Check next to File name and enter proc-critical-path.txt</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the \"slack\" and the \"data delay\" of the displayed path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one register to another register</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Lab Report Task 3: Collect Data for Single-Cycle Processor</p> <p>Save your completed data table with your analysis of your single-cycle processor and include it in your lab report. Take a screenshot of the entire RTL viewer window; it must clearly show the Netlist Navigator with the full hierarchy from the top to the full adder on the left and the gate-level implementation of the full adder on the right. Save a screenshot of the chip planner clearly showing where the logic used to implement your design is located on the FPGA. Save the critical path report and use it to highlight the critical path on the processor datapath diagram; annotate the delays of the various components along the critical path. Remember, if you select multiple cells in the Incr column of the timing report and hover your mouse it will display a pop-up showing the sum of the delays along that portion of the path.</p> <p>Lab Check-Off Task 7: Discuss Single-Cycle Processor</p> <p>Show a TA your completed data table with the area and performance results. Show a TA the screenshot of the full adder and explain how the full adder fits into the complete single-cycle processor. Show a TA the single-cycle processor datapath with the highlighted critical path and annotated delays. Is the critical path as expected?</p>"},{"location":"ece2300-lab4ef-proc/#44-configure-single-cycle-tinyrv1-processor-prototype","title":"4.4. Configure Single-Cycle TinyRV1 Processor Prototype","text":"<p>Now we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>You probably need to press the reset button on the FPGA board to start the execution of the assembly program. Confirm that the seven-segment displays show the exact same output as the simulation. Don't forget to actually press the push button to start the kernel!</p> <p>Lab Check-Off Task 8: Demonstrate TinyRV1 Processor Running Accumulate Program</p> <p>First, show the TA the same simulation you did earlier on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make proc-scycle-sim\n% ./proc-scycle-sim +prog-num=0 +in0-switches=00100 +buttons=0001\n</code></pre> <p>Then press the reset button the FPGA board to show the TA that your FPGA prototype produces the expected output. The TA will ask you to try a different size and to compare the output between your simulator and the FPGA prototype.</p>"},{"location":"ece2300-lab4ef-proc/#5-accumulate-accelerator","title":"5. Accumulate Accelerator","text":"<p>In this part, we will simulate, synthesize, analyze, and configure your accumulate accelerator. The accelerator is specialized so it should have lower area and higher performance compared to the general-purpose processor; but of course since it is specialized it can only do one thing!</p>"},{"location":"ece2300-lab4ef-proc/#51-simulate-accumulate-accelerator","title":"5.1. Simulate Accumulate Accelerator","text":"<p>We provide you an interactive accumulate accelerator simulator which emulates the eventual FPGA prototype. You can run the interactive simulator as follows:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make accum-xcel-sim\n% ./accum-xcel-sim +in0-switches=00100 +buttons=0000\n% ./accum-xcel-sim +in0-switches=00100 +buttons=0001\n</code></pre> <p>The accumulate accelerator is setup to use the exact same data as the accumulate assembly program so it should display the same values for a given size. As with the accumulate assembly program, the result when accumulating the first four elements should be 188 and the seven-segment display should shown 28.</p> <p>Let's run a full experiment to accumulate 31 elements.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make accum-xcel-sim\n% ./accum-xcel-sim +in0-switches=11111 +buttons=0001\n</code></pre> <p>The correct result is 1425 and the seven-segment display should show 17. The simulator will print out the <code>cycle_count</code>. This is the number of cycles it takes for the accumulate accelerator to finish. Add this cycle count to the data table.</p> <p>Lab Report Task 4: Accumulate Accelerator and Cycle Count</p> <p>Make sure to save your completed data table with the cycle count number for accumulating 31 elements. You will also need to include a datapath diagram and a FSM diagram of your accumulate accelerator in your lab report.</p> <p>Lab Check-Off Task 9: Simulate Accumulate Accelerator</p> <p>Start by showing a TA the datapath and FSM diagram for your accumulate accelerator. Clearly explain how your accumulate accelerator works by describing the interaction between the datapath and control unit. Then show a TA your accumulate accelerator working in simulation. The TA will ask you why the cycle count is reasonable if the given size is 4. Here are the steps you need to show the TA.</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make accum-xcel-sim\n% ./accum-xcel-sim +in0-switches=00100 +buttons=0000\n% ./accum-xcel-sim +in0-switches=00100 +buttons=0001\n</code></pre>"},{"location":"ece2300-lab4ef-proc/#52-synthesize-and-analyze-accumulator-accelerator","title":"5.2. Synthesize and Analyze Accumulator Accelerator","text":"<p>Now that we know our accumulate accelerator is fully functional, we can synthesize and analyze the accumulate accelerator using the FPGA tools. Here is the code you can use for your top-level design.</p> <pre><code>  // replace this with the clock divider if you do not meet timing\n  logic clk;\n  assign clk = CLOCK_50;\n\n  logic rst0;\n  logic rst;\n  always @(posedge clk) begin\n    rst0 &lt;= ~RESET_N;\n    rst  &lt;= rst0;\n  end\n\n  logic        xcel_go;\n  logic [13:0] xcel_size;\n  logic        xcel_result_val;\n  logic [31:0] xcel_result;\n\n  logic        memreq_val;\n  logic [15:0] memreq_addr;\n  logic [31:0] memresp_data;\n\n  assign xcel_go = ~KEY[0];\n  assign xcel_size = SW[9:5];\n\n  AccumXcel xcel\n  (\n    .clk          (clk),\n    .rst          (rst),\n    .go           (xcel_go),\n    .size         (xcel_size),\n    .result_val   (xcel_result_val),\n    .result       (xcel_result),\n    .memreq_val   (memreq_val),\n    .memreq_addr  (memreq_addr),\n    .memresp_data (memresp_data)\n  );\n\n  AccumXcelMem mem\n  (\n    .clk          (clk),\n    .rst          (rst),\n    .memreq_val   (memreq_val),\n    .memreq_addr  (memreq_addr),\n    .memresp_data (memresp_data)\n  );\n\n  // Size Display\n\n  Display_GL xcel_size_display\n  (\n    .in       (xcel_size[4:0]),\n    .seg_tens (HEX5),\n    .seg_ones (HEX4)\n  );\n\n  // Result Display\n\n  Display_GL xcel_result_display\n  (\n    .in       (xcel_result[4:0]),\n    .seg_tens (HEX3),\n    .seg_ones (HEX2)\n  );\n\n  assign LEDR[0] = xcel_result_val;\n</code></pre> <p>Spend a few minutes making sure you understand this top-level composition. Notice we are not using a clock divider since we should be able to meet timing using a 50MHz clock. We are again using a reset synchronizer which should help address some of the flakiness that students were seeing Lab 4D. We have connected the <code>xcel_result_val</code> signal to one of the LEDs.</p> <p>Once you are happy with your understanding, you just need to copy this code into the DE0_CV_golden_top.v. We also need to update our constraints to be as follows:</p> <pre><code>set_max_delay -from [all_inputs] -to [all_outputs] 20\nset_min_delay -from [all_inputs] -to [all_outputs] 0\n\ncreate_clock -name clk -period 20 [get_ports {CLOCK_50}]\n\nset_output_delay -add_delay -clock clk -max 0 [all_outputs]\nset_output_delay -add_delay -clock clk -min 0 [all_outputs]\n\nset_input_delay -add_delay -clock clk -max 0 [all_inputs]\nset_input_delay -add_delay -clock clk -min 0 [all_inputs]\n</code></pre> <p>This is similar to the processor except without the clock divider. Choose Processing &gt; Start Compilation from the menu to synthesize your design. You will need to wait 2-3 minutes for synthesis to complete. Be patient!</p> <p>If your design does not meet timing then you have two options: (1) you can change your design to try and reduce the critical path; or (2) you can increase the clock constraint (i.e., your accelerator will run at a lower clock frequency). For this lab let's go with option (2). You can instantiate a clock divider at the top-level just like you did for the processor earlier in the lab. The clock divider will increase the clock constraint to 80ns (i.e., the target clock frequency will be 12.5MHz instead of 50MHz). After instantiating the clock divider make sure you also change the timing constraints to be the same as what you used with the processor. Then try synthesizing your design again.</p> <p>Once synthesis is done, double check that your design does not have any inferred latches! The compilation will emit warnings not errors regarding inferred latches, but you must remove all inferred latches. These warnings are confusingly in green text. Check out this Ed post for some more information on how to fix common issues, including inferred latches, we saw in Lab 4D.</p> <p>The next step is to analyze the area of your design.</p> <ul> <li>Choose Processing -&gt; Compilation Report from the menu</li> <li>Under Table of Contents choose Fitter &gt; Resource Section &gt; Resource    Usage Summary</li> <li>Look through the report to determine the number of combinational ALUTs    (configurable look-up tables) that are used for your design</li> <li>Look through the report to determine the number of dedicated logic    registers that are used for your design</li> </ul> <p>Add the area data to the data table. You can find the number of 7-input ALUTs, 6-input ALUTs, etc in the area report. You can find the dedicated logic registers also in the area report.</p> <p>The final step is to analyze the timing (i.e., the critical path delay) of your design. We will analyze timing for the Slow 1100mV 85C Model which is the default choice in the Timing Analyzer.</p> <ul> <li>Choose Tools &gt; Timing Analyzer from the menu</li> <li>Double-click Update Timing Netlist</li> <li>Choose Reports &gt; Custom Reports &gt; Report Timing from the menu</li> <li>Report Timing<ul> <li>Clocks - From clock: clk</li> <li>Clocks - To clock: clk</li> <li>Targets - From: [get_registers *]</li> <li>Targets - To: [get_registers *]</li> <li>Report number of paths: 1</li> <li>Check next to File name and enter xcel-critical-path.txt</li> <li>Click Report Timing</li> </ul> </li> <li>Identify the \"slack\" and the \"data delay\" of the displayed path</li> <li>Look at the actual critical path (i.e., Data Arrival Path) which     shows the longest path from one register to another register</li> <li>Choose File &gt; Close from the menu to close the timing analyzer</li> </ul> <p>Lab Report Task 5: Collect Data for Accumulate Accelerator</p> <p>Save your completed data table with your analysis of your single-cycle processor and include it in your lab report. Save the critical path report and use it to highlight the critical path on the accumulate accelerator datapath diagram; annotate the delays of the various components along the critical path. Remember, if you select multiple cells in the Incr column of the timing report and hover your mouse it will display a pop-up showing the sum of the delays along that portion of the path.</p> <p>Lab Check-Off Task 10: Discuss Accumulate Accelerator</p> <p>Show a TA your completed data table with the area and performance results. Show a TA your accumulate accelerator datapath with the highlighted critical path and annotated delays. Is the critical path as expected? Discuss the trade-off between more general-purpose hardware (e.g., our TinyRV1 processor) and more specialized hardware (e.g., our accumulate accelerator).</p>"},{"location":"ece2300-lab4ef-proc/#53-configure-accumulator-accelerator-prototype","title":"5.3. Configure Accumulator Accelerator Prototype","text":"<p>Now we can configure the FPGA:</p> <ul> <li>Choose Tools &gt; Programmer from the menu</li> <li>Click Hardware Setup</li> <li>Currently selected hardware: USB-Blaster [USB-0]</li> <li>Click Close</li> <li>Click Start</li> </ul> <p>You might need to press the reset button on the FPGA board. Confirm that the seven-segment displays show the exact same output as the simulation. Don't forget to actually press the push button to start the accelerator!</p> <p>Lab Check-Off Task 11: Demonstrate Accumulate Accelerator</p> <p>First, show the TA the same simulation you did earlier on <code>ecelinux</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/groupXX/lab4-proc/build\n% make accum-xcel-sim\n% ./accum-xcel-sim +in0-switches=00100 +buttons=0001\n</code></pre> <p>Then press the reset button the FPGA board to show the TA that your FPGA prototype produces the expected output. The TA will ask you to try a different size and to compare the output between your simulator and the FPGA prototype.</p> <p>Lab Check-Off Task 12: Turn In FPGA Board</p> <p>When you are finished with your demo, pack up your FPGA development board. Neatly put the board, power cable, and USB cable back in the box. Return the box to a TA who will then record the board number on your check-off sheet, initial the final check-off, and then collect your check-off sheet.</p>"},{"location":"ece2300-lab4ef-proc/#6-lab-report-submission","title":"6. Lab Report Submission","text":"<p>Students should work with their partner to prepare a short lab report that conveys what they have learned in this lab assignment. The lab report should start with no more than two pages of text. Students should include all figures, tables, and diagrams after these two pages in an appendix. The appendix can be as many pages as necessary. Do not interleave the text, figures, tables, and diagrams. There should be two pages of text and then the appendix with all of the text, figures, tables, and diagrams.</p> <p>There are no restrictions on font size, margins, or line spacing, but please make sure your report is readable. We recommend using 10pt Times or 10pt Palintino with 0.75in to 1in margins. Please make sure you include a title, your names, and your NetIDs at the top of the first page. Do not include a title page.</p> <p>The lab report must include the following numbered sections. Please number your sections and use these specific titles. Please follow the guidelines on the number of paragraphs, the content of each paragraph, and which figures/tables to include. Some paragraphs might just be 2-3 sentences.</p>"},{"location":"ece2300-lab4ef-proc/#section-1-introduction-one-paragraph","title":"Section 1. Introduction (one paragraph)","text":"<ul> <li>Include 2-3 sentences explaining what the lab involves</li> <li>Include one sentence explaining the purpose of this lab (why are     students doing this lab?)</li> <li>Include one sentence explicitly connecting the lab to one or more     lecture topics; be specific on which lecture topics this lab     reinforces with experiential learning</li> </ul>"},{"location":"ece2300-lab4ef-proc/#section-2-single-cycle-tinyrv1-processor-two-paragraphs","title":"Section 2. Single-Cycle TinyRV1 Processor (two paragraphs)","text":"<ul> <li> <p>Paragraph 1: Accumulate Assembly Program</p> <ul> <li>Include a sentence referencing your accumulate assembly program    listing in the appendix</li> <li>Include 2-3 sentences clearly describing how the accumulate    assembly program works</li> </ul> </li> <li> <p>Paragraph 2: Single-Cycle TinyRV1 Processor FPGA Implementation</p> <ul> <li>Include a sentence referencing the data tables in the appendix</li> <li>Include a sentence discussing the area of the processor</li> <li>Include 2-3 sentences referencing your annotated processor datapath    diagram in the appendix, clearly describing where the critical    path is in your processor, and discussing if this is the expected    path</li> <li>Include a sentence discussing the number of cycles required for the    processor to accumulate 31 elements; clearly justify this cycle    count</li> <li>Include a sentence discussing the total execution time in    nanoseconds required for the processor to accumulate 31 elements</li> </ul> </li> </ul>"},{"location":"ece2300-lab4ef-proc/#section-3-accumulate-accelerator-two-paragraphs","title":"Section 3. Accumulate Accelerator (two paragraphs)","text":"<ul> <li> <p>Paragraph 1: Accumulate Accelerator Design</p> <ul> <li>Include a sentence referencing your datapath and FSM diagram</li> <li>Include several sentences that clearly explain how your accumulate   accelerator works by describing the interaction between the   datapath and control unit; be sure to clearly explain how the   accelerator starts and stops</li> </ul> </li> <li> <p>Paragraph 2: Accumulate Accelerator FPGA implementation</p> <ul> <li>Include a sentence referencing the data tables in the appendix</li> <li>Include a sentence discussing the area of the accelerator</li> <li>Include 2-3 sentences referencing your annotated accelerator    datapath diagram in the appendix, clearly describing where the    critical path is in your accelerator, and discussing if this is    the expected path</li> <li>Include a sentence discussing the number of cycles required for the    accelerator to accumulate 31 elements; clearly justify this cycle    count</li> <li>Include a sentence discussing the total execution time in    nanoseconds required for the accelerator to accumulate 31 elements</li> </ul> </li> </ul>"},{"location":"ece2300-lab4ef-proc/#section-5-conclusion-one-paragraph","title":"Section 5: Conclusion (one paragraph)","text":"<ul> <li>Include a sentence that provides a clear quantitative comparison in     terms of area and performance between using a general-purpose     processor vs. specialized hardware for this accumulate kernel</li> <li>Include a sentence that provides a clear qualitative comparison in     terms of design complexity and generality between using a     general-purpose processor vs. specialized hardware</li> <li>Include a sentence that draws a high-level conclusion; how has what     you have learned impact your perspective of computer engineering</li> </ul>"},{"location":"ece2300-lab4ef-proc/#appendix","title":"Appendix","text":"<ul> <li>Complex TinyRV1 program worksheet (from Lab 4D)</li> <li>Three-function calculator assembly program</li> <li>Accumulate assembly program</li> <li>FPGA Area and Performance Data Tables</li> <li>RTL viewer showing complete hierarchy on left and full adder gate-level     implementation on the right</li> <li>Chip planner showing location of logic used to implement processor</li> <li>Processor datapath diagram with highlighted critical path and      annotated delays</li> <li>Accumulate accelerator datapath diagram with highlighted critical path      and annotated delays</li> <li>Accumulate accelerator FSM diagram</li> <li>You do not need to include the actual critical path reports!</li> </ul>"},{"location":"ece2300-sec01-linux/","title":"Section 1: Linux Development Environment","text":"<p>This discussion section serves as gentle introduction to the basics of using the Linux development environment on the <code>ecelinux</code> servers. We will be using the <code>ecelinux</code> servers for all of the lab assignments. The <code>ecelinux</code> servers all run the Red Hat Enterprise Linux 8 operating system, and they all use an identical setup. Linux is the operating system of choice for hardware design, so becoming familiar with Linux will pay dividends beyond just this course. In the discussion section, we will learn how to log into the servers using PowerShell, how to log into the servers using VS Code, how to work at the Linux command line, and how to use Git version control.</p>"},{"location":"ece2300-sec01-linux/#1-logging-into-ecelinux-with-powershell","title":"1. Logging Into ecelinux with PowerShell","text":"<p>We will start by using PowerShell to log into the <code>ecelinux</code> servers. Although most of the time you will be using VS Code to log into the <code>ecelinux</code> servers, you may occassionally need to use PowerShell (or Mac Terminal if you are using a Mac OS X) if VS Code stops working.</p>"},{"location":"ece2300-sec01-linux/#11-logging-into-ecelinux-servers-with-powershell","title":"1.1. Logging into <code>ecelinux</code> Servers with PowerShell","text":"<p>To start PowerShell click the Start menu then search for Windows PowerShell. After starting PowerShell, type in the following command at the prompt to log into the ecelinux servers using SSH.</p> <pre><code>% ssh netid@ecelinux.ece.cornell.edu\n</code></pre> <p>Replace netid with your Cornell NetID in the command above. You should not enter the <code>%</code> character. We use the <code>%</code> character to indicate what commands we should enter on the command line. Executing the command will prompt you to enter your Cornell NetID password, and then you should be connected to the ecelinux servers.</p> <p>The very first time you log into the ecelinux servers you may see a warning like this:</p> <pre><code> The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019\n can\u2019t be established. ECDSA key fingerprint is\n SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI.\n Are you sure you want to continue connecting (yes/no)?\n</code></pre> <p>The very first time you log into the <code>ecelinux</code> servers it is okay to enter <code>yes</code>, but from then on if you continue to receive this warning please contact the course staff.</p>"},{"location":"ece2300-sec01-linux/#12-using-powershell","title":"1.2. Using PowerShell","text":"<p>The very first thing you need to do after opening a terminal is source the course setup script. This will ensure your environment is setup with everything you need for working on the lab assignments. Enter the following command on the command line:</p> <pre><code>% source setup-ece2300.sh\n</code></pre> <p>Note that you do not need to enter <code>%</code> character. In a tutorial like this, the <code>%</code> simply indicates what you should type at the command line. You should now see <code>ECE 2300</code> in your prompt which means your environment is setup for the course.</p> <p>It can be tedious to always remember to source the course setup script. You can also use auto setup which will automatically source the course setup for you when you log in. Note that if the environment for ECE 2300 conflicts with the environment required by a different course then you will need to manually source the setup script when you are working on this course. Enter the following command on the command line to use auto setup:</p> <pre><code>% source setup-ece2300.sh --enable-auto-setup\n</code></pre> <p>If at anytime you need to disable auto setup you can use the following command:</p> <pre><code>% source setup-ece2300.sh --disable-auto-setup\n</code></pre>"},{"location":"ece2300-sec01-linux/#2-logging-into-ecelinux-with-vs-code","title":"2. Logging Into ecelinux with VS Code","text":"<p>While PowerShell is fine for basic work at the Linux command line, it is not a productive way to develop large and complicated computer engineering projects. We instead, recommend students use VS Code to log into the <code>ecelinux</code> servers. VS Code provides a nice GUI for navigating the directory hierarchy on <code>ecelinux</code>, great syntax highlighting for Verilog hardware designs, the ability to open many files at once using tabs, and an integrated remote terminal for running commands at the Linux command line. When using VS Code it is important to keep in mind that the GUI interface runs completely on the local workstation and then automatically handles copying files back and forth between the local workstation and the <code>ecelinux</code> servers.</p> <p>Note, if you have already installed VS Code on your laptop, then you should feel free to use your laptop for this discussion section. However, if you have not already installed VS Code on your laptop and verified it works, then please use the workstations in 225 Upson. We do not have time to help you setup VS Code on your own laptop in the discussion section.</p>"},{"location":"ece2300-sec01-linux/#21-logging-into-ecelinux-servers-with-vs-code","title":"2.1. Logging into <code>ecelinux</code> Servers with VS Code","text":"<p>To start VS Code click the Start menu then search for Visual Studio Code. The key to VS Code is installing the correct extensions. We want to start by installing a special extension for the Verilog hardware description language (HDL). We also want to install a special extension which will enable remotely accessing the <code>ecelinux</code> servers using SSH. Choose View &gt; Extensions from the menubar. Enter the name of the extension in the \"Search Extensions in Marketplace\" and then click the blue Install button. Here are the names of the extensions to install:</p> <ul> <li>Remote - SSH (use the one from Microsoft)</li> <li>Verilog (use the one from Masahiro Hiramori)</li> <li>Surfer (use the one from surfer-project)</li> </ul> <p></p> <p></p> <p></p> <p>Now we need to log into the <code>ecelinux</code> servers. Choose View &gt; Command Palette from the menubar. This will cause a little \"command palette\" to drop down where you can enter commands to control VS Code. Enter the following command in the command palette:</p> <pre><code>Remote-SSH: Connect Current Window to Host...\n</code></pre> <p>As you start typing matching commands will be displayed and you can just click the command when you see it. VS Code will then ask you to Enter SSH Connection Command, and you should enter the following:</p> <pre><code>netid@ecelinux.ece.cornell.edu\n</code></pre> <p>Replace <code>netid</code> with your Cornell NetID in the command above.</p> <p>You may see a pop-up which stays that the Windows Defender Firewall as blocked some features of this app. This is not a problem. Simply click Cancel. You might also see a drop down which asks you to choose the operating system of the remote server with options like Linux and Windows. Choose Linux. Finally, the very first time you log into the <code>ecelinux</code> servers you may see a warning like this:</p> <pre><code>\"ecelinux.ece.cornell.edu\" has fingerprint\n\"SHA256:YCh2FiadeTXEzuSkC0AOdglBgPciwc8WvcCPncvr2Fs\"\nAre you sure you want to continue?\nContinue\nCancel\n</code></pre> <p>Also the very first time you log into the <code>ecelinux</code> servers you will see a pop up dialog box in the lower right-hand corner which says Setting up SSH host ecelinux.ece.cornell.edu (details) Initializing.... It might take up to a minute for everything to be setup; please be patient! Once the pop up dialog box goes away and you see SSH: ecelinux.ece.cornell.edu in the lower left-hand corner of VS Code then you know you are connected to the ecelinux servers.</p> <p></p> <p>The final step is to make sure your extensions for the Verilog HDL and Surfer are also installed on the server. Choose View &gt; Extensions from the menubar. Use the \"Search Extensions in Marketplace\" to search for the same Verilog HDL extensions that we installed earlier. Instead of saying Install it should now say Install in SSH: ecelinux.ece.cornell.edu. Install the Verilog HDL extension on the <code>ecelinux</code> servers. You only need to do this once, and then next time this extension will already be installed on the <code>ecelinux</code> servers.</p>"},{"location":"ece2300-sec01-linux/#22-using-vs-code","title":"2.2. Using VS Code","text":"<p>VS Code includes an integrated file explorer which makes it very productive to browse and open files. Choose View &gt; Explorer from the menubar, and then click on Open Folder. VS Code will then ask you to Open File Or Folder with a default of <code>/home/netid</code>. Click OK.</p> <p>You might see a pop-up which asks you Do you trust the authors of the files in this folder? Since you will only be browsing your own files on the <code>ecelinux</code> server, it is fine to choose Yes, I trust the authors.</p> <p>This will reload VS Code, and you should now you will see a file explore in the left sidebar. You can easily browse your directory hierarchy, open files by clicking on them, create new files, and delete files.</p> <p>VS Code includes an integrated terminal which will give you access to the Linux command line on the <code>ecelinux</code> servers. Choose Terminal &gt; New Terminal from the menubar. You should see the same kind of Linux command line prompt that you saw when using PowerShell.</p> <p>Remember, the very first thing you need to do after logging into the ecelinux servers is source the course setup script. If you used --enable-auto-setup in the last section, then the setup script is already sourced for you automatically when you log into the ecelinux servers. If not, you will need to enter the following command on the command line:</p> <pre><code>% source setup-ece2300.sh\n</code></pre> <p>You should now see <code>ECE 2300</code> in your prompt which means your environment is setup for the course.</p>"},{"location":"ece2300-sec01-linux/#3-linux-command-line","title":"3. Linux Command Line","text":"<p>We will using the <code>ecelinux</code> servers which run the Linux operating system for all of the lab assignments. The heart of the Linux operating system is the Linux command line. This is a text-based console where you can enter commands to interact with the operating system.</p>"},{"location":"ece2300-sec01-linux/#31-hello-world","title":"3.1 Hello World","text":"<p>We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the <code>echo</code> command. The <code>echo</code> command simply \"echoes\" its input to the console.</p> <pre><code>% echo \"Hello, World\"\n</code></pre> <p>The string we provide to the echo command is called a command line argument. We use command line arguments to tell commands what they should operate on. Again, note that you do not need to enter <code>%</code> character.</p>"},{"location":"ece2300-sec01-linux/#32-manual-pages","title":"3.2. Manual Pages","text":"<p>You can learn more about any Linux command by using the <code>man</code> command. Try using this to learn more about the <code>echo</code> command.</p> <pre><code>% man echo\n</code></pre> <p>You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the <code>q</code> key to quit viewing the manual.</p>"},{"location":"ece2300-sec01-linux/#33-create-view-and-list-files","title":"3.3. Create, View, and List Files","text":"<p>We can use the echo command and a feature called command output redirection to create simple text files. Command output redirection is discussed more in the full tutorial. Command output redirection uses the <code>&gt;</code> operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named <code>ece2300-sec01.txt</code> that simply contains the text \"Digital Logic and Computer Organization\".</p> <pre><code>% echo \"Digital Logic and Computer Organization\" &gt; ece2300-sec01.txt\n</code></pre> <p>We can use the <code>cat</code> command to quickly display the contents of a file.</p> <pre><code>% cat ece2300-sec01.txt\n</code></pre> <p>For larger files, <code>cat</code> will output the entire file to the console so it may be hard to read the file as it streams past. We can use the <code>less</code> command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the <code>q</code> key to quit viewing the file.</p> <pre><code>% less ece2300-sec01.txt\n</code></pre> <p>The <code>&gt;</code> command output redirection operator will always create a brand new file (even if the target output file already exists). You can use the <code>&gt;&gt;</code> operator to append lines to the end of a file. Let's add another line to our text file using the <code>&gt;&gt;</code> operator.</p> <pre><code>% echo \"Using the Verilog Hardware Description Language\" &gt;&gt; ece2300-sec01.txt\n% cat ece2300-sec01.txt\n</code></pre> <p>You can use the <code>ls</code> command to list the filenames of the files you have created.</p> <pre><code>% ls\n</code></pre> <p>We can provide command line options to the <code>ls</code> command to modify the command\u2019s behavior. For example, we can use the <code>-1</code> (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the <code>-l</code> (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file.</p>"},{"location":"ece2300-sec01-linux/#34-create-change-and-list-directories","title":"3.4. Create, Change, and List Directories","text":"<p>Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an <code>ecelinux</code> machine, you will be in your home directory. This is your own private space on the server that you can use to work on the lab assignments and store your files. You can use the <code>pwd</code> command to print the directory in which you are currently working, which is known as the current working directory.</p> <pre><code>% pwd\n    /home/netid\n</code></pre> <p>You should see output similar to what is shown above, but instead of <code>netid</code> it should show your actual NetID. The pwd command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named home that contains a directory named <code>netid</code>. This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash (<code>/</code>) to separate directories, while Windows uses a back slash (<code>\\</code>) for the same purpose.</p> <p>We can use the <code>mkdir</code> command to make new directories. The following command will make a new directory named <code>ece2300</code> within your home directory.</p> <pre><code>% mkdir ece2300\n</code></pre> <p>We can use the <code>cd</code> command to change our current working directory. The following command will change the current working directory to be the newly created <code>ece2300</code> directory, before displaying the current working directory with the pwd command.</p> <pre><code>% cd ece2300\n% pwd\n    /home/netid/ece2300\n</code></pre> <p>Use the <code>mkdir</code>, <code>cd</code>, and <code>pwd</code> commands to make another directory.</p> <pre><code>% mkdir test\n% cd test\n% pwd\n    /home/netid/ece2300/test\n</code></pre> <p>We sometimes say that <code>test</code> is a subdirectory or a child directory of the <code>ece2300</code> directory. We might also say that the <code>ece2300</code> directory is the parent directory of the <code>test</code> directory. Use the following command to create a new file in this child directory.</p> <pre><code>% cd /home/netid/ece2300/test\n% echo \"Digital Logic and Computer Organization\" &gt; ece2300-sec01.txt\n% mkdir dirA\n% ls\n</code></pre> <p>You can use the <code>tree</code> command to visualize the directory layout and where files are located:</p> <pre><code>% cd ~/ece2300\n% tree\n</code></pre> <p>Note that the tilde character (<code>~</code>) is a shortcut which always refers to your home directory. There are a few other very useful shortcuts. You can use a single dot (<code>.</code>) to refer to the current working directory, and you can use a double dot (<code>..</code>) to refer to the parent directory of the current working directory.</p> <pre><code>% cd ~/ece2300/test\n% cd ..\n% cd ..\n% pwd\n</code></pre>"},{"location":"ece2300-sec01-linux/#35-copy-move-and-remove-files-and-directories","title":"3.5. Copy, Move, and Remove Files and Directories","text":"<p>We can use the <code>cp</code> command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section.</p> <pre><code>% cd ~/ece2300/test\n% cp ece2300-sec01.txt ece2300-sec01-a.txt\n% cp ece2300-sec01.txt ece2300-sec01-b.txt\n% ls\n</code></pre> <p>Instead of copying we can also move a file with the <code>mv</code> command:</p> <pre><code>% cd ~/ece2300/test\n% mv ece2300-sec01.txt ece2300-sec01-c.txt\n% ls\n</code></pre> <p>Finally, we can use the <code>rm</code> command to remove files.</p> <pre><code>% cd ~/ece2300/test\n% ls\n% rm ece2300-sec01-a.txt\n</code></pre> <p>We have installed a simple program called <code>trash</code> which moves files you wish to delete into a special subdirectory of your home directory located at <code>~/tmp/trash</code>. The following commands create a file and then deletes it using trash.</p> <pre><code>% cd ~\n% echo \"This file will be deleted.\" &gt; testing.txt\n% trash testing.txt\n% echo \"This file will also be deleted.\" &gt; testing.txt\n% trash testing.txt\n% ls ~/tmp/trash\n</code></pre> <p>If you look in <code>~/tmp/trash</code> you will see subdirectories organized by date. Look in the subdirectory with today's date and you should two files corresponding to the two files you deleted. We highly recommend always using the <code>trash</code> command instead of <code>rm</code> since this avoids accidentally deleting your work.</p>"},{"location":"ece2300-sec01-linux/#36-using-vs-code-to-work-with-files","title":"3.6. Using VS Code to Work with Files","text":"<p>VS Code makes it easy to create and open files for editing from the command line. To open an existing file for editing use the <code>code</code> command on the command line. For example, you can open the <code>ece2300-sec01.txt</code> file like this:</p> <pre><code>% cd ~/ece2300/test\n% code ece2300-sec01.txt\n</code></pre> <p>Add some text of your choice to the bottom of the file. Then use File &gt; Save and then use <code>cat</code> to verify your changes through the command line.</p> <pre><code>% cd ~/ece2300/test\n% cat ece2300-sec01.txt\n</code></pre> <p>If you use the <code>code</code> command and the file does not exist, then VS Code will automatically create a new file with the corresponding filename.</p> <pre><code>% cd ~/ece2300/test\n% code ece2300-sec01-d.txt\n</code></pre> <p>Enter some text, save the file, and use <code>cat</code> to verify your chagnes through the command line. You can also use VS Code's integrated file explorer to create files and open files for editing.</p>"},{"location":"ece2300-sec01-linux/#4-github-account-setup","title":"4. GitHub Account Setup","text":"<p>We will be using GitHub for centralized repository hosting. You can check to see if you have a GitHub account on <code>github.com</code> using this link: <code>https://github.com/githubid</code> where <code>githubid</code> is your GitHub username on <code>github.com</code>. If the above link does not work, then you do not have an GitHub account on <code>github.com</code>. NOTE: We are using <code>github.com</code> not the Cornell hosted GitHub! You will need to create one here:</p> <ul> <li>https://github.com/join</li> </ul> <p>Your NetID makes a great GitHub username on <code>github.com</code>. If you are creating a new GitHub account, then be sure to use your Cornell email address. If you have an existing account it is fine for it to use a non-Cornell email address.</p> <p>Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Please also consider uploading a profile photo to GitHub; it makes it more fun to interact on GitHub if we all know what each other look like. Go to the following page and enter your first and last name in the Name field, and then consider uploading a profile photo.</p> <ul> <li>https://github.com/settings/profile</li> </ul> <p>Once you have a GitHub username, please fill out the following online so the instructors know the mapping from NetID to GitHub username:</p> <ul> <li>http://www.csl.cornell.edu/courses/ece2300/githubid</li> </ul> <p>Before you can begin using GitHub, you need to create an SSH key pair on an <code>ecelinux</code> machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. The course setup script takes care of creating an SSH key pair which you can use. View the contents of your public key using the following commands:</p> <pre><code>% cat ~/.ssh/ece2300-github.pub\n</code></pre> <p>Use the following page to upload the public key to GitHub:</p> <ul> <li>https://github.com/settings/ssh</li> </ul> <p>Click on New SSH Key, and then cut-and-paste the public key you displayed using cat into the key textbox. Give the key the title <code>ece2300-github</code>. Then click Add SSH key. To test things out try the following command:</p> <pre><code>% ssh -T git@github.com\n</code></pre> <p>You may see a warning about the authenticity of the host. Don\u2019t worry, this is supposed to happen the first time you access GitHub using your new key. Just enter <code>yes</code>. The GitHub server should output some text including your GitHub username. Verify that the GitHub username is correct, and then you should be all set.</p>"},{"location":"ece2300-sec01-linux/#5-git-version-control-system","title":"5. Git Version Control System","text":"<p>In this course, we will be using Git as our revision control and source code management system. Git will enable us to adopt an agile development methodology so you (and your group) can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments.</p>"},{"location":"ece2300-sec01-linux/#51-fork-and-clone-a-repo-from-github","title":"5.1. Fork and Clone a Repo from GitHub","text":"<p>Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the lab assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here:</p> <ul> <li>https://github.com/cornell-ece2300/ece2300-sec01-linux</li> </ul> <p>Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace:</p> <ul> <li><code>https://github.com/githubid/ece2300-sec01-linux</code></li> </ul> <p>Where <code>githubid</code> is your username on the public version of GitHub. Now let's clone your new repo to the <code>ecelinux</code> machine.</p> <pre><code>% mkdir -p ece2300\n% cd ~/ece2300\n% git clone git@github.com:githubid/ece2300-sec01-linux sec01\n% cd sec01\n% cat README.md\n</code></pre> <p>Where <code>githubid</code> is your username on the public version of GitHub.</p>"},{"location":"ece2300-sec01-linux/#52-adding-and-committing-files-to-local-repository","title":"5.2. Adding and Committing Files to Local Repository","text":"<p>Now let's add some new files to the repository. Use VS Code to create a file named <code>warm-colors.txt</code>:</p> <pre><code>% cd ~/ece2300/sec01\n% code warm-colors.txt\n</code></pre> <p>Add three warm colors and save the file.</p> <pre><code>red\norange\nyellow\n</code></pre> <p>Now use VS Code to create a file named <code>cool-colors.txt</code>:</p> <pre><code>% cd ~/ece2300/sec01\n% code cool-colors.txt\n</code></pre> <p>Add three cool colors and save the file.</p> <pre><code>blue\ngreen\npurple\n</code></pre> <p>Now let's add these files to our repository. First use the <code>git status</code> command to check on the status of the repository.</p> <pre><code>% cd ~/ece2300/sec01\n% git status\n</code></pre> <p>You should see that git has noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area so it now knows it should keep track of them:</p> <pre><code>% cd ~/ece2300/sec01\n% git add warm-colors.txt\n% git add cool-colors.txt\n% git status\n</code></pre> <p>The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository.</p> <pre><code>% cd ~/ece2300/sec01\n% git commit -m \"add some colors\"\n</code></pre> <p>Let's now use <code>echo</code> and the <code>&gt;&gt;</code> command output redirection operator to add <code>cyan</code> to the end of our <code>cool-colors.txt</code> file. We can then view our changes from the command line using <code>cat</code>, and use <code>git status</code> and then <code>git commit</code> to try and commit our changes.</p> <pre><code>% cd ~/ece2300/sec01\n% echo \"cyan\" &gt;&gt; cool-colors.txt\n% cat cool-colors.txt\n% git status\n% git commit -m \"add cyan\"\n</code></pre> <p>Git will report that there are no changes added to the commit. So even though Git is tracking <code>cool-colors.txt</code> and knows it has changed, we still must explicitly add the files we want to commit. We recommend using the <code>-a</code> command line option with the <code>git commit</code> command to tell Git to add any file which has changed and was previously added to the repository before doing the commit.</p> <pre><code>% cd ~/ece2300/sec01\n% git status\n% git commit -a -m \"add cyan\"\n</code></pre> <p>Now the changes are committed. You can use <code>git log</code> to see a log of the commits in your local repository.</p> <pre><code>% cd ~/ece2300/sec01\n% git log\n</code></pre>"},{"location":"ece2300-sec01-linux/#53-pushing-files-to-github","title":"5.3. Pushing Files to GitHub","text":"<p>Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this:</p> <pre><code>% cd ~/ece2300/sec01\n% git push\n</code></pre> <p>Now go to the repository page using the GitHub web interface and verify that there are two new files.</p> <ul> <li><code>https://github.com/githubid/ece2300-sec01-linux</code></li> </ul>"},{"location":"ece2300-sec01-linux/#54-pulling-files-from-github","title":"5.4. Pulling Files from GitHub","text":"<p>Let's try making a change to this repository through the GitHub web interface.</p> <ul> <li><code>https://github.com/githubid/ece2300-sec01-linux</code></li> </ul> <p>Click on Add file and then Create new file. Name the file <code>logic-gates.txt</code> and add a list of logic gates:</p> <pre><code>NOT\nAND\nOR\nNAND\nNOR\n</code></pre> <p>Now click Commit new file. Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on <code>ecelinux</code>:</p> <pre><code>% cd ~/ece2300/sec01\n% git pull\n% cat logic-gates.txt\n</code></pre> <p>This will be the basic GitHub workflow were students first use <code>clone</code> to get a copy of their repository, use <code>commit -a</code> to commit their code to the local repository, and then use <code>pull</code> and <code>push</code> to synchronize their repository with the repository on GitHub.</p>"},{"location":"ece2300-sec01-linux/#6-to-do-on-your-own","title":"6. To-Do On Your Own","text":"<p>If you have time, add <code>maroon</code> to the <code>warm-colors.txt</code> file you created earlier using VS Code. Save the file and then view your changes from the command line using <code>cat</code>. Then use <code>git status</code> and <code>git commit -a</code> to add these changes to local repository, and then use <code>git push</code> to push these changes up to GitHub. View the changes using the GitHub web interface.</p> <p>Then try editing a file using the GitHub web interface. Click on the <code>warm-colors.txt</code> file and then click on the pencil in the right-hand corner to edit this text file. Add another warm color. Click Commit changes. Then pull these changes to the local repository on the <code>ecelinux</code> server and verify that your new warm color is included.</p>"},{"location":"ece2300-sec02-verilog-gl/","title":"Section 2: Verilog Combinational Gate-Level Design","text":"<p>In this discussion section you will develop your first Verilog hardware design, build a simulator for your design, and then test the functionality of your design.</p>"},{"location":"ece2300-sec02-verilog-gl/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as last discussion section. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>Note that installing the Surfer extension is new from last time.</p> <p></p> <p>You need to install the Surfer extension on both your local machine and the server. So you might need to disconnect from the server using File &gt; Close Remote Connection. Now fork the GitHub repo we will be using in this discussion section. As mentioned last week, we won't actually be forking repos for the lab assignments, but it is an easy way for you to grab some example code for this discussion section and also to see how GitHub actions work. Go to the example repo here:</p> <ul> <li>https://github.com/cornell-ece2300/ece2300-sec02-verilog-gl</li> </ul> <p>Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace:</p> <ul> <li>https://github.com/githubid/ece2300-sec02-verilog-gl</li> </ul> <p>where <code>githubid</code> is your username on the public version of GitHub. Enable GitHub Actions on this repo. Click on the Actions tab in your repository on GitHub and click I understand my workflows, go ahead and enable them. Now let's clone your new repo to the <code>ecelinux</code> machine.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:githubid/ece2300-sec02-verilog-gl sec02\n% cd sec02\n% tree\n</code></pre> <p>Where <code>githubid</code> is your username on the public version of GitHub. The repo includes the following files:</p> <ul> <li><code>PairTripleDetector_GL.v</code> : Verilog for simple hardware module</li> <li><code>PairTripleDetector_GL-adhoc.v</code> : adhoc test for hardware module</li> <li><code>ece2300-test.v</code> : ECE 2300 unit testing library</li> <li><code>PairTripleDetector_GL-test.v</code> : test cases for hardware module</li> </ul>"},{"location":"ece2300-sec02-verilog-gl/#2-background-on-a-pairtriple-detector","title":"2. Background on a Pair/Triple Detector","text":"<p>We will be using a pair/triple detector as the target hardware in this discussion section. A pair/triple detector has some number of input ports and one output port. The output is one if either two or three of the inputs are one, and is the output should be zero otherwise. Here is a truth table for a three-bit pair/triple detector.</p> in0 in1 in2 out 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 <p>Verify that this truth table matches the specification above. Here is a gate-level network that implements this truth table.</p> <p></p> <p>Here is an example of an incomplete simulation table for this gate-level network.</p> in0 in1 in2 w x y out 0 0 0 0 1 1 0 1 0 1 1 1 <p>Here is an example of an incomplete waveform which corresponds to the above simulation table.</p> <p></p> <p>Activity 1: Simulation Tables and Waveforms</p> <p>Complete the above simulation table and waveform. Assume a zero delay model.</p>"},{"location":"ece2300-sec02-verilog-gl/#3-implementing-and-linting-a-pairtriple-detector-in-verilog","title":"3. Implementing and Linting a Pair/Triple Detector in Verilog","text":"<p>In this part, we will first implement a pair/triple detector before linting the detector to check for errors.</p>"},{"location":"ece2300-sec02-verilog-gl/#31-implementing-a-verilog-design","title":"3.1. Implementing a Verilog Design","text":"<p>Before implementing the pair/triple detector, you might want to review how to instantiate our primitive logic gates in Verilog.</p> <p></p> <p>We have provided you with the interface for the pair/triple detector in <code>PairTripleDetector_GL.v</code>.</p> <pre><code>module PairTripleDetector_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n</code></pre> <p>The module has three input ports and one output port. Notice that this file has a <code>_GL</code> suffix which standes for \"gate-level\". We will use various suffixes to clearly indicate what level of modeling is being used within the implementation of the corresponding Verilog hardware design. Open the <code>PairTripleDetector_GL.v</code> Verilog file using VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% code PairTripleDetector_GL.v\n</code></pre> <p>Activity 2: Implement a Pair/Triple Detector</p> <p>Create a Verilog hardware design that implements a pair/triple detector by declaring wires, instantiating primitive logic gates, and connecting the wires and gates appropriately.</p>"},{"location":"ece2300-sec02-verilog-gl/#32-linting-a-verilog-design","title":"3.2. Linting a Verilog Design","text":"<p>Note that Verilog is a very relaxed language which allows all kinds of sketch constructs many of which are only flagged with warnings. So we will be using the open-source <code>verilator</code> tool to lint our Verilog hardware designs. Linting means to check the design for static errors. It is critical be clear that <code>verilator</code> will only check for static errors (i.e., syntax errors) and does not actually test that your hardware design has the desired dynamic behavior. We will use testing in the next part to verify your hardawre design has the desired dynamic behavior. There is more information about <code>verilator</code> on its webpage:</p> <ul> <li>https://www.veripool.org/verilator</li> </ul> <p>Here is how to use <code>verilator</code> to lint our design.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% verilator -Wall --lint-only PairTripleDetector_GL.v\n</code></pre> <p>If <code>verilator</code> does not report any warnings or errors then you are ready to compile a simulator; but let's purposefully make an error in our Verilog hardware design. For example, modify your hardware design to purposefully omit the semicolon at the end of the module interface.</p> <pre><code>`ifndef PAIR_TRIPLE_DETECTOR_V1_GL_V\n`define PAIR_TRIPLE_DETECTOR_V1_GL_V\n\nmodule PairTripleDetectorV1_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  //''' ACTIVITY '''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n  // Implement pair/triple detector using explicit gate-level modeling\n  //&gt;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\nendmodule\n\n`endif /* PAIR_TRIPLE_DETECTOR_V1_GL_V */\n</code></pre> <p>The <code>ifdef</code>, <code>define</code>, and <code>endif</code> statements are for the Verilog preprocessor and act as include guards; then ensure if we include a Verilog module multiple times it is only inserted into the final Verilog hardware design once.</p> <p>Activity 3: Injecting a Static Bug</p> <p>Try removing the semicolon after the closed parenthesis to create a   bug. Rerun <code>verilator</code> to lint your design. You should see an error.   <code>verilator</code> is much, much better at catching syntax bugs and providing   useful error messages. So we will always lint our designs first with   <code>verilator</code>, and then (only once we are sure there are no static   errors!) we will move on to testing our hardware design's   functionality.</p>"},{"location":"ece2300-sec02-verilog-gl/#4-ad-hoc-testing-a-pairtriple-detector-in-verilog","title":"4. Ad-Hoc Testing a Pair/Triple Detector in Verilog","text":"<p>In this part, we will first implement a test bench for our pair/triple detector before simulating the detector to test its functionality.</p>"},{"location":"ece2300-sec02-verilog-gl/#41-implementing-a-verilog-test-bench","title":"4.1. Implementing a Verilog Test Bench","text":"<p>Now that we have successfully linted our design, we want to test its functionality (i.e., make sure it produces the correct output for various inputs). We need to implement a Verilog test bench which will set inputs and check outputs. We can use Verilog to implement hardware designs and to implement test benches. It is critical we keep these two very different uses of Verilog separate! When using Verilog for hardware design we are using Verilog to model hardware. We must be very careful, restrict ourselves to a very limited subset of the Verilog language, and ensure we always know what is the hardware we are modeling. It is easy to write Verilog which does not model any real hardware! When using Verilog for test benches, we can use any part of the Verilog language we want; our goal is not to model hardware but to test hardware.</p> <p>We have provided you a simple ad-hoc test bench in <code>PairTripleDetector_GL-adhoc.v</code>. Take a look at this file in VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% code PairTripleDetector_GL-adhoc.v\n</code></pre> <pre><code>`include \"PairTripleDetectorV1_GL.v\"\n\nmodule Top();\n\n  logic dut_in0;\n  logic dut_in1;\n  logic dut_in2;\n  logic dut_out;\n\n  PairTripleDetector_GL dut\n  (\n    .in0 (dut_in0),\n    .in1 (dut_in1),\n    .in2 (dut_in2),\n    .out (dut_out)\n  );\n\n  initial begin\n    $dumpfile(\"PairTripleDetector_GL-test.vcd\");\n    $dumpvars;\n\n    dut_in0 = 0;\n    dut_in1 = 0;\n    dut_in2 = 0;\n    #10;\n    $display( \"%b %b %b &gt; %b\", dut_in0, dut_in1, dut_in2, dut_out );\n\n    dut_in0 = 0;\n    dut_in1 = 1;\n    dut_in2 = 1;\n    #10;\n    $display( \"%b %b %b &gt; %b\", dut_in0, dut_in1, dut_in2, dut_out );\n\n    dut_in0 = 0;\n    dut_in1 = 1;\n    dut_in2 = 0;\n    #10;\n    $display( \"%b %b %b &gt; %b\", dut_in0, dut_in1, dut_in2, dut_out );\n\n    dut_in0 = 1;\n    dut_in1 = 1;\n    dut_in2 = 1;\n    #10;\n    $display( \"%b %b %b &gt; %b\", dut_in0, dut_in1, dut_in2, dut_out );\n\n  end\n\nendmodule\n</code></pre> <p>The <code>include</code> statement is used by the Verilog preprocessor and indicates that the adhoc test depends on the Verilog hardware design. We start by declaring four wires that will be connected to the design-under-test. Note that we use <code>logic</code> not <code>wire</code> in test benches. A <code>logic</code> is a more abstract kind of signal than a <code>wire</code> in Verilog. We then instantiates the design-under-test (DUT) and hooks up the ports to the <code>logic</code> signals we just declared.</p> <p>An initial block is a special piece of code which starts running at the beginning of a simulation. You should NEVER use an initial block when modeling hardware. But it is perfectly fine to use an initial block in your test benches. We call two system tasks (<code>$dumpfile</code>,<code>$dumpvars</code>) to tell the simulator to output a VCD file which contains waveforms so we can visualize what our hardware design is doing. Then we set input values for all input ports. Then wait 10 units of time. Then we display all of the input and output values. We do this four times with four different sets of input values.</p>"},{"location":"ece2300-sec02-verilog-gl/#42-ad-hoc-testing-a-verilog-design","title":"4.2. Ad-Hoc Testing a Verilog Design","text":"<p>Now that we have implemented and linted our Verilog hardware design and implemented a test bench, we want to simulate our hardware design to verify its functionality. We will be using the open-source <code>iverilog</code> (Icarus Verilog) simulator. One weakness of <code>iverilog</code> is that its error messages are not great; this is one of the primary reasons we always want to lint our designs first using <code>verilator</code>. There is more information about <code>iverilog</code> on its webpage:</p> <ul> <li>https://steveicarus.github.io/iverilog</li> </ul> <p>When using <code>iverilog</code> there are always two steps. First, we create a simulator and then we need to explicitly run the simulator to test hardware design. Let's start by using <code>iverilog</code> to create a simulator based on our pair/triple hardware design and test bench.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% iverilog -Wall -g2012 -o PairTripleDetector_GL-adhoc PairTripleDetector_GL-adhoc.v\n</code></pre> <p>If there are no errors you should now have a simulator named <code>PairTripleDetector_GL-adhoc</code>. Go ahead and execute the simulator.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% ./PairTripleDetector_GL-adhoc\n</code></pre> <p>The ad-hoc test will print out a simulation table. Compare it to the simulation table you created by hand earlier in this discussion section. You can also view the corresponding waveforms using the Surfer extension.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% code PairTripleDetector_GL-adhoc.vcd\n</code></pre> <p>Find the Scopes panel and click on the arrow next to Top. Click on dut and then click on the signals in the Variables panel to see the waveforms.</p>"},{"location":"ece2300-sec02-verilog-gl/#5-systematic-testing-for-a-pairtriple-detector-in-verilog","title":"5. Systematic Testing for a Pair/Triple Detector in Verilog","text":"<p>So far we have been using \"ad-hoc\" testing. Our test bench will display outputs on the terminal. If it is not what we expected, we can debug our hardware design until it meets our expectations. Unfortunately, ad-hoc testing is error prone and not easily reproducible. If you later make a change to your implementation, you would have to take another look at the output to ensure your implementation still works. If another designer wants to understand your implementation and verify that it is working, he or she would also need to take a look at the output and think hard about what is the expected result. Ad-hoc testing is usually verbose, which makes it error prone, and does not use any kind of standard test output. While ad-hoc testing might be feasible for very simple implementations, it is obviously not a scalable approach when developing the more complicated implementations we will tackle in this course.</p> <p>We will be using a more systematic way to do automated unit testing including standardized naming conventions, test benches, and test output. We have provided you an example of such systematic testing in <code>PairTripleDetector_GL-test.v</code>. Take a look at this file in VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% code PairTripleDetector_GL-test.v\n</code></pre> <p>The systematic test bench still declares four wires that will be connected to the DUT, and also still instantiates the DUT and hooks up the ports. We then declare a <code>check</code> task. We will be using Verilog tasks in our test bench. Tasks are a Verilog feature used for creating test benches and should be avoided when modeling hardware. A task is similar to a function in a software programming language and are critical for creating clean test benches.</p> <pre><code>  task check\n  (\n    input logic in0,\n    input logic in1,\n    input logic in2,\n    input logic out\n  );\n    if ( !t.failed ) begin\n\n      dut_in0 = in0;\n      dut_in1 = in1;\n      dut_in2 = in2;\n\n      #8;\n\n      if ( t.n != 0 )\n        $display( \"%3d: %b %b %b &gt; %b\", t.cycles,\n                  dut_in0, dut_in1, dut_in2, dut_out );\n\n      `ECE2300_CHECK_EQ( dut_out, out );\n\n      #2;\n\n    end\n  endtask\n</code></pre> <p>The <code>check</code> task takes as values we want to use as input to test our design, and the correct output values we want to check for. The task then sets the input, waits for some amount of time, displays the input and output values, and then checks that the output is as expected. We then declare one or more test case tasks. Each test case task has a sequence of checks. Here is the basic test case.</p> <pre><code>  task test_case_1_basic();\n    t.test_case_begin( \"test_case_1_basic\" );\n\n    check( 0, 0, 0, 0 );\n    check( 0, 1, 1, 1 );\n    check( 0, 1, 0, 0 );\n    check( 1, 1, 1, 1 );\n\n  endtask\n</code></pre> <p>Finally, our test bench uses an initial block to decide which test cases to run.</p> <pre><code>  initial begin\n    t.test_bench_begin( `__FILE__ );\n\n    if ((t.n &lt;= 0) || (t.n == 1)) test_case_1_basic();\n    if ((t.n &lt;= 0) || (t.n == 2)) test_case_2_exhaustive();\n\n    t.test_bench_end();\n  end\n</code></pre> <p>We can compile and run our systematic testing just like our ad-hoc testing.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% iverilog -Wall -g2012 -o PairTripleDetector_GL-test PairTripleDetector_GL-test.v\n% ./PairTripleDetector_GL-test\n</code></pre> <p>Remember, you can always use the up arrow key to retrieve a previously entered command. You can then quickly edit it as opposed to having to type a complete command from scratch.</p> <p>The simple unit testing framework we provide you enables to specify a single test case to run (with <code>+test-case=1</code> or <code>+test-case=2</code>), and generate a VCD file for viewing waveforms (with <code>+dump-vcd=waveform.vcd</code>).</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% ./PairTripleDetector_GL-test +test-case=1\n% ./PairTripleDetector_GL-test +test-case=1 +dump-vcd=PairTripleDetector_GL-test.vcd\n</code></pre> <p>Open up the waveforms in surfer.</p> <p>Activity 4: Exhaustive Testing</p> <p>Finish the second test case which should use exhaustive testing. Exhaustive testing simply means we test all possible input values. You can refer to the truth table from earlier in the discussion section and simply have one check for every row in the truth table. When you have finished rerun the the test using <code>+test-case=2</code> to make sure your test bench is testing what you think it is. Then inject a bug (e.g., change an OR gate to a NOR gate) to see if the test bench fails.</p>"},{"location":"ece2300-sec02-verilog-gl/#6-automating-the-development-process","title":"6. Automating the Development Process","text":"<p>The key to being a productive hardware designer is to automate as much of the process as possible. We will learn how to use a real build system in the next discussion section to help automate linting, compiling, simulating, and testing hardware designs. In this discussion section, we will briefly discuss two other wayts to automate the development process.</p>"},{"location":"ece2300-sec02-verilog-gl/#61-using-bash-shell-scripts-for-testing","title":"6.1. Using Bash Shell Scripts for Testing","text":"<p>If you find yourself continually having to use the same complex commands over and over, consider creating a Bash shell script to automatically execute those commands. A Bash shell script is just a text file with a list of commands that you can run using the <code>source</code> command.</p> <p>For example, let's create a Bash shell script to automatically lint, compile, and run the systematic test bench developed earlier in the discussion section. Use VS Code to open a new file called <code>PairTripleDetector_GL-test.sh</code> (note that by convention we usually use the <code>.sh</code> extension for Bash shell scripts).</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% code PairTripleDetector_GL-test.sh\n</code></pre> <p>Then enter the following commands into this new Bash shell script.</p> <pre><code>verilator -Wall --lint-only PairTripleDetector_GL.v\niverilog -Wall -g2012 -o PairTripleDetector_GL-test PairTripleDetector_GL-test.v\n./PairTripleDetector_GL-test\n</code></pre> <p>Then save the Bash shell script and execute it using the <code>source</code> command.</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% source PairTripleDetector_GL-test.sh\n</code></pre> <p>The script will automatically lint your design, compile your design with the test bench into a simulator, and then run the simulator to test your design all in a single step.</p>"},{"location":"ece2300-sec02-verilog-gl/#62-using-github-actions-for-continuous-integration","title":"6.2. Using GitHub Actions for Continuous Integration","text":"<p>We will be using GitHub Actions for continuous integration which means that GitHub Actions will run all of your tests in the cloud every time you push to GitHub. Go ahead and commit your work and push to GitHub.</p> <pre><code>% cd ${HOME}/ece2300/sec02\n% git commit -a -m \"finished implementation\"\n% git push\n</code></pre> <p>Then go to the Actions tab of your repo.</p> <ul> <li>https://github.com/githubid/ece2300-sec02-verilog-gl/actions</li> </ul> <p>You should be able to see a workflow run. Click on the name of the workflow run, then click on sim, then if you click on Run sim_tests you should be able to see the output of running the tests in the cloud through GitHub Actions.</p>"},{"location":"ece2300-sec02-verilog-gl/#7-to-do-on-your-own","title":"7. To-Do On Your Own","text":"<p>Let's say we started from just the original truth table for a pair/triple detector without the gate-level network. We can also directly transform this truth table into a (unoptimized) Verilog hardware design. We first use four NOT gates to create the complement of each input. We then declare eight wires, one for each row in the truth table. We use eight AND gates so each to ensure each of the eight wires will be true for a different row in the truth table. Then we OR together all of the wires where the output in the truth table is one to derive the final output.</p> <pre><code>module PairTripleDetector_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  // NOT gates to create complement of each input\n\n  wire in0_b, in1_b, in2_b;\n\n  not( in0_b, in0 );\n  not( in1_b, in1 );\n  not( in2_b, in2 );\n\n  // AND gates for each row in the truth table\n\n  wire min3, min5, min6, min7;\n\n  // and( min0, in0_b, in1_b, in2_b );\n  // and( min1, in0_b, in1_b, in2   );\n  // and( min2, in0_b, in1,   in2_b );\n  and( min3, in0_b, in1,   in2   );\n\n  // and( min4, in0,   in1_b, in2_b );\n  and( min5, in0,   in1_b, in2   );\n  and( min6, in0,   in1,   in2_b );\n  and( min7, in0,   in1,   in2   );\n\n  // OR together all wires where output in truth table is one\n\n  or( out, min3, min5, min6, min7 );\n\nendmodule\n</code></pre> <p>Note that we have commented out the minterms which are not used to avoid causing linting errors. It is still nice to have these minterms as comments to make it easier to write all the minterms out.</p> <p>Using explicit gate-level modeling can be tedious. We can also directly implement Boolean equations in Verilog. Here is how our primitive gates can be implemented using Boolean equations.</p> Explicit Gate-Level Modeling Boolean Equations <code>not( y, a );</code> <code>assign y =  ~a;</code> <code>and( y, a, b );</code> <code>assign y =   a &amp; b;</code> <code>nand( y, a, b );</code> <code>assign y = ~(a &amp; b);</code> <code>or( y, a, b );</code> <code>assign y =   a | b;</code> <code>nor( y, a, b );</code> <code>assign y = ~(a | b);</code> <code>xor( y, a, b );</code> <code>assign y =   a ^ b;</code> <code>xnor( y, a, b );</code> <code>assign y = ~(a ^ b);</code> <p>Here is the exact same gate-level network implementing the pair/triple detector except now implemented using Boolean equations.</p> <pre><code>module PairTripleDetector_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  wire w;\n  wire x;\n  wire y;\n\n  assign w   = in0 | in1;\n  assign x   = in0 &amp; in1;\n  assign y   = w   &amp; in2;\n  assign out = y   | x;\n\nendmodule\n</code></pre> <p>You can also of course use substitution to easily express the output in a single Boolean equation.</p> <pre><code>module PairTripleDetector_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  assign out = ((in0|in1) &amp; in2) | (in0 &amp; in1);\n\nendmodule\n</code></pre> <p>Just as with explicit gate-level modeling, we can also directly transform the original truth table for a pair/triple detector into a Verilog hardware design using Boolean equations.</p> <pre><code>module PairTripleDetectorV5_GL\n(\n  input  wire in0,\n  input  wire in1,\n  input  wire in2,\n  output wire out\n);\n\n  // AND gates for each row in the truth table\n\n  wire min3, min5, min6, min7;\n\n  // assign min0 = ~in0 &amp; ~in1 &amp; ~in2;\n  // assign min1 = ~in0 &amp; ~in1 &amp;  in2;\n  // assign min2 = ~in0 &amp;  in1 &amp; ~in2;\n  assign min3 = ~in0 &amp;  in1 &amp;  in2;\n\n  // assign min4 =  in0 &amp; ~in1 &amp; ~in2;\n  assign min5 =  in0 &amp; ~in1 &amp;  in2;\n  assign min6 =  in0 &amp;  in1 &amp; ~in2;\n  assign min7 =  in0 &amp;  in1 &amp;  in2;\n\n  // OR together all wires where output in truth table is one\n\n  assign out = min3 | min5 | min6 | min7;\n\nendmodule\n</code></pre> <p>again, we have commented out the minterms which are not used to avoid causing linting errors. It is still nice to have these minterms as comments to make it easier to write all the minterms out.</p> <p>We now have explored four new approaches to implementing a pair/triple detector. All four are equivalent with our original implementation. Modify your implementation in <code>PairTripleDetector_GL.v</code> based on one of these new approach and then rerun the ad-hoc and systematic tests to verify your new implementation is correct.</p>"},{"location":"ece2300-sec03-verilog-testing/","title":"Section 3: Verilog Testing","text":"<p>In this discussion section you will learn how to automate the process of linting your designs, building test simulators for your designs, and testing the functionality of your design with these test simulators.</p>"},{"location":"ece2300-sec03-verilog-testing/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as previous discussion sections. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>There is no need to fork the repo for today's discussion section. Simple clone the repo as follows.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:cornell-ece2300/ece2300-sec03-verilog-testing sec03\n% cd sec03\n% tree\n</code></pre> <p>The repo includes the following files:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> <li><code>hw/PairTripleDetector_GL.v</code>: Verilog for pair/triple detector</li> <li><code>hw/PairTripleDetector2_GL.v</code>: Verilog for two pair/triple detectors</li> <li><code>test/ece2300-test.v</code>: ECE 2300 unit testing library</li> <li><code>test/PairTripleDetector_GL-test.v</code>: test cases for pair/triple detector</li> <li><code>test/PairTripleDetector2_GL-test.v</code>: test cases for two pair/triple detector</li> <li><code>sim/detector2-sim.v</code>: interactive simulator for hardware module</li> </ul> <p>To make it easier to cut-and-paste commands from this handout onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-sec03-verilog-testing/#2-a-simple-makefile","title":"2. A Simple Makefile","text":"<p>We will start by writing a very simple Makefile to automate our work from the last discussion section. Let's copy some files into a temporary directory to enable us to explore a simple makefile.</p> <pre><code>% cd ${HOME}/ece2300/sec03\n% mkdir -p temp\n% cp hw/PairTripleDetector_GL.v temp\n% cp test/ece2300-test.v temp\n% cp test/PairTripleDetector_GL-test.v temp\n</code></pre> <p>Now let's remind ourselves how to lint, build, and run a test simulator for the pair/triple detector from the last discussion section.</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% verilator -Wall --lint-only PairTripleDetector_GL.v\n% iverilog -Wall -g2012 -o PairTripleDetector_GL-test PairTripleDetector_GL-test.v\n% ./PairTripleDetector_GL-test\n</code></pre> <p>Let's now remove the test simulator so we are back to a clean directory.</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% trash PairTripleDetector_GL-test\n</code></pre> <p>Manually performing these steps can be very tedious. We can use a new tool called <code>make</code> which was specifically designed to help automate the process of running a sequence of programs. The key to using <code>make</code> is developing a <code>Makefile</code>. A <code>Makefile</code> is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax:</p> <pre><code>target : prerequisite0 prerequisite1 prerequisite2\n&lt;TAB&gt;command\n</code></pre> <p>A rule specifies how to generate the target file using the list of prerequisite files and the given Linux command. <code>make</code> is smart enough to know it should rerun the command if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist then it needs to look for some other rule to generate that prerequisite first. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters <code>&lt;TAB&gt;</code>, but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces.</p> <p>Let's create a simple <code>Makefile</code> to automate the process of linting an building a test simulator. Use VS Code to create a new file named <code>Makefile</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% code Makefile\n</code></pre> <p>Enter the following content into the <code>Makefile</code>:</p> <pre><code>PairTripleDetector_GL-test : PairTripleDetector_GL.v PairTripleDetector_GL-test.v \n&lt;TAB&gt;verilator -Wall --lint-only PairTripleDetector_GL.v\n&lt;TAB&gt;iverilog -Wall -g2012 -o PairTripleDetector_GL-test PairTripleDetector_GL-test.v\n\nclean:\n&lt;TAB&gt;rm -rf PairTripleDetector_GL-test\n</code></pre> <p>We can use the newly created <code>Makefile</code> like this:</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% make PairTripleDetector_GL-test\n% ./PairTripleDetector_GL-test\n</code></pre> <p><code>make</code> will by default use the <code>Makefile</code> in the current directory. <code>make</code> takes a command line argument specifying what you want \"make\". In this case, we want to make the <code>PairTripleDetector_GL-test</code> simulator. <code>make</code> will look at all of the rules in the <code>Makefile</code> to find a rule that specifies how to make the <code>PairTripleDetector_GL-test</code> simulator. It will then check to make sure the prerequisites exist and that they are up-to-date, and then it will run the command sequence specified in the rule for <code>PairTripleDetector_GL-test</code>. In this case, those commands are <code>verilator</code> and <code>iverilog</code>. <code>make</code> will output to the terminal every command it runs, so you should see it output the command line which uses <code>verilator</code> to lint the design and <code>iverilog</code> to build the <code>PairTripleDetector_GL-test</code> simulator.</p> <p>Try running <code>make</code> again:</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% make PairTripleDetector_GL-test\n% ./PairTripleDetector_GL-test\n</code></pre> <p><code>make</code> detects that the prerequisite (i.e., <code>PairTripleDetector_GL.v</code> and <code>PairTripleDetector_GL-test.v</code>) have not changed and so it does not rebuild the test simulator. Now let's try making a change in the <code>PairTripleDetector_GL.v</code> source file; change the final OR gate to a NOR gate and rebuild and rerun the test simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% make PairTripleDetector_GL-test\n% ./PairTripleDetector_GL-test\n</code></pre> <p><code>make</code> will automatically detect that the prerequesite has changed and rebuild the test simulator appropriately. This ability to automatically track dependencies and rerun just what is necessary is a key benefit of using a tool like <code>make</code>. <code>Makefiles</code> can also include targets which are not actually files. Our example <code>Makefile</code> includes a <code>clean</code> target which will delete any generated simulators. Let's clean up our directory like this:</p> <pre><code>% cd ${HOME}/ece2300/sec03/temp\n% ls\n% make clean\n% ls\n</code></pre> <p>Let's go ahead and remove the temporary directory.</p> <pre><code>% trash ${HOME}/ece2300/sec03/temp\n</code></pre>"},{"location":"ece2300-sec03-verilog-testing/#3-automated-build-system","title":"3. Automated Build System","text":"<p>So far we have been doing all of our work in one directory. We will need a better way to organize our work as we start to develop larger and more complicated hardware modules. In the remaining lab assignments, you will be working with four subdirectories:</p> <ul> <li><code>hw</code> : subdirectory for Verilog hardware design files</li> <li><code>test</code> : subdirectory for Verilog test simulator files</li> <li><code>sim</code> : subdirectory for Verilog interactive simulator files</li> <li><code>build</code> : subdirectory for building/running all simulators</li> </ul> <p>Take a look in the <code>hw</code>, <code>test</code>, and <code>sim</code> directories in your cloned repo. You can see the <code>PairTripleDetector_GL.v</code> file is in the <code>hw</code> subdirectory and the <code>PairTripleDetector_GL-test.v</code> file is in the <code>test</code> subdirectory.</p> <p>From now on, we will always be building all of our simulators in a separate <code>build</code> directory. Keeping simulator executables, trace files, and waveforms separate from the source code is critical to maintaining a clean project. It enables us to easily do a \"clean build\". We can simply trash the build directory and start from scratch. You should never commit and push your build directory to GitHub!</p> <p>We provide you a sophisticated <code>Makefile</code> you will be using in the remaining lab assignments. The <code>Makefile</code> is generated through a configuration step that checks to make sure your environment is setup correctly. Let's go ahead and create a build directory, run configure, and look at the provided <code>Makefile.</code></p> <pre><code>% cd ${HOME}/ece2300/sec03\n% mkdir -p build\n% cd build\n% ../configure\n% code Makefile\n</code></pre> <p>You do not need to understand everything in the <code>Makefile</code>, but just appreciate that it will be a powerful way to automate the process of linting, building, and running our simulators.</p>"},{"location":"ece2300-sec03-verilog-testing/#21-composing-two-pairtriple-detectors","title":"2.1. Composing Two Pair/Triple Detectors","text":"<p>Let's implement a more complicated Verilog hardware module that composes two instances of our pair/triple detector called <code>PairTripleDetector2</code>. It has the following block diagram.</p> <p></p> <p>The <code>PairTripleDetector2</code> has two three-bit input ports and one one-bit output port; it should output a one if either of the input ports contain two or three ones and output a zero otherwise. Go ahead and use VS Code to implement <code>PairTripleDetector2</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% code ../hw/PairTripleDetector2_GL.v\n</code></pre>"},{"location":"ece2300-sec03-verilog-testing/#22-testing-child-modules","title":"2.2. Testing Child Modules","text":"<p>What strategy should we use to test our new composition? The wrong thing to do is to immediately start testing the composition. Instead, we must test and thoroughly verify every child module before doing any kind of integration testing. Let's use the provided <code>Makefile</code> to lint, build, and run the test simulator for the child pair/triple detector.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make PairTripleDetector_GL-test\n% ./PairTripleDetector_GL-test\n</code></pre> <p>You can build and run the test in a single line like this:</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make PairTripleDetector_GL-test &amp;&amp; ./PairTripleDetector_GL-test\n</code></pre> <p>The <code>&amp;&amp;</code> bash operator enables running multiple commands on the same command line. Remember you can \"zoom-in\" to run a single test case with the <code>+test-case</code> command line option.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% ./PairTripleDetector_GL-test +test-case=1\n% ./PairTripleDetector_GL-test +test-case=2\n</code></pre> <p>When you zoom-in the test framework will displace a trace of the inputs and outputs for the design-under-test. You can output waveforms using the <code>+dump-vcd</code> command line option and then open them using the Surfer extension for VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% ./PairTripleDetector_GL-test +test-case=2 +dump-vcd=waves.vcd\n% code waves.vcd\n</code></pre>"},{"location":"ece2300-sec03-verilog-testing/#23-basic-testing","title":"2.3. Basic Testing","text":"<p>Now that we know the child modules are correct, we can do integration testing of the composition. Run the basic tests that we provide for this new composition.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make PairTripleDetector2_GL-test &amp;&amp; ./PairTripleDetector2_GL-test\n</code></pre>"},{"location":"ece2300-sec03-verilog-testing/#24-directed-testing","title":"2.4. Directed Testing","text":"<p>In the previous discussion section, we used exhaustive testing to verify our pair/triple detector. Exhaustive testing is a powerful technique but only applicable to hardware modules with just a few input ports each with just a few bits. The number of exhaustive checks scales exponentially with the number of bits across all input ports. For example, if our hardware module has four eight-bit input ports, we would need <code>2^(8*4)</code> or four billion checks for exhaustive testing!</p> <p>We can use directed testing in situations where exhaustive testing is not possible. In directed testing, we focus on including checks for as many interesting input values as possible. We usually organize directed testing into many test cases, where each test case is focusing on a different kinds of input values we are interested in testing. For <code>PairTripleDetector2</code>, we might want a directed test case that focuses on input values with a few ones and a different directed test case that focuses on input values with many ones. Go ahead and add appropriate checks to <code>test_case_2_few_ones</code> and <code>test_case_3_many_ones</code> in <code>PairTripleDetector2_GL-test.v</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% code ../test/PairTripleDetector2_GL-test.v\n</code></pre> <p>Then rebuild and rerun the test simulator using <code>make</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make PairTripleDetector2_GL-test &amp;&amp; ./PairTripleDetector2_GL-test\n</code></pre> <p>Zoom-in on each of these two test cases to see the trace output.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% ./PairTripleDetector2_GL-test +test-case=2\n% ./PairTripleDetector2_GL-test +test-case=3\n</code></pre>"},{"location":"ece2300-sec03-verilog-testing/#25-random-testing","title":"2.5. Random Testing","text":"<p>Directed testing is a good first step, but how do we know if we have covered all of the corner cases? We can use random testing to help increase our confidence that we have not missed any important corner cases. Random testing involves generating random input values, determing the correct output given these random input values, applying these random input values to the design-under-test, and then verifying that the design-under-test produces the correct output values.</p> <p>Here is an example of a random test case for our <code>PairTripleDetector2</code> module:</p> <pre><code>  logic [2:0] random_a;\n  logic [2:0] random_b;\n  logic       random_out;\n  int         random_a_num_ones;\n  int         random_b_num_ones;\n\n  task test_case_4_random();\n    t.test_case_begin( \"test_case_4_random\" );\n\n    // Generate 20 random input values\n\n    for ( int i = 0; i &lt; 20; i = i+1 ) begin\n\n      // Generate a 3-bit random value for both a and b\n\n      random_a = 3'($urandom(t.seed));\n      random_b = 3'($urandom(t.seed));\n\n      // Calculate the number of ones in random value a\n\n      random_a_num_ones = 0;\n      for ( int j = 0; j &lt; 3; j = j+1 ) begin\n        if ( random_a[j] )\n          random_a_num_ones = random_a_num_ones + 1;\n      end\n\n      // Calculate the number of ones in random value b\n\n      random_b_num_ones = 0;\n      for ( int j = 0; j &lt; 3; j = j+1 ) begin\n        if ( random_b[j] )\n          random_b_num_ones = random_b_num_ones + 1;\n      end\n\n      // Calculate the correct output value\n\n      random_out = (random_a_num_ones &gt; 1) || (random_b_num_ones &gt; 1);\n\n      // Apply the random input values and check the output value\n\n      check( random_a, random_b, random_out );\n\n    end\n\n  endtask\n</code></pre> <p>Recall that Verilog can be used to both design hardware and also to test hardware. Very different constructs should be used when designing vs. testing hardware. Here we are clearly using Verilog constructs (e.g., <code>$urandom</code>, for loops, etc) that are not suitable for modeling hardware.</p> <p>The random test generates two random 3-bit values using the <code>$urandom</code> system task. We pass in <code>t.seed</code> to ensure our random tests are actually \"pseudo-random\", i.e., the test case will always produce the same sequence of random values. This way if a random test case fails we can rerun the test case to debug it without worrying that the failure will go away due to different random input values. We then include Verilog behavioral code to determine the correct answer; we use two for loops to count the number of ones in each random 3-bit value. Once we know the number of ones in each random 3-bit value, we can determine what the correct output should be for the design-under-test.</p> <p>Copy and paste this new test case into <code>PairTripleDetector2_GL-test.v</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% code ../test/PairTripleDetector2_GL-test.v\n</code></pre> <p>Then add this new test case to the list of test cases in the <code>initial</code> block like this:</p> <pre><code>  initial begin\n    t.test_bench_begin( `__FILE__ );\n\n    if ((t.n &lt;= 0) || (t.n == 1)) test_case_1_basic();\n    if ((t.n &lt;= 0) || (t.n == 2)) test_case_2_few_ones();\n    if ((t.n &lt;= 0) || (t.n == 3)) test_case_3_many_ones();\n    if ((t.n &lt;= 0) || (t.n == 4)) test_case_4_random();\n\n    t.test_bench_end();\n  end\n</code></pre> <p>Now rebuild and rerun the test simulator. Verify that your new random test case is running.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make PairTripleDetector2_GL-test &amp;&amp; ./PairTripleDetector2_GL-test\n% ./PairTripleDetector2_GL-test +test-case=4\n</code></pre> <p>It is always useful to try and break your code to make sure your test cases really are testing what you think they are. Replace the OR gate in <code>PairTripleDetector2_GL</code> with an AND gate. Do your directed tests catch this bug? If your directed tests do not catch a bug but your random tests do catch a bug, then you want to add a new directed test case that tests for this behavior. In fact, adding a new directed test case to reproduce a bug caught during randoming testing is the best way to start debugging a random test case failure. If the bug was caught by your random test, but not your directed test cases, go ahead and add a new directed test case that will catch this bug.</p>"},{"location":"ece2300-sec03-verilog-testing/#26-running-all-tests","title":"2.6. Running All Tests","text":"<p>The provided <code>Makefile</code> provides a <code>check</code> target which will build and run all test simulators in a single step.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make check\n</code></pre> <p>Note that this should only be used to produce a high-level overview of which test simulators are passing and which test simulators are failing. You should not just always type <code>make check</code>. You should \"zoom-in\" and build and run a single test simulator for which ever hardware module you are currently working on. Periodically run <code>make check</code> to get a high-level overview.</p>"},{"location":"ece2300-sec03-verilog-testing/#3-interactive-simulators","title":"3. Interactive Simulators","text":"<p>Once we have finished testing our hardware design, we can use an interactive simulator to experiment with the design. The source files for our interactive simulators will be in the <code>sim</code> subdirectory. Take a look at the provided <code>detector2-sim.v</code> interactive simulator.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% code ../sim/detector2-sim.v\n</code></pre> <p>You can build the simple interactive simulator by simply specifying it as a target:</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% make detector2-sim\n</code></pre> <p>Then you can specify the input values for <code>a</code> and <code>b</code> on the command line.</p> <pre><code>% cd ${HOME}/ece2300/sec03/build\n% ./detector2-sim +a=000 +b=000\n% ./detector2-sim +a=001 +b=000\n% ./detector2-sim +a=000 +b=001\n% ./detector2-sim +a=111 +b=111\n</code></pre> <p>Note that an interactive simulator is not for testing. Using an interactive simulator is neither systematic nor automatic. One should only start experimenting with an interactive simulator once a hardware module has been thoroughly tested using a combination of basic, exhaustive, directed, and/or random testing!</p>"},{"location":"ece2300-sec04-lab2-head-start/","title":"Section 4: Lab 2 Head Start","text":"<p>In this discussion section you will use what you have learned in the previous discussion sections to get started on Lab 2. By the end of this discussion section, you will have implemented a full adder, tested the full adder using exhaustive testing, implemented a four-bit ripple-carry adder, and tested the ripple-carry adder using directed and random testing. Feel free to copy any code you would like from your work in this discussion section into your lab group repo.</p>"},{"location":"ece2300-sec04-lab2-head-start/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as previous discussion sections. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>There is no need to fork the repo for today's discussion section. Simple clone the repo as follows.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:cornell-ece2300/ece2300-sec04-lab2-head-start sec04\n% cd sec04\n% tree\n</code></pre> <p>The repo includes the following files:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> <li><code>hw/FullAdder_GL.v</code>: Verilog for full adder</li> <li><code>hw/AdderRippleCarry_4b_GL.v</code>: Verilog for four-bit ripple-carry adder</li> <li><code>test/ece2300-test.v</code>: ECE 2300 unit testing library</li> <li><code>test/FullAdder_GL-test.v</code>: test cases for full adder</li> <li><code>test/AdderRippleCarry_4b_GL-test.v</code>: test cases for four-bit ripple-carry adder</li> </ul> <p>Go ahead and create a build directory and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/sec04\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>To make it easier to cut-and-paste commands from this handout onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-sec04-lab2-head-start/#2-implementing-a-full-adder","title":"2. Implementing a Full Adder","text":"<p>A full adder adds three one bit binary values and produces a two-bit binary output.</p> <p></p> <p>Review your notes from lecture and fill out the following truth table for a full adder. Make sure you completely understand this truth table before continuing.</p> in0 in1 cin cout sum 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 <p>We now want to implement this truth table in a Verilog hardware module. We have provided you with the interface for a full adder in <code>FullAdder_GL.v</code>.</p> <pre><code>module FullAdder_GL\n(\n  (* keep=1 *) input  wire in0,\n  (* keep=1 *) input  wire in1,\n  (* keep=1 *) input  wire cin,\n  (* keep=1 *) output wire cout,\n  (* keep=1 *) output wire sum\n);\n</code></pre> <p>The module has three input ports and two output ports. Notice we are using the special <code>(* keep=1 *)</code> Verilog attribute with every port. Without this attribute, the FPGA tools will \"flatten\" your entire design (i.e., eliminate all module boundries) during the synthesis process. While this can enable improved optimizations, it also complicates analyzing the area and timing of your design. The <code>(* keep=1 *)</code> attribute tells the FPGA tools to preserve the module hierarchy. We will use <code>(* keep=1 *)</code> on all ports for Lab 2-4 and explore the potential benefit of flattening in Lab 5. Open the <code>FullAdder_GL.v</code> Verilog file using VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% code ../hw/FullAdder_GL.v\n</code></pre> <p>Activity 1: Implement a Full Adder</p> <p>Complete the truth table for a full adder. Create a Verilog hardware design that implements a full adder using the logic gate or boolean equation layers of abstraction.</p>"},{"location":"ece2300-sec04-lab2-head-start/#3-testing-a-full-adder","title":"3. Testing a Full Adder","text":"<p>After implementing any Verilog hardware module, your next task must always be to test that Verilog hardware module. Never attempt to use a Verilog hardware module before thoroughly testing its functionality! Since our full adder only has eight possible input values, we can use exhaustive testing to verify its functionality.</p> <p>We have provided you a Verilog test bench in <code>FullAdder_GL-test.v</code> with a basic test case named <code>test_case_1_basic</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% code ../test/FullAdder_GL-test.v\n</code></pre> <p>Activity 2: Test the Full Adder</p> <p>Use your truth table to add checks to implement exhaustive testing in the test case named <code>test_case_2_exhaustive</code>.</p> <p>Once you have finished writing your exhaustive test case, you can build and run the test simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% make FullAdder_GL-test\n% ./FullAdder_GL-test\n% ./FullAdder_GL-test +test-case=2\n</code></pre>"},{"location":"ece2300-sec04-lab2-head-start/#4-implementing-a-ripple-carry-adder","title":"4. Implementing a Ripple-Carry Adder","text":"<p>A ripple-carry adder chains together full adders to implement a multi-bit binary adder. For example, we can chain four full adders together to implement a four-bit binary adder.</p> <p></p> <p>Review your notes from lecture to fill in the following simulation table for the four-bit ripple carry adder.</p> in0 in1 cin carry0 carry1 carry2 cout sum 0000 0000 0 0001 0001 0 0001 0001 1 0011 0011 0 <p>We now want to implement this ripple-carry adder in a Verilog hardware module. We have provided you with the interface for the adder in <code>AdderRippleCarry_4b_GL.v</code>.</p> <pre><code>module AdderRippleCarry_4b_GL\n(\n  (* keep=1 *) input  wire [3:0] in0,\n  (* keep=1 *) input  wire [3:0] in1,\n  (* keep=1 *) input  wire       cin,\n  (* keep=1 *) output wire       cout,\n  (* keep=1 *) output wire [3:0] sum\n);\n</code></pre> <p>Notice that we are using multi-bit input and output ports. The block diagram illustrates how we can \"slice\" the bus to connect each bit of the multi-input ports to a different instances of the full adder module. The carry chain is implemented using wires to connect the carry out of one full adder to the carry in of the next full adder.</p> <p>Take a minute to reflect on our use of the three abstraction principles: modularity: our ripple carry adder has a well-defined port-based interface; hierarchy: we have decomposed our ripple carry adder into a full adder module; and regularity: we have reused the same full adder four times to implement the ripple carry adder.</p> <p>Open the <code>AdderRippleCarry_4b_GL.v</code> Verilog file using VS Code.</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% code ../hw/AdderRippleCarry_4b_GL.v\n</code></pre> <p>Activity 3: Implement a Ripple Carry Adder</p> <p>Complete the simulation table for the ripple carry adder. Implement the ripple carry adder by instantiating four full adders and connecting the appropriately.</p>"},{"location":"ece2300-sec04-lab2-head-start/#5-testing-a-ripple-carry-adder","title":"5. Testing a Ripple-Carry Adder","text":"<p>Since we have already thoroughly unit tested our full adder, we can now focus on integration testing for our four-bit ripple-carry adder. Our four-bit ripple carry adder has a total of <code>2^9</code> or 512 possible input values which means exhaustive testing is not really feasible. We will need to use directed and random testing to verify the functionality of the ripple-carry adder.</p> <p>We have provided you a Verilog test bench in <code>AdderRippleCarry_4b_GL-test.v</code> with a basic test case named <code>test_case_1_basic</code>.</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% code ../test/AdderRippleCarry_4b_GL-test.v\n</code></pre> <p>Activity 4: Directed Testing for Ripple-Carry Adder</p> <p>Add multiple directed test cases. Each directed test case should be designed to test a specific behavior. For example, you might want to write the following test cases:</p> <ul> <li>Test inputs where cin is zero and cout is zero</li> <li>Test inputs where cin is one and cout is zero</li> <li>Test inputs where cin is zero and cout is one</li> <li>Test inputs where cin is one and cout is one</li> <li>Test inputs where every carry bit is one</li> </ul> <p>After writing each directed test case, build and run the test simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% make AdderRippleCarry_4b_GL-test &amp;&amp; ./AdderRippleCarry_4b_GL-test\n</code></pre> <p>Once you have finished writing and running your directed test cases, move on to random testing. Review what we learned in the previous discussion section about how to write random tests. There are a couple of hints that might be useful as you write the Verilog code to determine the correct answer given random inputs.</p> <p>First, you can use the <code>+</code> operator to perform addition in Verilog. Here is a toy example that you can experiment with using <code>iverilog</code> or EDA Playground.</p> <pre><code>module Top();\n\n  logic [3:0] a;\n  logic [3:0] b;\n  logic [3:0] sum;\n\n  initial begin\n\n    a = 4'd3;\n    b = 4'd7;\n\n    sum = a + b;\n\n    $display( \"%d + %d = %d\", a, b, sum );\n\n  end\n\nendmodule\n</code></pre> <p>Second, Verilator will complain if you attempt to add signals of different bitwidths; you can zero-extend signals to ensure they are all the same bitwidth using the Verilog concatenation operator (<code>{}</code>). Here is a toy example that you can experiment with using <code>iverilog</code> or EDA Playground.</p> <pre><code>module Top();\n\n  logic [3:0] a;\n  logic       b;\n  logic [3:0] sum;\n\n  initial begin\n\n    a = 4'd7;\n    b = 1'b1;\n\n    sum = a + {3'b0,b};\n\n    $display( \"%d + %d = %d\", a, b, sum );\n\n  end\n\nendmodule\n</code></pre> <p>Third, if you add two four-bit signals and write the result to a four-bit signal you cannot check the final carry out; if you add two four-bit signals and write the result to a five-bit signal then the most-significant bit of the output is the final carry out. Here is a toy example that you can experiment with using <code>iverilog</code> or EDA Playground.</p> <pre><code>module Top();\n\n  logic [3:0] a;\n  logic [3:0] b;\n  logic [4:0] result;\n  logic       cout;\n  logic [3:0] sum;\n\n  initial begin\n\n    a = 4'd15;\n    b = 4'd3;\n\n    result = a + b;\n    cout   = result[4];\n    sum    = result[3:0];\n\n    $display( \"%d + %d = %d (cout = %b)\", a, b, sum, cout );\n\n  end\n\nendmodule\n</code></pre> <p>Activity 5: Random Testing for Ripple-Carry Adder</p> <p>Use the above hints to write a random test case for your four-bit ripple-carry adder. Choosing iterations of random values seems reasonable.</p> <p>After writing a random test case, build and run the test simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/sec04/build\n% make AdderRippleCarry_4b_GL-test &amp;&amp; ./AdderRippleCarry_4b_GL-test\n</code></pre>"},{"location":"ece2300-sec04-lab2-head-start/#6-clean-build","title":"6. Clean Build","text":"<p>As a final step, do a clean build to verify everything is working correctly.</p> <pre><code>% cd ${HOME}/ece2300/sec04\n% trash build\n% mkdir -p build\n% cd build\n% ../configure\n% make check\n</code></pre>"},{"location":"ece2300-sec05-verilog-rtl/","title":"Section 5: Verilog Combinational RTL Design","text":"<p>In the past discussion sections, we have learned how to model hardware at the gate-level (GL). In this discussion section, you will learn a new approach to modeling hardware using Verilog at the register-transfer level (RTL). By the end of this discussion section, you will have explore both a GL and RTL implementation of an absolute difference unit. RTL modules are usually implemented at a much higher level of abstraction compared to GL models. This improves designer productivity and gives the FPGA tools more flexibility in optimizing the final hardware, but it also means the designer might not fully understand the final hardware and has less control over the details of the final hardware. This is a key trade-off we will need to balance carefully when using RTL modeling. It is also possible to write RTL models that cannot map to any kind of reasonable hardware. It is critical that students always know what is the hardware they are modeling whether they are working at the gate- or register-transfer level.</p>"},{"location":"ece2300-sec05-verilog-rtl/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as previous discussion sections. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>There is no need to fork the repo for today's discussion section. Simple clone the repo as follows.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:cornell-ece2300/ece2300-sec05-verilog-rtl sec05\n% cd sec05\n% tree\n</code></pre> <p>The repo includes the following files:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> <li><code>hw/FullSubtractor_GL.v</code>: One-bit full subtractor at gate level</li> <li><code>hw/SubtractorRippleCarry_4b_GL.v</code>: Four-bit ripple-carry subtractor at gate level</li> <li><code>hw/GTComparator_1b_GL.v</code>: One-bit greater-than comparator at gate level</li> <li><code>hw/GTComparator_4b_GL.v</code>: Four-bit greater-than comparator at gate level</li> <li><code>hw/Mux2_1b_GL.v</code>: One-bit two-to-one multiplexor at gate level</li> <li><code>hw/Mux2_4b_GL.v</code>: Four-bit two-to-one multiplexor at gate level</li> <li><code>hw/AbsDiff_4b_GL.v</code>: Absolute difference unit at gate level</li> <li><code>hw/Subtractor_4b_RTL.v</code>: Four-bit subtractor at register-transfer level</li> <li><code>hw/GTComparator_4b_RTL.v</code>: Four-bit greater-than comparator at register-transfer level</li> <li><code>hw/Mux2_4b_RTL.v</code>: Four-bit two-to-one multiplexor at register-transfer level</li> <li><code>hw/AbsDiff_4b_RTL.v</code>: Absolute difference unit at register-transfer level</li> <li><code>test</code>: Directory with unit tests for each hardware module</li> <li><code>sim/mux-rtl-sim.v</code>: interactive simulator for experimenting with mux RTL modeling</li> </ul> <p>Go ahead and create a build directory and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/sec05\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>To make it easier to cut-and-paste commands from this handout onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-sec05-verilog-rtl/#2-absolute-difference-unit-interface","title":"2. Absolute Difference Unit Interface","text":"<p>We will be implementing an absolute difference unit using both GL and RTL modeling. Both implementations will have similar interfaces. The GL interface is as follows:</p> <pre><code>module AbsDiff_4b_GL\n(\n  (* keep=1 *) input  wire [3:0] in0,\n  (* keep=1 *) input  wire [3:0] in1,\n  (* keep=1 *) output wire [3:0] diff\n);\n</code></pre> <p>The RTL interface as the same ports and bitwidths, except instead of declaring these ports as <code>wire</code> we declare them with <code>logic</code>. In RTL modeling, we will always use <code>logic</code> for both ports and internal signals.</p> <pre><code>module AbsDiff_4b_RTL\n(\n  (* keep=1 *) input  logic [3:0] in0,\n  (* keep=1 *) input  logic [3:0] in1,\n  (* keep=1 *) output logic [3:0] diff\n);\n</code></pre> <p>The absolute difference unit takes as input two four-bit unsigned binary numbers and outputs the corresponding absolute difference on the <code>diff</code> output port.</p>"},{"location":"ece2300-sec05-verilog-rtl/#2-gate-level-implementation-of-absolute-difference-unit","title":"2. Gate-Level Implementation of Absolute Difference Unit","text":"<p>We have provided you a gate-level implementation of an absolute difference unit in these files:</p> <ul> <li><code>hw/FullSubtractor_GL.v</code></li> <li><code>hw/SubtractorRippleCarry_4b_GL.v</code></li> <li><code>hw/GTComparator_1b_GL.v</code></li> <li><code>hw/GTComparator_4b_GL.v</code></li> <li><code>hw/Mux2_1b_GL.v</code></li> <li><code>hw/Mux2_4b_GL.v</code></li> <li><code>hw/AbsDiff_4b_GL.v</code></li> </ul> <p>Activity 1: Draw Block Diagram of Gate-Level Absolute Difference Unit</p> <p>Inspect the above files and draw a detailed block diagram of how all of the blocks are instantiated and connected. Use a top-down approach (i.e., start from the <code>AbsDiff_4b_GL</code> module and work down to the logic gates in the <code>FullSubtractor_GL</code>, <code>GTComparator_1b_GL</code>, and <code>Mux2_1b_GL</code> modules). You must be able to point to the actual AND, OR, NOT, etc gates in your diagram.</p>"},{"location":"ece2300-sec05-verilog-rtl/#3-rtl-implementation-of-building-blocks","title":"3. RTL Implementation of Building Blocks","text":"<p>In this section, we will experiment with RTL implementations of the key building blocks that make-up the absolute difference detector: a four-bit greater-than comparator, a four-bit subtractor, and a four-bit two-to-one multiplexor.</p>"},{"location":"ece2300-sec05-verilog-rtl/#31-rtl-implementation-of-four-bit-subtractor","title":"3.1. RTL Implementation of Four-Bit Subtractor","text":"<p>In Verilog GL modeling, we must explicitly instantiate gates. When writing Verilog Boolean equations, we can use the <code>assign</code> statement along with a limited number of operators (i.e., <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>). The most basic form of RTL modeling simply enables designers to use more complex operators in an <code>assign</code> statement. For example, we can implement a greater-than comparator by simply using the <code>-</code> operator.</p> <p>Open the <code>Subtractor_4b_RTL.v</code> file and implement the subtractor using RTL modeling like this:</p> <pre><code>  assign {bout,diff} = in0 - in1 - {3'b0,bin};\n</code></pre> <p>Notice how this implementation correctly hands both the borrow in and the borrow out. Run all of the provide tests to verify your implementation.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make Subtractor_4b_RTL-test\n% ./Subtractor_4b_RTL-test +test-case=-1\n</code></pre> <p>Notice how simple the RTL implementation is compared to the GL implementation. An RTL implementation enables the designer to express the subtractor at a very high level, and then trust that the FPGA tools will be able to choose an appropriate subtractor hardware implementation. Of course the downside is the designer has less control over what specific subtractor hardware implementation is actually used on the FPGA.</p> <p>In addition to more complex operators in <code>assign</code> statements, RTL modeling also enables designers to use an <code>always_comb</code> block to express operations. For example, the following <code>always_comb</code> block is equivalent to the above <code>assign</code> statement.</p> <pre><code>  always_comb begin\n    {bout,diff} = in0 - in1 - {3'b0,bin};\n  end\n</code></pre> <p>Any operations that are valid for use with an <code>assign</code> statement are also valid within an <code>always)comb</code> block. In this course, we require students to use <code>always_comb</code> when modeling combinational logic. Never use the <code>always</code> keyword on its own to model combinational logic.</p> <p>The real power of an <code>always_comb</code> block is that it enables expressing a sequence of operations that are executed sequentially (unlike <code>assign</code> statements which execute in parallel). The following example illustrates modeling a subtractor with a sequence of four operations in an <code>always_comb</code> block.</p> <pre><code>  logic [4:0] temp;\n  always_comb begin\n    temp = in0 - in1;\n    temp = temp - {3'b0,bin};\n    bout = temp[4];\n    diff = temp[3:0];\n  end\n</code></pre> <p>We first subtract <code>in1</code> from <code>in0</code> and store the result in a temporary signal. We then subtract the borrow input and store the result back in the temporary signal. Then we can extract the most-significant bit as the borrow output and the remaining bits as the difference.</p> <p>Open the <code>Subtractor_4b_RTL.v</code> file and change your implementation of the subtractor to use <code>always_comb</code> block. Run all of the provide tests to verify your implementation. Note that you might get notifications from <code>iverilog</code> that \"constant selects are not currently supported\". It is safe to ignore this notification.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make Subtractor_4b_RTL-test\n% ./Subtractor_4b_RTL-test +test-case=-1\n</code></pre>"},{"location":"ece2300-sec05-verilog-rtl/#32-rtl-implementation-of-four-bit-greater-than-comparator","title":"3.2. RTL Implementation of Four-Bit Greater-Than Comparator","text":"<p>An RTL model of the greater-than comparator can use the RTL <code>&gt;</code> operator. Open the <code>GTComporator_4b_RTL.v</code> file and change your implementation of the subtractor to use the <code>&gt;</code> operator in either an <code>assign</code> statement or <code>always_comb</code> block. Run all of the provided tests to verify your implementation.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make GTComparator_4b_RTL-test\n% ./GTComparator_4b_RTL-test +test-case=-1\n</code></pre>"},{"location":"ece2300-sec05-verilog-rtl/#33-rtl-implementation-of-four-bit-two-to-one-multiplexor","title":"3.3. RTL Implementation of Four-Bit Two-to-One Multiplexor","text":"<p>An RTL model of a multiplexors can use the ternary operator. Open the <code>Mux2_4b_RTL.v</code> file and implement the subtractor using RTL modeling like this:</p> <pre><code>  assign out = ( sel ) ? in1 : in0;\n</code></pre> <p>If the expression in the parentheses evaluates to one, then we assign <code>in1</code> to the output. If the expression in the parentheses evaluates to zero, then we assign <code>in0</code> to the output.</p> <p>Run all of the provide tests to verify your implementation.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make Mux2_4b_RTL-test\n% ./Mux2_4b_RTL-test +test-case=-1\n</code></pre> <p>You can use ternary operators in an <code>always_comb</code> block, but an <code>always_comb</code> block also enables using more traditional <code>if</code>/<code>else</code> conditional operations.</p> <p>Open the <code>Mux2_4b_RTL.v</code> file and implement the subtractor using RTL modeling like this:</p> <pre><code>  always_comb begin\n    if ( sel == 0 )\n      out = in0;\n    else\n      out = in1;\n  end\n</code></pre> <p>Run all of the provide tests to verify your implementation.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make Mux2_4b_RTL-test\n% ./Mux2_4b_RTL-test +test-case=-1\n</code></pre>"},{"location":"ece2300-sec05-verilog-rtl/#33-subtle-issues-with-using-ifelse-in-rtl-modeling","title":"3.3. Subtle Issues with Using If/Else in RTL Modeling","text":"<p>There are two critically important yet subtle issues that arise when using <code>if</code>/<code>else</code> conditional operations in <code>always_comb</code> blocks. We have provided you a simple interactive simulator that will enable us to explore these two issues. You can build and run the interactive simulator like this:</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make mux-rtl-sim\n% ./mux-rtl-sim +in0=0101 +in1=1111 +sel=0\n% ./mux-rtl-sim +in0=0101 +in1=1111 +sel=1\n</code></pre> <p>Let's assume we accidentally forget to include the <code>else</code> clause in our <code>always_comb</code> block. Go ahead and update your implementation to look like this:</p> <pre><code>  always_comb begin\n    if ( sel == 0 )\n      out = in0;\n  end\n</code></pre> <p>Then rebuild the interactive simulator.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make mux-rtl-sim\n</code></pre> <p><code>verilator</code> will complain that <code>in1</code> is not used, but more importantly notice how <code>verilator</code> is warning about an inferred latch. The above RTL mode actually does not model combinational logic. It models sequential logic. The signal <code>out</code> is no longer a function of just the inputs <code>sel</code> and <code>in0</code>. If <code>sel</code> is first zero and is then changed to one, the hardware must remember what was the previous value of <code>out</code> so that it stays the same even if <code>in0</code> changes. Inferred latches can cause all kinds of subtle bugs which is why we are using an <code>always_comb</code> block so <code>verilator</code> can detect inferred latches. To avoid inferred latches ensure that any signal written in an <code>always_comb</code> block is always written no matter what path we take through <code>if</code>/<code>else</code> conditional operators.</p> <p>Go ahead and update your implementation as it was before:</p> <pre><code>  always_comb begin\n    if ( sel == 0 )\n      out = in0;\n    else\n      out = in1;\n  end\n</code></pre> <p>Now let's experiment with what happens when one of our inputs is undefined (i.e., is modeled using an <code>X</code> in Verilog). Try these inputs.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make mux-rtl-sim\n% ./mux-rtl-sim +in0=xxxx +in1=1111 +sel=0\n% ./mux-rtl-sim +in0=xxxx +in1=1111 +sel=1\n% ./mux-rtl-sim +in0=0101 +in1=xxxx +sel=0\n% ./mux-rtl-sim +in0=0101 +in1=xxxx +sel=1\n% ./mux-rtl-sim +in0=0101 +in1=1111 +sel=x\n</code></pre> <p>Are the results as expected? Prof. Batten will talk more about <code>X</code> propagation and how to ensure <code>X</code> values are correctly propagated through your RTL models.</p>"},{"location":"ece2300-sec05-verilog-rtl/#4-rtl-implementation-of-absolute-difference-unit","title":"4. RTL Implementation of Absolute Difference Unit","text":"<p>Now that we have RTL models of our building blocks, we can create an RTL model for the entire absolute difference unit.</p> <p>Let's start with a structural RTL model. Open <code>AbsDiff_4b_GL.v</code> and copy the structural implementation into <code>AbsDiff_4b_RTL.v</code>. Change the building blocks to all be the RTL implementation. Then rerun all the tests to verify that your structural RTL modeling is functionally correct.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make AbsDiff_4b_RTL-test\n% ./AbsDiff_4b_RTL-test +test-case=-1\n</code></pre> <p>Notice how structural RTL modeling like this provides a nice balance between productive modeling and control over the hardware implementation. We can let the FPGA tools optimize each building block individually, but we still get explicit control over how these building blocks are composed.</p> <p>We can also use a flat RTL model which does not instantiate any building blocks at all, but instead simply uses a single <code>always_comb</code> block to model the entire absolute difference unit. Open <code>AbsDiff_4b_RTL.v</code> and change the RTL implementation to be as follows:</p> <pre><code>  always_comb begin\n    if ( in0 &gt; in1 )\n      diff = in0 - in1;\n    else\n      diff = in1 - in0;\n  end\n</code></pre> <p>Then rerun all the tests to verify that your structural RTL modeling is functionally correct.</p> <pre><code>% cd ${HOME}/ece2300/sec05/build\n% make AbsDiff_4b_RTL-test\n% ./AbsDiff_4b_RTL-test +test-case=-1\n</code></pre> <p>Notice how flat RTL modeling enables the designer to express their intent at a very high level, but the designer now has very little control over the final hardware implementation. Not only will the FPGA tools optimize the building blocks, but hopefully the FPGA tools will realize an implementation only needs a single subtractor. When using flat RTL modeling we have lost much of the intuition about the hardware implementation that was so explicit in our GL modeling and still somewhat present in our structural RTL modeling. Students will need to carefully navigate the tension between productivity and control when developing gate-level models, boolean equation models, structural RTL models, and flat RTL models.</p>"},{"location":"ece2300-sec05-verilog-rtl/#5-clean-build","title":"5. Clean Build","text":"<p>As a final step, do a clean build to verify everything is working correctly.</p> <pre><code>% cd ${HOME}/ece2300/sec05\n% trash build\n% mkdir -p build\n% cd build\n% ../configure\n% make check\n</code></pre>"},{"location":"ece2300-sec06-lab3-head-start/","title":"Section 6: Lab 3 Head Start","text":"<p>In this discussion section you will use what you have learned in the previous discussion sections to get started on Lab 3. You will start by implementing a D latch, D flip-flop, D flip-flop with reset and enable, and a 8-bit register all at the gate-level. You will then implement a parameterized multi-bit register and simple counter at the register-transfer level. Feel free to copy any code you would like from your work in this discussion section into your lab group repo.</p> <p>In the past discussion sections, we have focused on how to use Verilog to model combinational logic at both the gate-level and register-transfer-level (RTL). In this discussion section, we will learn how to use Verilog to model sequential logic. Gate-level modeling of sequential logic largely uses similar syntax and semantics to modeling combinational logic at the gate level, but RTL modeling of sequential logic will require new syntax and semantics which we will need to understand and use carefully. Remember from last discussion section that it is critical that students always know what is the hardware they are modeling whether they are working at the gate- or register-transfer level.</p>"},{"location":"ece2300-sec06-lab3-head-start/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as previous discussion sections. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>There is no need to fork the repo for today's discussion section. Simple clone the repo as follows.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:cornell-ece2300/ece2300-sec06-lab3-head-start sec06\n% cd sec06\n% tree\n</code></pre> <p>The repo includes the following files:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> <li><code>Adder_8b_RTL.v</code>: 8-bit RTL adder (copy from lab 2)</li> <li><code>Mux2_1b_GL.v</code>: 8-bit RTL adder (copy from lab 2)</li> <li><code>DLatch_GL.v</code>: 1-bit D latch at gate-level</li> <li><code>DFF_GL.v</code>: 1-bit D flip-flop at gate-level</li> <li><code>DFFRE_GL.v</code>: 1-bit D flip-flop with reset and enable at gate-level</li> <li><code>Register_8b_GL.v</code>: 8-bit register with reset and enable at gate-level</li> <li><code>Register_RTL.v</code>: Parameterized register with reset and enable at RTL</li> <li><code>SimpleCounter_8b_RTL.v</code>: Simple counter that counts up in structural RTL</li> <li><code>test</code>: Directory with unit tests for each hardware module</li> </ul> <p>Go ahead and create a build directory and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/sec06\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>To make it easier to cut-and-paste commands from this handout onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-sec06-lab3-head-start/#2-mux-and-adder-from-lab-2","title":"2. Mux and Adder from Lab 2","text":"<p>Copy your 1-bit 2-to-1 multiplexor and your 8-bit RTL adder from Lab 2 into the <code>hw</code> directory for this discussion section. Verify that these hardware modules are working.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make Mux2_1b_GL-test\n% make Adder_8b_RTL-test\n% ./Mux2_1b_GL-test\n% ./Adder_8b_RTL-test\n</code></pre>"},{"location":"ece2300-sec06-lab3-head-start/#3-implementing-and-testing-d-latch-d-flip-flops-and-register","title":"3. Implementing and Testing D Latch, D Flip-Flops, and Register","text":"<p>We will start by exploring how to implement and test three different single-bit sequential logic gates: D latch, D flip-flop, and a D flip-flop with reset and enable.</p>"},{"location":"ece2300-sec06-lab3-head-start/#31-d-latch","title":"3.1 D Latch","text":"<p>A D latch has a data input (<code>d</code>) and a clock input (<code>clk</code>) and one output (<code>q</code>). A D latch is transparent when the clock is one (i.e., the input passes directly to the output) and is opaque with the clock is zero (i.e., the latch \"remembers\" the value right before the clock transitioned to zero and holds this value while the latch is opaque).</p> <p>We have provided you the interface a D latch in <code>DLatch_GL.v</code> and a test bench in <code>DLatch_GL-test.v</code>. For the test bench, we have provided you a template for an exhaustive test case; all you need to do is fill in the correct output values for each provided check. Notice that our checks look exactly like the simulation tables we have studied in lecture with an explicit column for the clock signal. You can test the D latch as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make DLatch_GL-test\n% ./DLatch_GL-test\n</code></pre> <p>Activity 1: Implement and Test D Latch</p> <p>Create a Verilog hardware design that implements a D latch using the explicit gate-level modeling (do not use Boolean logic equations). Finish the test bench and verify that your D latch is functionally correct.</p>"},{"location":"ece2300-sec06-lab3-head-start/#32-d-flip-flop","title":"3.2 D Flip-Flop","text":"<p>A D flip-flop has a data input (<code>d</code>) and a clock input (<code>clk</code>) and one output (<code>q</code>). Unlike a D latch, a D flip-flop is never transparent. A D flip-flop samples its input right before the positive edge of the clock and then holds this value for the entire clock period until the next rising edge. We can implement a D flip-flop with two latches: a leader latch and a follower latch. The leader latch uses the complement of the clock so that only one latch is ever transparent on either phase of the clock.</p> <p>We have provided you the interface a D flip-flop in <code>DFF_GL.v</code> and a test bench in <code>DFF_GL-test.v</code>. For the test bench, we have provided you a template for an exhaustive test case; all you need to do is fill in the correct output values for each provided check. You can test the D flip-flop as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make DFF_GL-test\n% ./DFF_GL-test\n</code></pre> <p>Activity 2: Implement and Test D Flip-Flop</p> <p>Create a Verilog hardware design that implements a D flip-flop by instantiating two D latches and connecting them appropriately. You will also need a NOT gate (do not use Boolean logic equations). Finish the test bench and verify that your D flip-flop is functionally correct.</p>"},{"location":"ece2300-sec06-lab3-head-start/#33-d-flip-flop-with-reset-and-enable","title":"3.3 D Flip-Flop with Reset and Enable","text":"<p>We can also add a reset (<code>rst</code>) and enable (<code>en</code>) to our D flip-flop. The reset signal is used to reset the D flip-flop to a known value. In our case we will reset the flip-flop to zero. The enable signal is used to decided whether or not the flip-flop is \"enabled\": if the flip-flop is enabled (i.e., <code>en</code> is one) then the flip-flop will sample a new value on the rising edge of the clock; but if the flip-flop is disabled then the flip-flop will hold the old value and not sample a new value on the rising edge of the clock. We can implement a D flip-fop with reset and enable by adding a multiplexor, AND gate, and NOT gate to our D flip-flop.</p> <p>We have provided you the interface a D flip-flop with reset and enable in <code>DFFRE_GL.v</code> and a test bench in <code>DFFRE_GL-test.v</code>. We have already provided you all of the test cases you need for the D flip-flop with reset and enable. You can test this new version of the D flip-flop as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make DFFRE_GL-test\n% ./DFFRE_GL-test\n</code></pre> <p>Activity 3: Implement and Test D Flip-Flop with Reset and Enable</p> <p>Create a Verilog hardware design that implements a D flip-flop with reset and enable by instantiating a D flip-flop, 1-bit 2-to-1 multiplexor, AND gate, and NOT gate and connecting them appropriately. Do not use Boolean logic equations. Verify that your new D flip-flop passes all of the provided test cases.</p>"},{"location":"ece2300-sec06-lab3-head-start/#34-gate-level-register","title":"3.4 Gate-Level Register","text":"<p>To implement a multi-bit register we just need to instantiate a number of D flip-flops and connect them appropriately. We have provided you the interface an eight-bit register in <code>Register_8b_GL.v</code> and a test bench in <code>Register_8b_GL-test.v</code>. For the test bench, we have provided you a template for your test cases; all you need to do is fill in the correct output values for each provided check. Take a closer look at the provided test bench.</p> <pre><code>  task test_case_1_basic();\n    t.test_case_begin( \"test_case_1_basic\" );\n\n    //    rst en d             q\n    check( 0, 1, 8'b0000_0000, 8'b0000_0000 );\n    check( 0, 1, 8'b0000_0001, 8'b0000_0000 );\n    check( 0, 1, 8'b0000_0000, 8'b0000_0001 );\n    check( 0, 1, 8'b0000_0010, 8'b0000_0000 );\n    check( 0, 1, 8'b0000_0000, 8'b0000_0010 );\n\n  endtask\n</code></pre> <p>Notice how we no longer explicitly include the clock signal in our checks. The ECE 2300 testing framework takes care of toggling the clock appropriately, so we can think of each check corresponding to the row in our simulation tables when the clock is one. We will now always have exactly one check per cycle. In the above basic test, we can see that the output <code>q</code> is updated the cycle after we set the input value <code>d</code>. This is because we are testing sequential logic. It is important to understand how this works so you can effectively write tests for sequential logic.</p> <p>You can run the test simulator for the register as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make Register_8b_GL-test\n% ./Register_8b_GL-test\n</code></pre> <p>Activity 4: Implement and Test GL Register</p> <p>Create a Verilog hardware design that implements an eight-bit register with reset and enable by instantiating eight D flip-flops and connecting them appropriately. Finish the test bench and verify that your register is functionally correct.</p>"},{"location":"ece2300-sec06-lab3-head-start/#3-implementing-and-testing-a-parameterized-rtl-register","title":"3. Implementing and Testing a Parameterized RTL Register","text":"<p>Our goal is to now implement a parameterized multi-bit register using RTL modeling, but we need to learn two new concepts before we can complete this task.</p>"},{"location":"ece2300-sec06-lab3-head-start/#41-rtl-modeling-of-sequential-logic","title":"4.1. RTL Modeling of Sequential Logic","text":"<p>In the last discussion section, we learned how to use an <code>always_comb</code> block for RTL modeling of combinational logic. <code>always_ff</code> is a new kind of always block specifically for RTL modeling of sequential logic. The following is an example of a D flip-flop modeled using an <code>always_ff</code> block.</p> <pre><code>module DFF_RTL\n(\n  input  logic clk,\n  input  logic d,\n  output logic q\n);\n\n  always_ff @(posedge clk) begin\n    q &lt;= d;\n  end\n\nendmodule\n</code></pre> <p>An <code>always_comb</code> block executes whenever any of the inputs to that block change. An <code>always_ff @(posedge clk)</code> block only executes on the rising edge of the clock. Notice how we are using a non-block assignment (<code>&lt;=</code>) instead of a blocking assignment (<code>=</code>). A non-block assignment has very different semantics to a blocking assignment. In a non-blocking assignment, the right-hand side (i.e., <code>d</code>) is evaluated and saved before the rising clock edge and the left-hand side (i.e., <code>q</code>) is only updated after the rising clock edge. Critically, the right-hand side is evaluated and saved in every <code>always_ff</code> across the entire hardware design before updating any left-hand side. This effectively models all of these assignments happening concurrently on the rising edge of the clock which is exactly what happens in hardware. We should only use non-blocking assignments in <code>always_ff</code> blocks, and we should only use blocking assignments in <code>always_comb</code> blocks. We should never mix these up!</p>"},{"location":"ece2300-sec06-lab3-head-start/#42-parameterized-hardware-modules","title":"4.2. Parameterized Hardware Modules","text":"<p>So far all of our designs have been for a fixed bitwidth. For example, we have implemented various adders specifically designed for eight-bit inputs and outputs. If we need a new adder for 12-bit inputs and outputs we would need to implement and test this module from scratch. We can develop parameterized hardware modules by using Verilog parameters. Here is an example of how we can implement a parameterized RTL adder that can operate on inputs and outputs of any bitwidth.</p> <pre><code>module Adder_RTL\n#(\n  parameter p_nbits = 1\n)(\n  (* keep=1 *) input  logic [p_nbits-1:0] in0,\n  (* keep=1 *) input  logic [p_nbits-1:0] in1,\n  (* keep=1 *) input  logic               cin,\n  (* keep=1 *) output logic               cout,\n  (* keep=1 *) output logic [p_nbits-1:0] sum\n);\n\n  assign {cout,sum} = in0 + in1 + { {p_nbits-1}{1'b0}, cin };\n\nendmodule\n</code></pre> <p>Parameters are specified as a list using <code>#()</code> after the module name. In the above example we have one parameter named <code>p_nbits</code> with a default value of 1. This parameter is then used to specify the bitwidths of the input ports <code>in0</code> and <code>in1</code> as well as the bitwidth of the output port <code>sum</code>. Notice how we are also using this parameter along with the Verilog repeat operator to zero-extend <code>cin</code>.</p> <p>You can specify parameters using <code>#()</code> when you instantiate a module. Here is how we would instantiate a parameterized RTL adder as an eight-bit adder and connect its ports to wires.</p> <pre><code>  logic [7:0] adder_in0;\n  logic [7:0] adder_in1;\n  logic       adder_cin;\n  logic       adder_cout;\n  logic [7:0] adder_sum;\n\n  Adder_RTL#(8)\n  (\n    .in0  (adder_in0),\n    .in1  (adder_in1),\n    .cin  (adder_cin),\n    .cout (adder_cout),\n    .sum  (adder_sum)\n  );\n</code></pre>"},{"location":"ece2300-sec06-lab3-head-start/#43-parameterized-rtl-register","title":"4.3. Parameterized RTL Register","text":"<p>We have provided you the interface for a parameterized eight-bit register in <code>Register_RTL.v</code>.</p> <pre><code>module Register_RTL\n#(\n  parameter p_width = 1\n)(\n  input  logic               clk,\n  input  logic               rst,\n  input  logic               en,\n  input  logic [p_width-1:0] d,\n  output logic [p_width-1:0] q\n);\n</code></pre> <p>We have provided you a test bench in <code>Register_RTL-test.v</code>. Notice how the test bench instantiates this parameterized register as an eight-bit register.</p> <pre><code>  Register_RTL#(8) register\n  (\n    .clk (clk),\n    .rst (reset || dut_rst),\n    .en  (dut_en),\n    .d   (dut_d),\n    .q   (dut_q)\n  );\n</code></pre> <p>You should be able to just copy your tests from your gate-level register and reuse them for your RTL register. You can run the test simulator for the register as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make Register_RTL-test\n% ./Register_RTL-test\n</code></pre> <p>Activity 5: Implement and Test RTL Register</p> <p>Use what you have learned in Section 4.1 and 4.2 to create a Verilog hardware design that implements a parameterized register with reset and enable. You should have a single <code>always_ff</code> block with an if/else conditional operation to handle the reset and enable signals. Verify that your register is functionally correct.</p>"},{"location":"ece2300-sec06-lab3-head-start/#5-simple-counter","title":"5. Simple Counter","text":"<p>We now want to implement the following simple counter.</p> <p></p> <p>The counter has a single reset input signal which should reset the counter register to zero. The counter then simply counts up by one every cycle forever. If the counter reaches the maximum value (255) it just rolls over back to zero.</p> <p>We could definitely implement this simple counter using our 8-bit gate-level adders from lab 2, but let's stick with just using the RTL adder. We will experiment with using both the gate-level and RTL register developed in this discussion section.</p> <p>We have provided you a test bench with three test cases. Notice how we can use a loop to test roll over:</p> <pre><code>  task test_case_2_directed_rollover();\n    t.test_case_begin( \"test_case_2_directed_rollover\" );\n\n    for ( int i = 0; i &lt; 275; i = i+1 )\n      check( 0, 8'(i) );\n\n  endtask\n</code></pre> <p>You can run the test simulator for the simple counter as follows.</p> <pre><code>% cd ${HOME}/ece2300/sec06/build\n% make SimpleCounter_RTL-test\n% ./SimpleCounter_RTL-test\n</code></pre> <p>Activity 6: Implement and Test Simple Counter</p> <p>Implement a simple counter by instantiating an eight-bit register and the RTL adder. Try using both the gate-level and the RTL register. Verify that both versions are functionally correct.</p>"},{"location":"ece2300-sec06-lab3-head-start/#6-clean-build","title":"6. Clean Build","text":"<p>As a final step, do a clean build to verify everything is working correctly.</p> <pre><code>% cd ${HOME}/ece2300/sec06\n% trash build\n% mkdir -p build\n% cd build\n% ../configure\n% make check\n</code></pre>"},{"location":"ece2300-sec07-verilog-mem/","title":"Section 7: Verilog Memory Arrays","text":"<p>In this discussion section, you will use what you have learned in the previous discussion sections to implement a simple register file memory array at the register-transfer level (RTL). We will also learn about implementing parameterized Verilog hardware modules. You will start by implementing a parameterized 4-to-1 mux, parameterized decoder, and parameterized register which are each parameterized by the input/output bitwidth. You will then implement a 4-word 4-bit register file memory array in two ways: (1) structurally by composing the mux, register, and decoder; and (2) flat using a single <code>always_ff</code> and <code>always_comb</code> block.</p> <p>In the past discussion sections, we have focused on how to use Verilog to model combinational logic at both the gate-level and RTL. In this discussion section, we will only be using RTL. Remember from previous discussion sections that it is critical that students always know what is the hardware they are modeling; students should understand what their RTL would likely turn into at the gate-level.</p>"},{"location":"ece2300-sec07-verilog-mem/#1-logging-into-ecelinux-with-vs-code","title":"1. Logging Into <code>ecelinux</code> with VS Code","text":"<p>Follow the same process as previous discussion sections. Find a free workstation and log into the workstation using your NetID and standard NetID password. Then complete the following steps (described in more detail in the last discussion section):</p> <ul> <li>Start VS Code</li> <li>Install the Remote-SSH, Verilog, and Surfer extensions</li> <li>Use View &gt; Command Palette to execute Remote-SSH: Connect Current     Window to Host...</li> <li>Enter <code>netid@ecelinux.ece.cornell.edu</code></li> <li>Install the Verilog and Surfer extensions on the server</li> <li>Use View &gt; Explorer to open your home directory on <code>ecelinux</code></li> <li>Use View &gt; Terminal to open a terminal on <code>ecelinux</code></li> </ul> <p>There is no need to fork the repo for today's discussion section. Simple clone the repo as follows.</p> <pre><code>% source setup-ece2300.sh\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:cornell-ece2300/ece2300-sec07-verilog-mem sec07\n% cd sec07\n% tree\n</code></pre> <p>The repo includes the following files:</p> <ul> <li><code>Makefile.in</code>: Makefile for the build system</li> <li><code>configure</code>: Configure script for the build system</li> <li><code>configure.ac</code>: Used to generate the configure script</li> <li><code>scripts</code>: Scripts used by the build system</li> <li><code>Mux4_RTL.v</code>: Parameterized 4-to-1 mux in RTL</li> <li><code>Decoder_RTL.v</code>: Parameterized binary decoder in RTL</li> <li><code>Register_RTL.v</code>: Parameterized register with reset and enable in RTL</li> <li><code>RegfileStruct1r1w_4x4b_RTL.v</code>: Regster file using structural RTL</li> <li><code>RegfileFlat1r1w_4x4b_RTL.v</code>: Regster file using flat RTL</li> <li><code>test</code>: Directory with unit tests for each hardware module</li> </ul> <p>Go ahead and create a build directory and run configure to generate a Makefile.</p> <pre><code>% cd ${HOME}/ece2300/sec07\n% mkdir -p build\n% cd build\n% ../configure\n</code></pre> <p>To make it easier to cut-and-paste commands from this handout onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-sec07-verilog-mem/#2-implementing-and-testing-a-parameterized-4-to-1-rtl-multiplexor","title":"2. Implementing and Testing a Parameterized 4-to-1 RTL Multiplexor","text":"<p>Our goal is to now implement a parameterized 4-to-1 multiplexor using RTL modeling. Parameterized hardware modules have an additional list of parameters as part of their interface. These parameters can be used to specify the bitwidths of ports and declare internal wires. Here is a trivial parameterized pass through module that simply connects the input port to the output port. The pass through module is parameterized by the bitwidths of the input and output ports.</p> <pre><code>module PassThrough\n#(\n  parameter p_nbits = 1\n)(\n  input  logic [p_nbits-1:0] in,\n  output logic [p_nbits-1:0] out\n);\n\n  assign out = in;\n\nendmodule\n</code></pre> <p>Paarameters are specified as an additional list enclosed in <code>#()</code> before the list of ports. By convention, we prefix all parameters with <code>p_</code>. Parameters can have default values (the default value for <code>p_nbits</code> above is 1). We need new syntax to insantate a module with parameters. The following instantiates two pass through modules with a large module.</p> <pre><code>module DoublePassThrough_8b\n(\n  input  logic [7:0] in,\n  output logic [7:0] out\n);\n\n logic [7:0] pt0_out;\n\n PassThrough\n #(\n   .p_nbits(8)\n )\n pt0\n (\n   .in  (in),\n   .out (pt0_out)\n );\n\n PassThrough\n #(\n   .p_nbits(8)\n )\n pt1\n (\n   .in  (pt0_out),\n   .out (out)\n );\n\nendmodule\n</code></pre> <p>To specify parameter values when instantiating a hardware module we use an extra <code>#()</code> before connecting the ports. Our coding conventions require always using named port lists, and usually we always want to use named parameter lists as well so there is no confusion what parmeters we are setting. However, as special exception to our coding conventions, if a module is only parameterized by the bitwidth then you can just use a positional parameter specification like this.</p> <pre><code>module DoublePassThrough_8b\n(\n  input  logic [7:0] in,\n  output logic [7:0] out\n);\n\n logic [7:0] pt0_out;\n\n PassThrough#(8) pt0\n (\n   .in  (in),\n   .out (pt0_out)\n );\n\n PassThrough#(8) pt1\n (\n   .in  (pt0_out),\n   .out (out)\n );\n\nendmodule\n</code></pre>"},{"location":"ece2300-sec07-verilog-mem/#21-implementing-a-parameterized-4-to-1-multiplexor","title":"2.1. Implementing a Parameterized 4-to-1 Multiplexor","text":"<p>We have provided you the interface for a parameterized 4-to-1 mux in <code>Mux4_RTL.v</code>.</p> <pre><code>module Mux4_RTL\n#(\n  parameter p_nbits = 1\n)(\n  input  logic [p_nbits-1:0] in0,\n  input  logic [p_nbits-1:0] in1,\n  input  logic [p_nbits-1:0] in2,\n  input  logic [p_nbits-1:0] in3,\n  input  logic         [1:0] sel,\n  output logic [p_nbits-1:0] out\n);\n</code></pre> <p>Activity 1: Implement a Parameterized 4-to-1 Mux</p> <p>Use what you have learned to create a Verilog hardware design that implements a parameterized 2-to-1 mux. You should have a single <code>always_comb</code> block. Although it is possible to use if/else conditional operators, try using a case statemet instead.</p>"},{"location":"ece2300-sec07-verilog-mem/#22-testing-a-parameterized-4-to-1-multiplexor","title":"2.2. Testing a Parameterized 4-to-1 Multiplexor","text":"<p>Testing parameterized hardware modules is more challenging since we need to instantiate the design under test with many different parameters and then throughly test each instance. We have provided you a test bench in <code>Mux4_RTL-test.v</code>. Notice how we have a separate parameterized test module; the test cases in the test module are all parameterized so we can use the same test cases to test modules with different parameter values.</p> <p>You can run the test simulator for the mux as follows. Currently we are only testing a 1-bit 4-to-1 mux.</p> <pre><code>% cd ${HOME}/ece2300/sec07/build\n% make Mux4_RTL-test\n% ./Mux4_RTL-test\n</code></pre> <p>Activity 2: Test Parameterized 4-to-1 Mux</p> <p>Instantiate <code>TestMux4</code> two more times to test a 5-bit 4-to-1 mux and a 32-bit 4-to-1 test. Use <code>run_test_suite</code> in the top-level initial block to run these two new test suites. Build and run the updated test simulator to verify the parameterized mux works for a variety of different parameters.</p>"},{"location":"ece2300-sec07-verilog-mem/#3-implementing-and-testing-a-parameterized-rtl-decoder","title":"3. Implementing and Testing a Parameterized RTL Decoder","text":"<p>We will now implement a parameterized binary decoder using RTL modeling. Recall that a decoder takes as input a binary number and produces a one-hot encoding of that binary number. If the input is 0, then bit 0 should be 1 and the remaining bits should be 0. If the input is 1, then bit 1 should be 1 and the remaining bits should be 0.</p> <p>We will need to start understanding the static elaboration phase of hardware modeling. Static elaboration involves generating hardware, and is a form of meta-programming (i.e., programs that generate programs). Static elaboration is not about modeling hardware; it is about generating hardware. Static elaboration happens once when we construct the hardware (or construct a simulator); static elaboration is very seperate from runtime when the hardware is actually executing. Let's look at the interface for the parameterized mux.</p> <pre><code>module Decoder_RTL\n#(\n  parameter p_nbits = 4\n)(\n  input  logic [$clog2(p_nbits)-1:0] in,\n  output logic         [p_nbits-1:0] out\n);\n</code></pre> <p><code>$clog2()</code> is a new Verilog construct that returns the ceiling log base 2 of its input. This enables us to specify a 2-to-4 decoder: we specify <code>p_nbits</code> as 4 and the input port will be automatically determined to hvae a bitwidth of 2 at static elaboration time. <code>$clog2()</code> has nothing to do with modeling hardware. It is only used for generating hardware. Here it is used to determine a bitwidth based on a parameter value.</p>"},{"location":"ece2300-sec07-verilog-mem/#31-implementing-a-parameterized-decoder","title":"3.1. Implementing a Parameterized Decoder","text":"<p>We have provided you the interface for a parameterized decoder in <code>Decoder_RTL.v</code>.</p> <p>Activity 3: Implement a Parameterized Decoder</p> <p>Use what you have learned to create a Verilog hardware design that implements a parameterized decoder. You should have a single <code>always_comb</code> block. Then run the tests in <code>Decoder_RTL-test.v</code>.</p>"},{"location":"ece2300-sec07-verilog-mem/#4-implementing-and-testing-a-parameterized-rtl-register","title":"4. Implementing and Testing a Parameterized RTL Register","text":"<p>We will now implement a parameterized register using RTL modeling.</p>"},{"location":"ece2300-sec07-verilog-mem/#41-implementing-a-parameterized-register","title":"4.1. Implementing a Parameterized Register","text":"<p>We have provided you the interface for a parameterized register in <code>Register_RTL.v</code>.</p> <pre><code>module Register_RTL\n#(\n  parameter p_width = 1\n)(\n  input  logic               clk,\n  input  logic               rst,\n  input  logic               en,\n  input  logic [p_width-1:0] d,\n  output logic [p_width-1:0] q\n);\n</code></pre> <p>Activity 4: Implement a Parameterized Register</p> <p>Use what you have learned to create a Verilog hardware design that implements a parameterized register. You should have a single <code>always_ff</code> block with an if/else conditional operation to handle the reset and enable signals. Then run the tests in <code>Register_RTL-test.v</code>.</p>"},{"location":"ece2300-sec07-verilog-mem/#5-implementing-and-testing-a-structural-register-file","title":"5. Implementing and Testing a Structural Register File","text":"<p>A memory array is a two-dimensional array of sequential logic gates (also called \"bit cells\"). A register file is a specific kind of memory array where D flip-flops are used as the sequental logic gates. We can implement a register file structurally using the mux, decodier, and register developed earlier in this discussion section.</p> <p></p> <p>This register file has four \"words\" and each word is 4-bits. The register file has one write port and one read port (i.e., we can do a 4-bit write and a 4-bit read at the same time). The read port is combinational; if we set the read address then the read data comes back that same cycle (i.e., combinationally).</p> <p>We have provided you the following Verilog structural template for this register file in <code>RegfileStruct1r1w_4x4b_RTL.v</code>:</p> <pre><code>module RegfileStruct1r1w_4x4b_RTL\n(\n  input  logic       clk,\n  input  logic       rst,\n\n  input  logic       wen,\n  input  logic [1:0] waddr,\n  input  logic [3:0] wdata,\n\n  input  logic [1:0] raddr,\n  output logic [3:0] rdata\n);\n\n  // Write Address Decoder\n\n  logic [3:0] regfile_en;\n\n  Decoder_RTL#(4) waddr_decoder\n  (\n    .in  (waddr),\n    .out (regfile_en)\n  );\n\n  // Register file array\n\n  logic [3:0] regfile_q [4];\n\n  genvar i;\n  generate\n    for ( i = 0; i &lt; 4; i = i + 1 ) begin : regfile\n\n     //''' ACTIVITY ''''''''''''''''''''''''''''''''''''''''''''''''''''''\n     // Instantate a 4-bit register and connect appropriately\n     //&gt;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n    end\n  endgenerate\n\n  // Read mux\n\n  Mux4_RTL#(4) mux\n  (\n    .in0 (regfile_q[0]),\n    .in1 (regfile_q[1]),\n    .in2 (regfile_q[2]),\n    .in3 (regfile_q[3]),\n    .sel (raddr),\n    .out (rdata)\n  );\n\nendmodule\n</code></pre> <p>This template is again making use of static elaboration. The generate loop is a new Verilog construct which can be used to programmatically instantiate hardware modules at static elaboration time. Generate loops do not happen at runtime when the hardware is actually executing. The generate loop in this template is used to instantiate four registers. These kind of generate statemts can greatly simplify complex hardware (especially complex parameterized hardware).</p> <p>The following construct from the template creates an array of signals:</p> <pre><code>  logic [3:0] regfile_q [4];\n</code></pre> <p>This creates an array of four signals, each signal is four-bits.</p> <p>Activity 5: Implement and Test Structural Register File</p> <p>Instantiate your 4-bit register using your parameterized register in the template. Verify your register file works using the provided test bench in <code>RegfileStruct1r1w_4x4b_RTL-test.v</code>.</p>"},{"location":"ece2300-sec07-verilog-mem/#6-implementing-and-testing-a-flat-register-file","title":"6. Implementing and Testing a Flat Register File","text":"<p>We can also implement a register file flat using a single <code>always_ff</code> block for the write ports and a single <code>always_comb</code> block for the read port. We will use an array of signals to act as the state.</p> <pre><code>  logic [3:0] regfile [4];\n</code></pre> <p>You can read and write four-bit signals from this array by simply indexing into it. So the following will write the binary value 0011 into the second signal in this array.</p> <pre><code>  always_comb begin\n    regfile[1] = 4'b0011;\n  end\n</code></pre> <p>Activity 6: Implement and Test Flat Register File</p> <p>Implement the flat register file using a single <code>always_ff</code> block and a single <code>always_comb</code> block. Verify your register file works using the provided test bench in <code>RegfileFlat1r1w_4x4b_RTL-test.v</code>.</p>"},{"location":"ece2300-sec07-verilog-mem/#7-clean-build","title":"7. Clean Build","text":"<p>As a final step, do a clean build to verify everything is working correctly.</p> <pre><code>% cd ${HOME}/ece2300/sec07\n% trash build\n% mkdir -p build\n% cd build\n% ../configure\n% make check\n</code></pre>"},{"location":"ece2300-test-debug-strategy/","title":"ECE 2300 Testing and Debugging Strategy","text":"<p>This document discuses the testing and debugging strategy we will be using for the lab assignments in ECE 2300.</p>"},{"location":"ece2300-test-debug-strategy/#1-testing-strategy","title":"1. Testing Strategy","text":"<p>Testing is the process of checking whether a program behaves correctly. Testing a large design can be hard because bugs may appear anywhere in the design, and multiple bugs may interact. Good practice is to test small parts of the design individually, before testing the entire design, which can more readily support finding and fixing bugs.</p>"},{"location":"ece2300-test-debug-strategy/#11-unit-vs-integration-testing","title":"1.1. Unit vs. Integration Testing","text":"<p>We will use both unit testing and integration testing. Unit testing is the process of individually testing a small part or unit of a design, typically a single module. A unit test is typically conducted by creating a testbench, a.k.a. test harness, which is a separate program whose sole purpose is to check that a module returns correct output values for a variety of input values. Each unique set of input values is known as a test vector. Manually examining printed output is cumbersome and error prone. A better test harness would only print a message for incorrect output. Integration testing involves testing the composition of various modules and should only be attempted after we have unit tested those modules.</p>"},{"location":"ece2300-test-debug-strategy/#12-black-box-vs-white-box-testing","title":"1.2. Black-Box vs. White-Box Testing","text":"<p>We will be using a mix of black-box and white-box testing. Black box testing is where your test cases only test the interface of your design. Black-box testing does not directly test any of the internals within your design. Obviously, black-box testing will indirectly test the internals though. White-box testing is where your test cases directly test the internals by perhaps poking into the design using hierarchical signal references. White-box testing is pretty fragile so we won't really be using it in this course. We also might do what I call \"gray-box\" testing. This is where you choose specific test vectors that are carefully designed to trigger complex behavior in a specific implementation. Since gray-box tests can be applied to any implementation, they are like black-box tests. Since they attempt to trigger complex implementation-specific behavior, they are like white-box tests.</p>"},{"location":"ece2300-test-debug-strategy/#13-directed-vs-random-testing","title":"1.3. Directed vs. Random Testing","text":"<p>We will primarly be using directed testing and random testing. Directed testing is where the designer explicitly specifies the inputs and the correct outputs. Directed tests are carefully crafted to enable good coverage of many different hardware behaviors. Random testing is where the designer randomly generates inputs and then verifies that the function produces the right output. This of course begs the question, \"How do we know what the right output is, if we are randomly generating the input?\" There are two approaches. First, the designer can assert that property is valid on the output. For example, if the module is meant to sort a sequence of values, the random test can assert that the final values are is indeed sorted. Second, the designer can use a golden reference implementation. For example, the programmer might use a functional-level model of the module.</p>"},{"location":"ece2300-test-debug-strategy/#14-value-vs-delay-testing","title":"1.4. Value vs. Delay Testing","text":"<p>We will also use value and delay testing. Value testing focuses on applying different input values and checking the corresponding output values. Delay testing focuses more on changing the delays between when input values are provided and possibly also changing the delays between when output values are accepted. Delay testing is particularly important when working with memory interfaces to ensure the design-under-test can correctly handle wait states. A variant of delay testing involves verifying that the delay of a module is as expected. So for example we might assert that the module takes no longer than a specific number of cycles to executes a specific transaction.</p>"},{"location":"ece2300-test-debug-strategy/#15-mixing-styles-of-testing","title":"1.5. Mixing Styles of Testing","text":"<p>Note that we usually mix and match these different styles of testing. So we can use unit, black-box, directed, value testing or integration, black-box, random, delay testing. Note that ad-hoc testing should not an important part of your testing strategy. It is neither automatic nor systematic.</p>"},{"location":"ece2300-test-debug-strategy/#2-debugging-strategy","title":"2. Debugging Strategy","text":"<p>Here is our recommended systematic debugging process.</p>"},{"location":"ece2300-test-debug-strategy/#step-1-configure-the-build-system","title":"Step 1: Configure the build system","text":"<p>Start by creating a build directory and using <code>configure</code> to configure the build system.</p> <pre><code>% mkdir build\n% cd build\n% ../configure\n</code></pre>"},{"location":"ece2300-test-debug-strategy/#step-2-run-all-test-benches","title":"Step 2: Run all test benches","text":"<p>Fun all of the tests to get a high-level view of what test cases are passing and what test cases are failing. This gives you the big pictures. Are many tests failing? Are just a few tests failing?</p> <pre><code>% make check\n</code></pre>"},{"location":"ece2300-test-debug-strategy/#step-3-zoom-in-on-one-test-bench-in-isolation","title":"Step 3: Zoom-in on one test bench in isolation","text":"<p>Pick one failing test bench to focus on. Choose the failing test bench that tests the simplest hardware module. So if your design has many modules, start by focusing on the simplest child module. Let's assume we want to focus on the test bench named <code>Foo-test.v</code>. Build and run the failing test bench in isolation like this:</p> <pre><code>% make Foo-test\n% ./Foo-test\n</code></pre> <p>You can build and run the failing test bench in a single step using command chaining like this:</p> <pre><code>% make Foo-test &amp;&amp; ./Foo-test\n</code></pre>"},{"location":"ece2300-test-debug-strategy/#step-4-zoom-in-on-one-test-case-in-isolation","title":"Step 4: Zoom-in on one test case in isolation","text":"<p>Each test bench will contain many test cases. Pick one failing test case to focus on. Choose the simplest failing test case. Let's assume the test bench includes a basic test case, several directed test cases, and a random test case. If all of the test cases are failing, then start by focusing on the basic test case. If the basic test case is passing, but all of the remaining test cases are failing, then start by focusing on the simplest directed test case. Only focus on a random test case if it is the only failing test case. Lest's assume we want to focus on test case number 2. Build and run just failing test test case in isolation like this:</p> <pre><code>% make Foo-test &amp;&amp; ./Foo-test +test-case=2\n</code></pre> <p>When you run a test case in isolation, the testing framework will display a trace showing the values of various signals over time. You will also see a more detailed error message showing the value from the design under test that does not match the expected value.</p>"},{"location":"ece2300-test-debug-strategy/#step-5-determine-the-observable-error","title":"Step 5: Determine the observable error","text":"<p>Look at the trace and the error message. Determine the exact observable error. The observable error might be something like \"signal X is supposed to be 0 but is instead 1\". The observable error is never \"my code doesn't work\"; the observable error needs to be a specific statement about a signal and how its value is different from what is expected.</p>"},{"location":"ece2300-test-debug-strategy/#step-6-look-at-the-test-case","title":"Step 6: Look at the test case","text":"<p>Look at the actual test case. Make absolutely sure you know what the test case is testing and that the test case is valid. You have no hope of debugging your design if you do not understand what correct execution you expect to happen!</p>"},{"location":"ece2300-test-debug-strategy/#step-7-zoom-in-both-in-terms-of-space-and-time","title":"Step 7: Zoom-in both in terms of space and time","text":"<p>Try to zoom-in in terms of space. Look at the trace and see if you can move the observable error in space. For example, let's say you have a parent module with three child modules A, B, and C. The input of the parent module is connected to the input of A, the output of A is connected to the input of B, the output of B is connected to the input of C, and the output of C is connected to the output of the parent module. Let's say after step 5, the observable error is that the output value of the parent module does not match the expected output value. From the trace we might be able to determine that the input to B is correct, but the output of B is incorrect. This means we have just moved the observable error from the output of the parent module to the output of module B. We no longer need to focus on module A or module C, we can zoom-in and focus on debugging module B.</p> <p>Try to zoom-in in terms of time. Work backwards from the observable error on the trace. For designs with just combinational logic (i.e., labs 1 and 2) there might not be any need to work backwards through the trace since the outputs always directly depend on the inputs. For designs with sequential logic working backwards through the trace is much more important. There may be an observable error on cycle 10, but if we work backwards through the trace we might realize that something first goes wrong on cycle 5 and eventually this casues the incorrect output on cycle 10. We no longer need to focus on cycles 6 through 10. We can zoom-in and focus on cycle 5.</p> <p>Essentially, for designs with sequential logic we want to try and work backwards through the trace to find the first cycle where the previous cycle looks correct and the next cycle looks incorrect. Our goal is to move the observable error as far backwards in the trace as possible.</p> <p>Step 7: Based on the narrowed focus from step 6, make a hypothesis on what might be wrong. Take a quick look at the corresponding code. Check for errors in bitwidth, in signal naming, or in connectivity. If you cannot spot anything obvious then go to the next step. If you spot something obvious skip to step 10.</p> <p>Step 8: Use the --dump-vcd option to generate a VCD file. Open the VCD file in gtkwave. Add the clock, maybe add the inst_D, inst_X, inst_M, inst_W fields to the waveform view. Use the narrowed focus from Step 6 and the hypothesis from Step 7 to zoom in on a specific cycle and a specific part of the design where you can clearly see a specific signal that is incorrect.</p> <p>Step 9: Work backwards from the signal which is incorrect. Work backwards in the datapath -- keep working backwards component by component. For each component look at the inputs (all inputs, look at data inputs and control signals) and look at the outputs (all outputs, look at data outputs and status signals). Check for one of three things: (1) are the inputs incorrect and the outputs incorrect for this component? if so you need to continue working backwards -- if the incorrect input is a control signal then you need to start working backwards into the control unit; (2) are the inputs correct and the outputs incorrect for this component? if so then you have narrowed the bug to be inside the component (maybe it is a bug in the ALU? maybe it is a bug in some other module?); or (3) are the inputs correct and the outputs correct for this component? Then you have gone backwards too far and you need to go forward in the design again to find a signal which is incorrect.</p> <p>Step 10: Once you find a bug, make a hypothesis about what should happen if you fix the bug. Your hypothesis should not just be \"fixing the bug will make the test pass.\" It should instead be something like \"fixing this bug should make this specific signal be 1 instead of 0\" or \"fixing this bug should make this specific instruction in the line trace stall\". Fix the bug and see what happens by looking at the line trace and/or waveform. Don't just see if it passes the test -- literally check the line trace and/or waveform and see if the behavior confirms the line trace. One of four things will happen: (1) the test will pass and the linetrace/waveform behavior will match your hypothesis -- bug fixed! (2) the test will fail and the linetrace/waveform will not match your hypothesis -- you need to keep working -- your bug fix did not do what it was supposed to, and it did not fix the error -- undo the bug fix and go back to step 6. (3) the test will fail but the linetrace/waveform will match your hypothesis -- this means your bug fix did what you expected but there might be another bug still causing trouble -- you need to keep working -- go back to step 6. (4) the test will pass and the linetrace/waveform will not match your hypothesis -- you need to keep working -- your bug fix did not do what you thought it would even though it cause the test to pass -- there might be something subtle going on -- go back to step 6 to figure out why the bug fix did not do what you thought it would.</p> <p>Note a couple things about this systematic 10 step process. First, it is a systematic process ... it does not involve randomly trying things. Second, the process uses all tools at your disposable: output from pytest, traceback, line tracing, and VCD waveforms. You really need to use all of these tools. If you use line tracing but never use VCD waveforms or you use VCD waveforms and never use line tracing then you are putting yourself at a disadvantage. Third, the process requires you to think critically and make a hypothesis about what should change -- do not just change something, pass the test, and move on -- change something and see if the line trace and waveforms change in the way you expect. Otherwise you can actually introduce more bugs even though you think are fixing things.</p>"},{"location":"ece2300-tinyrv1-isa/","title":"TinyRV1 ISA","text":"<p>In Lab 4, you will be implementing the TinyRV1 ISA on your processor. The TinyRV1 ISA is a very limited subset of the RISC-V ISA, an open-source instruction set architecture that has gained significant popularity in the last decade.</p>"},{"location":"ece2300-tinyrv1-isa/#1-architectural-state","title":"1. Architectural State","text":""},{"location":"ece2300-tinyrv1-isa/#11-data-formats","title":"1.1: Data Formats","text":"<p>TinyRV1 only supports 4B (four-byte) signed and unsigned integer values. There are no byte nor half-word values and no floating-point.</p>"},{"location":"ece2300-tinyrv1-isa/#12-general-purpose-registers","title":"1.2: General-Purpose Registers","text":"<p>There are 31 general-purpose registers (GPRs) <code>x1</code>-<code>x31</code> (called x registers), which hold integer values. Register <code>x0</code> is hardwired to the constant zero. Each register is 32 bits wide. TinyRV1 uses the same calling convention and symbolic register names as RISC-V:</p> <pre><code>+----------+----------+--------------------------------------------------------+\n| Register | ABI Name | Description                                            |\n|----------|----------|--------------------------------------------------------|\n| x0       | zero     | The constant value 0                                   |\n| x1       | ra       | Return address (caller saved)                          |\n| x2       | sp       | Stack pointer (callee saved)                           |\n| x3       | gp       | Global pointer                                         |\n| x4       | tp       | Thread pointer                                         |\n| x5       | t0       | Temporary registers (caller saved)                     |\n| x6       | t1       | \u2191                                                      |\n| x7       | t2       | \u2191                                                      |\n| x8       | s0/fp    | Saved register or frame pointer (callee saved)         |\n| x9       | s1       | Saved register (callee saved)                          |\n| x10      | a0       | Function arguments and/or return values (caller saved) |\n| x11      | a1       | \u2191                                                      |\n| x12      | a2       | Function arguments (caller saved)                      |\n| x13      | a3       | \u2191                                                      |\n| x14      | a4       | \u2191                                                      |\n| x15      | a5       | \u2191                                                      |\n| x16      | a6       | \u2191                                                      |\n| x17      | a7       | \u2191                                                      |\n| x18      | s2       | Saved registers (callee saved)                         |\n| x19      | s3       | \u2191                                                      |\n| x20      | s4       | \u2191                                                      |\n| x21      | s5       | \u2191                                                      |\n| x22      | s6       | \u2191                                                      |\n| x23      | s7       | \u2191                                                      |\n| x24      | s8       | \u2191                                                      |\n| x25      | s9       | \u2191                                                      |\n| x26      | s10      | \u2191                                                      |\n| x27      | s11      | \u2191                                                      |\n| x28      | t3       | Temporary registers (caller saved)                     |\n| x29      | t4       | \u2191                                                      |\n| x30      | t5       | \u2191                                                      |\n| x31      | t6       | \u2191                                                      |\n+----------+----------+--------------------------------------------------------+\n</code></pre>"},{"location":"ece2300-tinyrv1-isa/#13-memory","title":"1.3: Memory","text":"<p>TinyRV1 only supports a 1MB virtual memory address space from <code>0x00000000</code> to <code>0x000fffff</code>. The result of memory accesses to addresses larger than <code>0x000fffff</code> are undefined. TinyRV1 uses a little endian memory system.</p>"},{"location":"ece2300-tinyrv1-isa/#2-tinyrv1-instruction-and-immediate-encoding","title":"2. TinyRV1 Instruction and Immediate Encoding","text":"<p>The TinyRV1 ISA uses the same instruction encoding as RISC-V. There are four instruction types and four immediate encodings. Each instruction has a specific instruction type, and if that instruction includes an immediate, then it will also have an immediate type.</p>"},{"location":"ece2300-tinyrv1-isa/#21-tinyrv1-instruction-formats","title":"2.1: TinyRV1 Instruction Formats","text":""},{"location":"ece2300-tinyrv1-isa/#r-type","title":"R-type","text":""},{"location":"ece2300-tinyrv1-isa/#i-type","title":"I-type","text":""},{"location":"ece2300-tinyrv1-isa/#s-type","title":"S-type","text":""},{"location":"ece2300-tinyrv1-isa/#u-type","title":"U-type","text":""},{"location":"ece2300-tinyrv1-isa/#22-tinyrv1-immediate-formats","title":"2.2: TinyRV1 Immediate Formats","text":"<p>RISC-V has an asymmetric immediate encoding which means that the immediates are formed by concatenating different bits in an asymmetric order based on the specific immediate formats. Note that in RISC-V, all immediates are always sign extended, and the sign-bit for the immediate is always in bit 31 of the instruction.</p> <p>For this, let's separate out the different sections of an instruction:</p> <p>The following diagrams represent how to re-arrange these sections to create different immediates, based on the encoding for the particular instruction. Here:</p> <ul> <li><code>0</code> is used to indicate that a particular bit is 0</li> <li><code>&lt;-[n]-&gt;</code> is used to indicate that bit <code>n</code> should be replicated for    all bits in the field</li> </ul>"},{"location":"ece2300-tinyrv1-isa/#i-immediate","title":"I-immediate","text":""},{"location":"ece2300-tinyrv1-isa/#s-immediate","title":"S-immediate","text":""},{"location":"ece2300-tinyrv1-isa/#j-immediate","title":"J-immediate","text":""},{"location":"ece2300-tinyrv1-isa/#b-immediate","title":"B-immediate","text":""},{"location":"ece2300-tinyrv1-isa/#3-tinyrv1-instruction-details","title":"3. TinyRV1 Instruction Details","text":"<p>For each instruction we include a brief summary, assembly syntax, instruction semantics, instruction and immediate encoding format, and the actual encoding for the instruction. We use the following conventions when specifying the instruction semantics:</p> <ul> <li>\\(R[\\texttt{rx}]\\): general-purpose register value for register specifier <code>rx</code></li> <li>\\(CSR[\\texttt{csr}]\\): control/status register value for register specifier <code>csr</code></li> <li>\\(\\text{sext}\\): sign extend to 32 bits</li> <li>\\(M[\\texttt{addr}]\\) : 4-byte memory value at address <code>addr</code></li> <li>\\(PC\\): current program counter</li> <li>\\(\\texttt{imm}\\): immediate according to the immediate type</li> </ul>"},{"location":"ece2300-tinyrv1-isa/#csrr","title":"CSRR","text":"<ul> <li>Summary: Move value in control/status register to GPR</li> <li>Assembly: <code>csrr rd, csr</code></li> <li>Format: I-type, I-immediate</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow CSR[\\texttt{csr}]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul> <p>The control/status register read instruction is used to read a CSR and write the result to a GPR. The CSRs supported in TinyRV1 are listed in Section 4. Note that in RISC-V, <code>CSRR</code> is really a pseudo-instruction for a specific usage of <code>CSRRS</code>, but in TinyRV1 we only support the subset of <code>CSRRS</code> captured by <code>CSRR</code>. See Section 5 for more details about pseudo-instructions.</p>"},{"location":"ece2300-tinyrv1-isa/#csrw","title":"CSRW","text":"<ul> <li>Summary: Move value in GPR to control/status register</li> <li>Assembly: <code>csrw csr, rs1</code></li> <li>Format: I-type, I-immediate</li> <li>Semantics:</li> <li>\\(CSR[\\texttt{csr}] \\leftarrow R[\\texttt{rs1}]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul> <p>The control/status register write instruction is used to read a GPR and write the result to a CSR. The CSRs supported in TinyRV1 are listed in Section 4. Note that in RISC-V, <code>CSRW</code> is really a pseudo-instruction for a specific usage of <code>CSRRW</code>, but in TinyRV1 we only support the subset of <code>CSRRW</code> captured by <code>CSRW</code>. See Section 5 for more details about pseudo-instructions.</p>"},{"location":"ece2300-tinyrv1-isa/#add","title":"ADD","text":"<ul> <li>Summary: Addition with 3 GPRs (no overflow)</li> <li>Assembly: <code>add rd, rs1, rs2</code></li> <li>Format: R-type</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow R[\\texttt{rs1}] + R[\\texttt{rs2}]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul>"},{"location":"ece2300-tinyrv1-isa/#addi","title":"ADDI","text":"<ul> <li>Summary: Add constant</li> <li>Assembly: <code>addi rd, rs1, imm</code></li> <li>Format: I-type, I-immediate</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow R[\\texttt{rs1}] + \\text{sext}(\\texttt{imm})\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul>"},{"location":"ece2300-tinyrv1-isa/#mul","title":"MUL","text":"<ul> <li>Summary: Signed multiplication with 3 GPRs (no overflow)</li> <li>Assembly: <code>mul rd, rs1, imm</code></li> <li>Format: R-type</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow R[\\texttt{rs1}] \\times R[\\texttt{rs2}]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul>"},{"location":"ece2300-tinyrv1-isa/#lw","title":"LW","text":"<ul> <li>Summary: Load word from memory</li> <li>Assembly: <code>lw rd, imm(rs1)</code></li> <li>Format: I-type, I-immediate</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow M\\left[R[\\texttt{rs1}] + \\text{sext}(\\texttt{imm})\\right]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul> <p>TinyRV1 does not support unaligned memory access. The address used in any LW instruction must be 4-byte aligned (i.e., the bottom two bits must be zero). An unaligned LW address results in undefined behavior.</p>"},{"location":"ece2300-tinyrv1-isa/#sw","title":"SW","text":"<ul> <li>Summary: Store word in memory</li> <li>Assembly: <code>sw rs2, imm(rs1)</code></li> <li>Format: S-type, S-immediate</li> <li>Semantics:</li> <li>\\(M\\left[R[\\texttt{rs1}] + \\text{sext}(\\texttt{imm})\\right] \\leftarrow R[\\texttt{rs2}]\\)</li> <li>\\(PC \\leftarrow PC + 4\\)</li> </ul> <p>TinyRV1 does not support self-modifying code. Using a SW instruction to writing memory locations which will eventually be fetched as instructions results in undefined behavior. TinyRV1 does not support unaligned memory access. The address used in any SW instruction must be 4-byte aligned (i.e., the bottom two bits must be zero). An unaligned SW address results in undefined behavior.</p>"},{"location":"ece2300-tinyrv1-isa/#jal","title":"JAL","text":"<ul> <li>Summary: Jump to address, place return address in GPR</li> <li>Assembly: <code>jal rd, addr</code></li> <li>Format: U-type, J-immediate</li> <li>Semantics:</li> <li>\\(R[\\texttt{rd}] \\leftarrow PC + 4\\)</li> <li>\\(PC \\leftarrow \\texttt{addr}\\)</li> </ul> <p>The encoded immediate <code>imm</code> is calculated during assembly such that \\(PC + \\text{sext}(\\texttt{imm}) = \\texttt{addr}\\). TinyRV1 requires the JAL target address to always be four-byte aligned (i.e., the bottom two bits must be zero). An unaligned JAL target address results in undefined behavior.</p>"},{"location":"ece2300-tinyrv1-isa/#jr","title":"JR","text":"<ul> <li>Summary: Jump to address</li> <li>Assembly: <code>jr rs1</code></li> <li>Format: I-type</li> <li>Semantics:</li> <li>\\(PC \\leftarrow R[\\texttt{rs1}]\\)</li> </ul> <p>TinyRV1 requires the JR target address to always be four-byte aligned (i.e., the bottom two bits must be zero). An unaligned JR target address results in undefined behavior.</p>"},{"location":"ece2300-tinyrv1-isa/#bne","title":"BNE","text":"<ul> <li>Summary: Branch if two GPRs are not equal</li> <li>Assembly: <code>bne rs1, rs2, addr</code></li> <li>Format: S-type, B-immediate</li> <li>Semantics:</li> <li>\\(\\text{if}(R[\\texttt{rs1}] \\neq R[\\texttt{rs2}]) \\ PC \\leftarrow \\texttt{addr}\\)</li> <li>\\(\\text{else}\\qquad\\qquad\\qquad\\ \\ \\ \\ \\,           PC \\leftarrow PC + 4\\)</li> </ul> <p>The encoded immediate <code>imm</code> is calculated during assembly such that \\(PC + \\text{sext}(\\texttt{imm}) = \\texttt{addr}\\). TinyRV1 requires the BNE target address to always be four-byte aligned (i.e., the bottom two bits must be zero). An unaligned BNE target address results in undefined behavior.</p>"},{"location":"ece2300-tinyrv1-isa/#4-tinyrv1-privileged-isa","title":"4. TinyRV1 Privileged ISA","text":"<p>TinyRV1 does not support any kind of distinction between user and privileged mode. Using the terminology in the RISC-V vol 2 ISA manual, TinyRV1 only supports M-mode.</p>"},{"location":"ece2300-tinyrv1-isa/#reset-vector","title":"Reset Vector","text":"<p>RISC-V specifies that on reset, \\(PC\\) will reset to an implementation-defined value. TinyRV1 defines this to be at <code>0x00000000</code>. This is where assembly tests should reside.</p>"},{"location":"ece2300-tinyrv1-isa/#controlstatus-registers","title":"Control/Status Registers","text":"<p>TinyRV1 includes six non-standard CSRs. Here is the mapping:</p> <p> CSR Name Privilege Read/Write CSR Num Note <code>in0</code> M R <code>0xFC2</code> non-standard <code>in1</code> M R <code>0xFC3</code> non-standard <code>in2</code> M R <code>0xFC4</code> non-standard <code>out0</code> M R/W <code>0x7C2</code> non-standard <code>out1</code> M R/W <code>0x7C3</code> non-standard <code>out2</code> M R/W <code>0x7C4</code> non-standard <p></p> <p>These are chosen to conform to the guidelines in Section 2.1 of the RISC-V vol 2 ISA manual. Here is a description of each of these six CSRs.</p> <ul> <li><code>in0</code>/<code>in1</code>/<code>in2</code><ul> <li>Used to communicate data to the processor from an external   manager. These registers have register-mapped FIFO-dequeue   semantics, meaning reading the registers essentially dequeues   the data from the head of a FIFO. Reading the registers will   stall if the FIFO has no valid data. Writing the registers is   undefined.</li> </ul> </li> <li><code>out0</code>/<code>out1</code>/<code>out2</code><ul> <li>Used to communicate data from an external manager to the processor.   These registers have register-mapped FIFO-enqueue semantics, meaning   writing the registers essentially enqueues the data on the tail of a   FIFO. Writing the registers will stall if the FIFO is not ready.   Reading the registers is undefined.</li> </ul> </li> </ul>"},{"location":"ece2300-tinyrv1-isa/#address-translation","title":"Address Translation","text":"<p>TinyRV1 only supports the most basic form of address translation. Every logical address is directly mapped to the corresponding physical address. As mentioned above, TinyRV1 only supports a 1MB virtual memory address space from <code>0x00000000</code> to <code>0x000fffff</code>, and thus TinyRV1 only supports a \\(1MB\\) physical memory address space. In the RISC-V vol 2 ISA manual this is called a <code>Mbare</code> addressing environment.</p>"},{"location":"ece2300-tinyrv1-isa/#5-tinyrv1-pseudo-instructions","title":"5. TinyRV1 Pseudo-Instructions","text":"<p>It is very important to understand the relationship between the \"real\" instructions presented in this manual, the \"real\" instructions in the official RISC-V ISA manual, and pseudo-instructions. There are two instructions we need to be careful with: <code>NOP</code> and <code>JR</code>. The following table illustrates which ISAs contain which of these two instructions, and whether or not the instruction is considered a \"real\" instruction or a \"pseudo-instruction\".</p> <p> TinyRV1 RISC-V <code>NOP</code> pseudo pseudo <code>JR</code> real pseudo <code>CSRR</code> real pseudo <code>CSRW</code> real pseudo <p></p> <p><code>NOP</code> is always a pseudo-instruction. It is always equivalent to the following use of the <code>ADDI</code> instruction:</p> \\[\\begin{align}   \\texttt{nop} \\equiv \\texttt{addi x0, x0, 0} \\end{align}\\] <p><code>JR</code> is a \"real\" instruction in TinyRV1, but it is a pseudo-instruction in RISC-V for the following use of the <code>JALR</code> instruction:</p> \\[\\begin{align}   \\texttt{jr rs1} \\equiv \\texttt{jalr x0, rs1, 0} \\end{align}\\] <p><code>CSRR</code> and <code>CSSRW</code> are real instructions in TinyRV1 but they are pseudo-instructions for the following use of the <code>CSRRS</code> and <code>CSRRW</code>:</p> \\[\\begin{align}   \\texttt{csrr rd, csr}  &amp;\\equiv \\texttt{csrrs rd, csr, x0} \\\\   \\texttt{csrw csr, rs1} &amp;\\equiv \\texttt{csrrw x0, csr, rs1} \\end{align}\\] <p>None of this changes the encodings. In TinyRV1, <code>JR</code> is encoded the same way as the corresponding use of the <code>JALR</code> instruction in RISC-V.</p>"},{"location":"ece2300-tut00-remote-access/","title":"Tutorial 0: ECE Linux Server Remote Access","text":"<p>All of the laboratory assignments for this course will be completed by remotely logging into a cluster of <code>ecelinux</code> servers. The <code>ecelinux</code> servers all run the Red Hat Enterprise Linux 8 operating system, and they all use an identical setup. You do not need to do anything special to create an <code>ecelinux</code> account. You will be using your NetID and Cornell password to login, and an <code>ecelinux</code> account will be automatically created for you when you first login. Any student enrolled in any ECE class should automatically be granted access to the <code>ecelinux</code> servers. Having said this, if you cannot log into the <code>ecelinux</code> servers please reach out to the course staff for assistance.</p> <p>Later tutorials will discuss how to use the Linux development environment and the Git distributed version control system. In this tutorial, we focus on how to setup remote access to the <code>ecelinux</code> servers by first connecting to the Cornell VPN and then using two different options to remotely access the <code>ecelinux</code> servers. The first remote access option is based on using PowerShell (for Windows OS users) or Mac Terminal (for Mac OS X users) and only supports primitive text-based interaction. We recommend using PowerShell or Mac Terminal as backup options to debug connection issues to the <code>ecelinux</code> servers. The primary remote access option recommended in this course is through Visual Studio Code (VS Code) which provides a very nice interface with support for working at the command line, graphic text editing, and graphic file browsing.</p>"},{"location":"ece2300-tut00-remote-access/#1-connecting-to-the-cornell-vpn","title":"1. Connecting to the Cornell VPN","text":"<p>If you are logging into the <code>ecelinux</code> servers from on campus (i.e., using the Cornell wired or wireless network), then you do not need to enable the Cornell virtual private network (VPN). However, if you are off campus, then you will need to enable the Cornell VPN whenever you want to log into the <code>ecelinux</code> servers. The VPN provides very secure access to all on-campus network resources. More information about the Cornell VPN is available here:</p> <ul> <li>https://it.cornell.edu/cuvpn</li> </ul> <p>Simply follow the instructions at the following link to install the Cisco VPN software for the appropriate operating system you use on your laptop/workstation:</p> <ul> <li>https://it.cornell.edu/landing-page-kba/2605/5273</li> </ul> <p>Once the Cornell VPN is installed, then connect to the Cornell VPN by following these instructions and using your Cornell NetID and password:</p> <ul> <li>https://it.cornell.edu/landing-page-kba/2605/823</li> </ul> <p>The Cornell VPN uses the Cisco Secure Client shown below.</p> <p></p>"},{"location":"ece2300-tut00-remote-access/#2-remote-access-via-powershell-or-mac-terminal","title":"2. Remote Access via PowerShell or Mac Terminal","text":"<p>PowerShell is part of Windows OS and Mac Terminal is part of Mac OS X. Both enable interacting with your system from the command line (i.e., a powerful text-based environment where users type commands to manipulate files and directories and execute applications). Both also enable remotely accessing other systems (e.g., the <code>ecelinux</code> servers) via the command line using SSH, a highly secure network protocol and associated client/server program. Both will enable you to log into the <code>ecelinux</code> servers and to then manipulate files and directories and execute applications remotely on the <code>ecelinux</code> servers using the Linux command line.</p>"},{"location":"ece2300-tut00-remote-access/#21-starting-powershell-or-mac-terminal","title":"2.1. Starting PowerShell or Mac Terminal","text":"<p>First, if you are off campus, then you must be connected to the Cornell VPN before attempting to use X2Go to access the <code>ecelinux</code> servers (see Section 1). To start PowerShell click the Start menu then search for Windows PowerShell. To start Mac Terminal go to your Applications folder and choose Utilities &gt; Terminal, or open Spotlight, type Terminal, and press enter.</p>"},{"location":"ece2300-tut00-remote-access/#22-logging-into-ecelinux-servers-with-powershell-or-mac-terminal","title":"2.2. Logging into <code>ecelinux</code> Servers with PowerShell or Mac Terminal","text":"<p>After starting PowerShell or Mac Terminal, type in the following command at the prompt to log into the <code>ecelinux</code> servers using SSH.</p> <pre><code>% ssh netid@ecelinux.ece.cornell.edu\n</code></pre> <p>Replace <code>netid</code> with your Cornell NetID in the command above. You should not enter the <code>%</code> character. We use the <code>%</code> character to indicate what commands we should enter on the command line. Executing the command will prompt you to enter your Cornell NetID password, and then you should be connected to the <code>ecelinux</code> servers.</p> <p>The very first time you log into the <code>ecelinux</code> servers you may see a warning like this:</p> <pre><code> The authenticity of host \u2019ecelinux.ece.cornell.edu (128.253.51.206)\u2019\n can\u2019t be established. ECDSA key fingerprint is\n SHA256:smwMnf9dyhs5zW5I279C5oJBrTFc5FLghIJMfBR1cxI.\n Are you sure you want to continue connecting (yes/no)?\n</code></pre> <p>The very first time you log into the <code>ecelinux</code> servers it is okay to enter yes, but from then on if you continue to receive this warning please contact the course staff.</p> <p>Once you have opened a terminal, the very first thing you need to do after logging into the <code>ecelinux</code> servers is source the course setup script. This will ensure your environment is setup with everything you need for working on the laboratory/programming assignments. Enter the following command on the command line:</p> <pre><code>% source setup-ece2300.sh\n</code></pre> <p>Again, you should not enter the <code>%</code> character. You should now see a blue <code>ECE 2300</code> in your prompt which means your environment is setup for the course. The following figure shows what your prompt should look like if you have sourced the course setup script. See the final section of this tutorial for more on how to automatically source the setup script every time you log into the <code>ecelinux</code> servers.</p>"},{"location":"ece2300-tut00-remote-access/#23-nano-text-editor","title":"2.3. Nano Text Editor","text":"<p>Nano is a text-based editor installed on the <code>ecelinux</code> servers. The editor is easy to learn and use, but very simple. To experiment with Nano, we will first grab a text file using the <code>wget</code> command. The next tutorial discusses this command in more detail.</p> <pre><code>% wget http://www.csl.cornell.edu/courses/ece2300/overview.txt\n</code></pre> <p>You can start nano by typing the command <code>nano</code> at the Linux command line and optionally specifying the filename you want to view and edit.</p> <pre><code>% nano overview.txt\n</code></pre> <p>Notice that the editor specifies most of the useful commands at the bottom of the terminal screen. The symbol <code>\\^</code> indicates the <code>CONTROL</code> key. To type any text you want, just move the cursor to the required position and use the keyboard. To save your changes press <code>CONTROL+O1 (i.e., press the</code>CONTROL1 key and the <code>O1 key at the same time) and press the</code>1 key after specifying the filename you want to save to. You can quit by pressing <code>CONTROL+X1. Use</code>CONTROL+G1 for help. <p></p>"},{"location":"ece2300-tut00-remote-access/#3-remote-access-via-vs-code","title":"3. Remote Access via VS Code","text":"<p>While combining PowerShell or Mac Terminal with a text-based editor like Nano can certainly work, it is not the most productive development setup. We strongly recommend using VS Code as your primary remote access option for code development. VS Code offers a nice balance of productive features while also working well with moderate internet speeds.</p> <p>VS Code uses a unique approach where the GUI interface runs completely on your local laptop/workshop and then automatically handles copying files back and forth between your local laptop/workshop and the <code>ecelinux</code> servers. VS Code is portable across many operating systems and has a thriving ecosystem of extensions and plugins enabling it to function as a full-featured IDE for languages from C to Javascript. More information about VS Code is here:</p> <ul> <li>https://code.visualstudio.com</li> <li>https://code.visualstudio.com/docs</li> </ul>"},{"location":"ece2300-tut00-remote-access/#31-installing-vs-code-on-your-laptopworkstation","title":"3.1. Installing VS Code on Your Laptop/Workstation","text":"<p>You can download VS Code by simply going to the main VS Code webpage:</p> <ul> <li>https://code.visualstudio.com</li> </ul> <p>There should be an obvious link that says <code>Download for Windows'' or</code>Download for MacOS''. Click on that link. On Mac OS X, you will need to drag the corresponding Visual Student Code.app to your Applications folder.</p>"},{"location":"ece2300-tut00-remote-access/#32-starting-and-configuring-vs-code","title":"3.2. Starting and Configuring VS Code","text":"<p>First, if you are off campus, then you must be connected to the Cornell VPN before attempting to use VS Code to access the <code>ecelinux</code> servers (see Section 1). Start by opening VS Code. The exact way you do this will depend on whether you are using a Windows OS or Mac OS X laptop/workstation.</p> <p>The key to VS Code is installing the correct extensions. You will need extensions for the Verilog hardware description language (HDL). We also want to install a special extension which will enable remotely accessing the <code>ecelinux</code> servers using SSH. Choose View &gt; Extensions from the menubar. Enter the name of the extension in the ``Search Extensions in Marketplace'' and then click the blue \\IT{Install} button. Here are the names of the extensions to install:</p> <ul> <li>Remote - SSH (use the one from Microsoft)</li> <li>Verilog (use the one from Masahiro Hiramori)</li> <li>Surfer (use the one from surfer-project)</li> </ul> <p></p> <p></p> <p></p>"},{"location":"ece2300-tut00-remote-access/#33-logging-into-ecelinux-servers-with-vs-code","title":"3.3. Logging into <code>ecelinux</code> Servers with VS Code","text":"<p>After starting VS Code, choose View &gt; Command Palette from the menubar. Enter the following command in the command palette:</p> <pre><code>Remote-SSH: Connect Current Window to Host..\n</code></pre> <p>As you start typing matching commands will be displayed and you can just click the command when you see it. VS Code will then ask you to Select configured SSH host or enter user@host, and you should enter the following:</p> <pre><code>netid@ecelinux.ece.cornell.edu\n</code></pre> <p>Replace <code>netid</code> with your Cornell NetID in the command above. If you are on a Windows OS laptop/workstation, then you may see a pop-up which stays that the Windows Defender Firewall as blocked some features of this app. This is not a problem. Simply click Cancel.</p> <p>You might also see a drop down which asks you to choose the operating system of the remote server with options like Linux and Windows. Choose Linux.</p> <p>Finally, the very first time you log into the <code>ecelinux</code> servers you may see a warning like this:</p> <pre><code>\"ecelinux.ece.cornell.edu\" has fingerprint\n\"SHA256:YCh2FiadeTXEzuSkC0AOdglBgPciwc8WvcCPncvr2Fs\"\nAre you sure you want to continue?\nContinue\nCancel\n</code></pre> <p>The very first time you log into the <code>ecelinux</code> servers it is okay to enter yes, but from then on if you continue to receive this warning please contact the course staff.</p> <p>Hopefully, VS Code will now prompt you to enter your Cornell NetID password, and then you should be connected to the <code>ecelinux</code> servers.</p> <p>Also the very first time you log into the <code>ecelinux</code> servers you will see a pop up dialog box in the lower right-hand corner which says Setting up SSH host ecelinux.ece.cornell.edu (details) Initializing.... It might take up to a minute for everything to be setup; please be patient! Once the pop up dialog box goes away and you see SSH: ecelinux.ece.cornell.edu in the lower left-hand corner of VS Code then you know you are connected to the <code>ecelinux</code> servers.</p> <p>The final step is to make sure your extensions for the Verilog HDL are also installed on the server. Choose View &gt; Extensions from the menubar. Use the \"Search Extensions in Marketplace\" to search for the same Verilog HDL extensions that we installed earlier. Instead of saying Install it should now say Install in SSH: ecelinux.ece.cornell.edu. Install the Verilog HDL extension on the <code>ecelinux</code> servers. You only need to do this once, and then next time this extension will already be installed on the <code>ecelinux</code> servers.</p>"},{"location":"ece2300-tut00-remote-access/#34-using-vs-code","title":"3.4. Using VS Code","text":"<p>VS Code includes an integrated file explorer which makes it very productive to browse and open files. Choose View &gt; Explorer from the menubar, and then click on Open Folder. VS Code will then ask you to Open File Or Folder with a default of <code>/home/netid</code>. Click OK.</p> <p>You might see a pop-up which asks you Do you trust the authors of the   files in this folder? Since you will only be browsing your own files   on the <code>ecelinux</code> server, it is fine to choose Yes, I trust the   authors.</p> <p>This will reload VS Code, and you should now you will see a file explore in the left sidebar. You can easily browse your directory hierarchy, open files by clicking on them, create new files, and delete files.</p> <p>VS Code includes an integrated terminal which will give you access to the Linux command line on the <code>ecelinux</code> servers. Choose Terminal &gt; New Terminal from the menubar. You should see the same kind of Linux command line prompt that you saw when using either PowerShell or Mac Terminal. The very first thing you need to do after logging into the <code>ecelinux</code> servers is source the course setup script. This will ensure your environment is setup with everything you need for working on the laboratory/programming assignments. Enter the following command on the command line:</p> <pre><code>% source setup-ece2300.sh\n</code></pre> <p>Again, you should not enter the <code>%</code> character. You should now see a blue <code>ECE 2300</code> in your prompt which means your environment is setup for the course. See the final section of this tutorial for more on how to automatically source the setup script every time you log into the <code>ecelinux</code> servers.</p> <p>To experiment with VS Code, we will first grab a text file using the <code>wget</code> command. The next tutorial discusses this command in more detail. Type the following command in the VS Code integrated terminal.</p> <pre><code>% wget http://www.csl.cornell.edu/courses/ece2300/overview.txt\n</code></pre> <p>You can open a file in the integrated text editor using the <code>code</code> command like this:</p> <pre><code>% code overview.txt\n</code></pre> <p>The following figure shows what VS Code should look like if you have sourced the course setup script and opened the <code>overview.txt</code> file. Notice how the <code>overview.txt</code> file opened in a new tab at the top and the terminal remains at the bottom. This enables you to have easy access to editing files and the Linux command line at the same time.</p> <p></p>"},{"location":"ece2300-tut00-remote-access/#35-troubleshooting-remote-access-via-vs-code","title":"3.5. Troubleshooting Remote Access via VS Code","text":"<p>There may be issues where sometimes VS Code just keeps asking you for your password or VS Code just hangs when you try and connect to the <code>ecelinux</code> servers. This might mean VS Code is getting wedged. You can definitely ask the course staff to help, but you can also try to fix it on your own.</p> <p>One thing to try is to kill the VS Code server on the host. Choose View &gt; Command Palette from the menubar. Enter the following command in the command palette:</p> <pre><code>Remote-SSH: Kill VS Code Server on Host...\n</code></pre> <p>Another thing to try is to delete the <code>.vscode-server</code> directory on the sever. Of course, how can you delete this directory if you cannot use VS Code to access the <code>ecelinux</code> servers? You can use PowerShell or Mac Terminal to log into the <code>ecelinux</code> servers (see Section 2 or 3).</p> <p>Once you have gained access to the Linux command line on the <code>ecelinux</code> servers using either PowerShell or Mac Terminal, then you can delete the <code>.vscode-server</code> directory like this:</p> <pre><code>% rm -rf .vscode-server\n</code></pre> <p>Be very careful with the <code>rm</code> command since it can permanently delete files!</p> <p>Another option is to directly log into a specific <code>ecelinux</code> server. So instead of loging into <code>ecelinux.ece.cornell.edu</code> (which will automatically pick an <code>ecelinux</code> server for you to use) you can log into <code>ecelinux-01.ece.cornell.edu</code>, <code>ecelinux-02.ece.cornell.edu</code>, and so on.</p> <p>Note that using the <code>Remote-SSH: Add new SSH host...</code> option does not always seem to work on Microsoft Windows OS laptops/workstations. This is why we recommend just using <code>Remote-SSH: Connect Current Window to Host...</code> directly.</p> <p>Sometimes VS Code can take a very long time to save a file. This is usually because VS Code is trying to auto-format the file on the <code>ecelinux</code> servers. To turn off auto-formatting, open the VS Code settings menu. On Windows OS, choose File &gt; Preferences &gt; Settings from the menubar. On Mac OS X, choose Code &gt; Preferences &gt; Settings from the menubar. Click on Text Editor and then Formatting. Make sure Format On Save is not checked.</p>"},{"location":"ece2300-tut00-remote-access/#4-sourcing-course-setup-script-with-auto-setup","title":"4. Sourcing Course Setup Script with Auto Setup","text":"<p>The previous sections have demonstrated how to remotely access the <code>ecelinux</code> servers, get to the Linux command line, and source the course setup script. Again, you must source the course setup script before doing any work related to this course! The course setup script configures everything so you have the right environment to work on the laboratory/programming assignments.</p> <p>Since it can be tedious to always remember to source the course setup script, you can also use auto setup which will automatically source the course setup for you when you open a terminal. Note that if the environment for ECE 2300 conflicts with the environment required by a different course then you will need to manually source the setup script when you are working on this course. Enter the following command on the command line to use auto setup:</p> <pre><code> % source setup-ece2300.sh --enable-auto-setup\n</code></pre> <p>Now completely logout of the <code>ecelinux</code> servers then log back in and get to the Linux command line. The exact way to do this depends on which remote access option you using. You should see <code>ECE 2300</code> in the prompt meaning your environment is automatically setup for the course. If at anytime you need to disable auto setup you can use the following command:</p> <pre><code> % source setup-ece2300.sh --disable-auto-setup\n</code></pre> <p>Again, if for any reason running the setup script prevents you from using tools for another course, you cannot use the auto setup. You will need to run the setup script manually every time you want to work on a laboratory/programming assignment for this course.</p>"},{"location":"ece2300-tut01-linux/","title":"Tutorial 1: Linux Development Environment","text":"<p>The laboratory assignments for this course are designed assuming you will be using a Linux (or UNIX-like) operating system for development. Basic Linux knowledge is essential to successfully complete this work and a more in-depth understanding enhances productivity. This tutorial covers the computing resources to be used in the course and offers a brisk introduction to the Linux operating system for first time users including some details specific to this course.</p> <p>Before you begin, make sure that you have logged into the <code>ecelinux</code> servers as described in the remote access tutorial. You will need to open a terminal and be ready to work at the Linux command line using VS Code. To follow along with the tutorial, type the commands without the <code>%</code> character. In addition to working through the commands in the tutorial, you should also try the more open-ended activities.</p> <p>Before you begin, make sure that you have sourced the <code>setup-ece2300.sh</code> script as described in the remote access tutorial. Sourcing the setup script sets up the environment required for this tutorial.</p>"},{"location":"ece2300-tut01-linux/#1-the-linux-command-line","title":"1. The Linux Command Line","text":"<p>In this section, we introduce the basics of working at the Linux command line. Our goal is to get you comfortable with commands required to complete the laboratory assignments. The shell is the original Linux user interface which is a text-based command-line interpreter. The default shell on the <code>ecelinux</code> machines is Bash. While there are other shells such as <code>sh</code>, <code>csh</code>, and <code>tcsh</code>, for this course we will always assume you are using Bash. As mentioned above, we use the <code>%</code> character to indicate commands that should be entered at the Linux command line, but you should not include the actual <code>%</code> character when typing in the commands on your own. To make it easier to cut-and-paste commands from this tutorial document onto the command line, you can tell Bash to ignore the <code>%</code> character using the following command:</p> <pre><code>% alias %=\"\"\n</code></pre> <p>Now you can cut-and-paste a sequence of commands from this tutorial document and Bash will not get confused by the <code>%</code> character which begins each line.</p>"},{"location":"ece2300-tut01-linux/#11-hello-world","title":"1.1. Hello World","text":"<p>We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the <code>echo</code> command. The <code>echo</code> command simply \"echoes'' its input to the console.</p> <pre><code>% echo \"Hello, World\"\n</code></pre> <p>The string we provide to the <code>echo</code> command is called a \\IT{command   line argument}. We use command line arguments to tell commands what they should operate on. Although simple, the <code>echo</code> command can very useful for creating simple text files, displaying environment variables, and general debugging.</p> <p>Activity 1: Experiment with <code>echo</code></p> <p>Experiment with using the <code>echo</code> command to display different messages.</p>"},{"location":"ece2300-tut01-linux/#12-manual-pages","title":"1.2. Manual Pages","text":"<p>You can learn more about any Linux command by using the <code>man</code> command. Try using this to learn more about the <code>echo</code> command.</p> <pre><code>% man echo\n</code></pre> <p>You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the <code>q</code> key to quit viewing the manual. You can even learn about the <code>man</code> command itself by using <code>man man</code>. As you follow the tutorial, feel free to use the <code>man</code> command to learn more about the commands we cover.</p> <p>Activity 2: Experiment with <code>man</code></p> <p>Use the <code>man</code> command to learn more about the <code>cat</code> command.</p>"},{"location":"ece2300-tut01-linux/#13-create-view-and-list-files","title":"1.3. Create, View, and List Files","text":"<p>We can use the <code>echo</code> command and a feature called ecommand output redirection to create simple text files. We will discuss command output redirection in more detail later in the tutorial. Command output redirection uses the <code>&gt;</code> operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named <code>ece2300-tut01.txt</code> that simply contains the text \"Digital Logic and Computer Organization\"</p> <pre><code>% echo \"Digital Logic and Computer Organization\" &gt; ece2300-tut01.txt\n</code></pre> <p>We can use the <code>cat</code> command to quickly display the contents of a file.</p> <pre><code>% cat ece2300-tut01.txt\n</code></pre> <p>For larger files, <code>cat</code> will output the entire file to the console so it may be hard to read the file as it streams past. We can use the <code>less</code> command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the <code>q</code> key to quit viewing the file.</p> <pre><code>% less ece2300-tut01.txt\n</code></pre> <p>You can use the <code>ls</code> command to list the filenames of the files you have created.</p> <pre><code>% ls\n</code></pre> <p>We can provide command line options to the <code>ls</code> command to modify the command's behavior. For example, we can use the <code>-1</code> (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the <code>-l</code> (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file.</p> <pre><code>% ls -1\n% ls -l\n</code></pre> <p>You should see the newly created <code>ece2300-tut01.txt</code> file along with some additional directories or folders. We will discuss directories in the next section. Use the following commands to create a few more files using the <code>echo</code> command and command output redirection, and then list the files again.</p> <pre><code>% echo \"Application\" &gt; ece2300-tut01-layer1.txt\n% echo \"Algorithm\"   &gt; ece2300-tut01-layer2.txt\n% ls -1\n</code></pre> <p>Activity 3: Create New File</p> <p>Create a new file named <code>ece2300-tut01-layer3.txt</code> which contains the third layer in the computing systems stack (i.e., programming language). Use <code>cat</code> and <code>less</code> to verify the file contents.</p>"},{"location":"ece2300-tut01-linux/#14-create-change-and-list-directories","title":"1.4. Create, Change, and List Directories","text":"<p>Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an <code>ecelinux</code> machine, you will be in your home directory. This is your own private space on the server that you can use to work on the laboratory assignments and store your files. You can use the <code>pwd</code> command to print the directory in which you are currently working, which is known as the current working directory.</p> <pre><code>% pwd\n/home/netid\n</code></pre> <p>You should see output similar to what is shown above, but instead of <code>netid</code> it should show your actual NetID. The <code>pwd</code> command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named <code>home</code> that contains a directory named <code>netid</code>. This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash (<code>/</code>) to separate directories, while Windows uses a back slash (<code>\\</code>) for the same purpose.</p> <p>We can use the <code>mkdir</code> command to make new directories. The following command will make a new directory named <code>ece2300</code> within your home directory.</p> <pre><code>% mkdir ece2300\n</code></pre> <p>We can use the <code>cd</code> command to change our current working directory. The following command will change the current working directory to be the newly created <code>ece2300</code> directory, before displaying the current working directory with the <code>pwd</code> command.</p> <pre><code>% cd ece2300\n% pwd\n/home/netid/ece2300\n</code></pre> <p>Use the <code>mkdir</code>, <code>cd</code>, and <code>pwd</code> commands to make another directory.</p> <pre><code>% mkdir tut01\n% cd tut01\n% pwd\n/home/netid/ece2300/tut01\n</code></pre> <p>We sometimes say that <code>tut01</code> is a subdirectory or a child directory of the <code>ece2300</code> directory. We might also say that the <code>ece2300</code> directory is the parent directory of the <code>tut01</code> directory.</p> <p>There are some important shortcuts that we can use with the <code>cd</code> command to simplify navigating the file system. The special directory named <code>.</code> (i.e., one dot) always refers to the current working directory. The special directory named <code>..</code> (i.e., two dots) always refers to the parent of the current working directory. The special directory named <code>~</code> (i.e., a tilde character) always refers to your home directory. The special directory named <code>/</code> (e.g., single forward slash) always refers to the highest-level root directory. The following commands illustrate how to navigate up and down the directory hierarchy we have just created.</p> <pre><code>% pwd\n/home/netid/ece2300/tut01\n% cd .\n% pwd\n/home/netid/ece2300/tut01\n% cd ..\n% pwd\n/home/netid/ece2300\n% cd ..\n% pwd\n/home/netid\n% cd ece2300/tut01\n% pwd\n/home/netid/ece2300/tut01\n% cd\n% pwd\n/home/netid\n% cd /\n% pwd\n/\n% cd ~/ece2300\n% pwd\n/home/netid/ece2300\n</code></pre> <p>Notice how we can use the <code>cd</code> command to change the working directory to another arbitrary directory by simply using a directory path (e.g., <code>ece2300/tut01</code>). These are called relative paths because the path is relative to your current working directory. You can also use an absolute path which always starts with the root directory to concretely specify a directory irrespective of the current working directory. A relative path is analogous to directions to reach a destination from your current location (e.g., How do I get to the coffee shop from my current location?), while an absolute path is analogous to directions to reach a destination from a centralized location (e.g., How do I get to the coffee shop from the center of town?).</p> <pre><code>% pwd\n/home/netid/ece2300\n% cd /home/netid/ece2300/tut01\n% pwd\n/home/netid/ece2300/tut01\n% cd\n% pwd\n/home/netid\n</code></pre> <p>This example illustrates one more useful shortcut. The <code>cd</code> command with no command line arguments always changes the current working directory to your home directory. We can use the <code>ls</code> command to list files as well as directories. Use the following commands to create a new file and directory in the <code>ece2300/tut01</code> subdirectory, and then list the file and directory.</p> <pre><code>% cd ~/ece2300/tut01\n% echo \"Computer Systems Programming\" &gt; ece2300-tut01.txt\n% mkdir dirA\n% ls -1\n</code></pre> <p>You should see both the <code>dirA</code> subdirectory and the newly created <code>ece2300-tut01.txt</code> file listed. Feel free to use the <code>cat</code> command to verify the file contents of the newly created file. We can use the <code>tree</code> command to recursively list the contents of a directory. The following commands create a few more directories before displaying the directory hierarchy.</p> <pre><code>% cd ~/ece2300/tut01\n% mkdir -p dirB/dirB_1\n% mkdir -p dirB/dirB_2\n% mkdir -p dirC/dirC_1\n% cd ~/ece2300/tut01\n% tree\n.\n+-- dirA\n+-- dirB\n|   |-- dirB_1\n|   `-- dirB_2\n|-- dirC\n|   `-- dirC_1\n`-- ece2300-tut01.txt\n</code></pre> <p>Note that we are using the <code>-p</code> command line option with the <code>mkdir</code> command to make multiple nested directories in a single step.</p> <p>Activity 4: Creatring Directories and Files</p> <p>Experiment with creating additional directories and files within the <code>ece2300/tut01</code> subdirectory. Try creating deeper hierarchies with three or even four levels of nesting using the <code>-p</code> option to the <code>mkdir</code> command. Experiment with using the <code>.</code> and <code>..</code> special directories. Use the <code>tree</code> command to display your newly created directory hierarchy.</p>"},{"location":"ece2300-tut01-linux/#15-copy-move-and-remove-files-and-directories","title":"1.5. Copy, Move, and Remove Files and Directories}","text":"<p>We can use the <code>cp</code> command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section.</p> <pre><code>% cd ~/ece2300/tut01\n% cp ece2300-tut01.txt ece2300-tut01-a.txt\n% cp ece2300-tut01.txt ece2300-tut01-b.txt\n% ls -1\n</code></pre> <p>We can also copy one or more files into a subdirectory by using multiple source files and a final destination directory as the arguments to the <code>cp</code> command.</p> <pre><code>% cd ~/ece2300/tut01\n% cp ece2300-tut01.txt dirA\n% cp ece2300-tut01-a.txt ece2300-tut01-b.txt dirA\n% tree\n</code></pre> <p>We can use the <code>-r</code> command line option to enable the <code>cp</code> command to recursively copy an entire directory.</p> <pre><code>% cd ~/ece2300/tut01\n% tree\n% cp -r dirA dirD\n% tree\n</code></pre> <p>If we want to move a file or directory, we can use the <code>mv</code> command. As with the <code>cp</code> command, the first argument is the name of the file you want to move and the second argument is the new name of the file.</p> <pre><code>% cd ~/ece2300/tut01\n% mv ece2300-tut01.txt ece2300-tut01-c.txt\n% ls -1\n</code></pre> <p>Again, similar to the <code>cp</code> command, we can also move one or more files into a subdirectory by using multiple source files and a final destination directory as the arguments to the <code>mv</code> command.</p> <pre><code>% cd ~/ece2300/tut01\n% tree\n% mv ece2300-tut01-a.txt dirB\n% mv ece2300-tut01-b.txt ece2300-tut01-c.txt dirB\n% tree\n</code></pre> <p>We do not need to use the <code>-r</code> command line option to move an entire directory at once.</p> <pre><code>% cd ~/ece2300/tut01\n% tree\n% mv dirD dirE\n% tree\n</code></pre> <p>The following example illustrates how we can use the special <code>.</code> directory to move files from a subdirectory into the current working directory.</p> <pre><code>% cd ~/ece2300/tut01\n% tree\n% mv dirE/ece2300-tut01.txt .\n% tree\n</code></pre> <p>We can use the <code>rm</code> command to remove files. The following command removes a file from within the <code>ece2300/tut01</code> subdirectory.</p> <pre><code>% cd ~/ece2300/tut01\n% ls -1\n% rm ece2300-tut01.txt\n% ls -1\n</code></pre> <p>To clean up, we might want to remove the files we created in your home directory earlier in this tutorial.</p> <pre><code>% cd\n% rm ece2300-tut01.txt\n% rm ece2300-tut01-layer1.txt\n% rm ece2300-tut01-layer2.txt\n% rm ece2300-tut01-layer3.txt\n</code></pre> <p>We can use the <code>-r</code> command line option with the <code>rm</code> command to remove entire directories, but please be careful because it is relatively easy to permanently delete many files at once. See Section 2.3 for a useful command that you might want to use instead of the <code>rm</code> command to avoid accidentally deleting important work.</p> <pre><code>% cd ~/ece2300/tut01\n% ls -1\n% rm -r dirA dirB dirC dirE\n% ls -1\n</code></pre> <p>Activity 5: Copy, Move, and Remove Directories and Files</p> <p>Creating additional directories and files within the <code>ece2300/tut01</code> subdirectory, and then use the <code>cp</code>, <code>mv</code>, and <code>rm</code> commands to copy, move, and remove the newly created directories and files. Use the <code>ls</code> and <code>tree</code> commands to display your file and directory organization.</p>"},{"location":"ece2300-tut01-linux/#16-using-wget-to-download-files","title":"1.6. Using <code>wget</code> to Download Files","text":"<p>We can use the <code>wget</code> command to download files from the internet. For now, this is a useful way to retrieve a text file that we can use in the following examples.</p> <pre><code>% cd ~/ece2300/tut01\n% wget http://www.csl.cornell.edu/courses/ece2300/overview.txt\n% cat overview.txt\n</code></pre>"},{"location":"ece2300-tut01-linux/#17-using-grep-to-search-files","title":"1.7. Using <code>grep</code> to Search Files","text":"<p>We can use the <code>grep</code> command to search and display lines of a file that contain a particular pattern. The <code>grep</code> command can be useful for quickly searching the contents of the source files in your laboratory assignments. The command takes the pattern and the files to search as command line arguments. The following command searches \"digital logic\" in the <code>overview.txt</code> file downloaded in the previous section.</p> <pre><code>% cd ~/ece2300/tut01\n% grep \"digital logic\" overview.txt\n</code></pre> <p>You should see just the lines within the <code>overview.txt</code> file that contain the words \"digital logic\". We can use the <code>--line-number</code> command line option with the <code>grep</code> command to display the line number of each match.</p> <pre><code>% cd ~/ece2300/tut01\n% grep --line-number \"digital logic\" overview.txt\n</code></pre> <p>We can use the <code>-r</code> command line option to recursively search all files within a given directory hierarchy. In the following example, we create a subdirectory, copy the <code>overview.txt</code> file, and illustrate how we can use the <code>grep</code> command to recursively search for the word \"digital logic\".</p> <pre><code>% cd ~/ece2300/tut01\n% mkdir dirA\n% cp overview.txt dirA\n% grep -r --line-number \"digital logic\" .\n</code></pre> <p>Notice how we specify a directory as a command line argument (in this case the special <code>.</code> directory) to search the current working directory. You should see the three lines from both copies of the <code>overview.txt</code> file. The <code>grep</code> command also shows which file contains the match.</p> <p>As another example, we will search two special files named <code>/proc/cpuinfo</code> and <code>proc/meminfo</code>. These files are present on every modern Linux system, and they contain information about the processor and memory hardware in that system. The following command first uses the <code>less</code> command so you can browse the file, and then uses the <code>grep</code> command to search for <code>processor</code> in the <code>/proc/cpuinfo</code> file. Recall that with the <code>less</code> command, we use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the <code>q</code> key to quit viewing the file.</p> <pre><code>% cd ~/ece2300/tut01\n% less /proc/cpuinfo\n% grep \"processor\" /proc/cpuinfo\n</code></pre> <p>It should be pretty clear that you are using a system with multiple processors. You can also search to find out which company makes the processors and what clock frequency they are running at:</p> <pre><code>% cd ~/ece2300/tut01\n% grep \"vendor_id\" /proc/cpuinfo\n% grep \"cpu MHz\" /proc/cpuinfo\n</code></pre> <p>We can find out how much memory is in the system by searching for <code>MemTotal</code> in the <code>/proc/meminfo</code> file.</p> <pre><code>% cd ~/ece2300/tut01\n% grep \"MemTotal\" /proc/meminfo\n</code></pre> <p>Activity 6: Experimenting with <code>grep</code></p> <p>Try using <code>grep</code> to search for the words \"computer\" in the <code>overview.txt</code> file.</p>"},{"location":"ece2300-tut01-linux/#18-using-find-to-find-files","title":"1.8. Using <code>find</code> to Find Files","text":"<p>We can use the <code>find</code> command to recursively search a directory hierarchy for files or directories that match a specified criteria. While the <code>grep</code> command is useful for searching file contents, the <code>find</code> command is useful for quickly searching the file and directory names in your laboratory assignments. The <code>find</code> command is very powerful, so we will just show a very simple example. First, we create a few new files and directories.</p> <pre><code>% cd ~/ece2300/tut01\n% mkdir -p dirB/dirB_1\n% mkdir -p dirB/dirB_2\n% mkdir -p dirC/dirC_1\n% echo \"test\" &gt; dirA/file0.txt\n% echo \"test\" &gt; dirA/file1.txt\n% echo \"test\" &gt; dirB/dirB_1/file0.txt\n% echo \"test\" &gt; dirB/dirB_1/file1.txt\n% echo \"test\" &gt; dirB/dirB_2/file0.txt\n% tree\n</code></pre> <p>We will now use the <code>find</code> command to find all files named <code>file0.txt</code>. The <code>find</code> command takes one command line argument to specify where we should search and a series of command line options to describe what files and directories we are trying to find. We can also use command line options to describe what action we would like to take when we find the desired files and directories. In this example, we use the <code>--name</code> command line option to specify that we are searching for files with a specific name. We can also use more complicated patterns to search for all files with a specific filename prefix or extension.</p> <pre><code>% cd ~/ece2300/tut01\n% find . -name \"file0.txt\"\n</code></pre> <p>Notice that we are using the special <code>.</code> directory to tell the <code>find</code> command to search the current working directory and all subdirectories. The <code>find</code> command always searches recursively.</p> <p>Activity 7: Experimenting with <code>find</code></p> <p>Create additional files named <code>file2.txt</code> in some of the subdirectories we have already created. Use the <code>find</code> command to search for files named <code>file2.txt</code>.</p>"},{"location":"ece2300-tut01-linux/#19-using-tar-to-archive-files","title":"1.9. Using <code>tar</code> to Archive Files","text":"<p>We can use the <code>tar</code> command to \"pack\" files and directories into a simple compressed archive, and also to \"unpack\" these files and directories from the archive. This kind of archive is sometimes called a tarball. Most open-source software is distributed in this compressed form. It makes it easy to distribute code among collaborators and it is also useful to create backups of files. We can use the following command to create an archive of our tutorial directory and then remove the tutorial directory.</p> <pre><code>% cd ~/ece2300\n% tar -czvf tut01.tgz tut01\n% rm -r tut01\n% ls -l\n</code></pre> <p>Several command line options listed together as a single option (<code>-czvf</code>), where <code>c</code> specifies we want to create an archive, <code>z</code> specifies we should use \"gzip\" compression, <code>v</code> specifies verbose mode, and <code>f</code> specifies we will provide filenames to archive. The first command line argument is the name of the archive to create, and the second command line argument is the directory to archive. We can now extract the contents of the archive to recreate the tutorial directory. We also remove the archive.</p> <pre><code>% cd ~/ece2300\n% tar -xzvf tut01.tgz\n% rm tut01.tgz\n% tree tut01\n</code></pre> <p>Note that we use the <code>x</code> command line option with the <code>tar</code> command to specify that we intend to extract the archive.</p> <p>Activity 8: Experimenting with <code>tar</code></p> <p>Create an example directory within the <code>ece2300/tut01</code> subdirectory. Copy the <code>overview.txt</code> file and rename it to add example files to your new directory. Use the <code>tar</code> command to create and extract an archive of just this one new directory.</p>"},{"location":"ece2300-tut01-linux/#110-using-top-to-view-running-processes","title":"1.10. Using <code>top</code> to View Running Processes","text":"<p>You can use the <code>top</code> command to view what commands are currently running on the Linux system in realtime. This can be useful to see if there are many commands running which are causing the system to be sluggish. When finished you can use the <code>q</code> character to quit.</p> <pre><code>% top\n</code></pre> <p>The first line of the <code>top</code> display shows the number of users currently logged into the system, and the load average. The load average indicates how \"overloaded\" the system was over the last one, five, and 15 minutes. If the load average is greater than the number of processors in the system, it means your system will probably be sluggish. You can always try logging out and then back into the <code>ecelinux</code> servers to see if you get assigned to a different server in the cluster.</p>"},{"location":"ece2300-tut01-linux/#111-environment-variables","title":"1.11. Environment Variables","text":"<p>In the previous sections, we have been using the Bash shell to run various commands, but the Bash shell is actually a full-featured programming language. One aspect of the shell that is similar in spirit to popular programming languages, is the ability to write and read environment variables. The following commands illustrate how to write an environment variable named <code>ece2300_tut01_layer1</code>, and how to read this environment variable using the <code>echo</code> command.</p> <pre><code>% ece2300_tut01_layer1=\"application\"\n% echo ${ece2300_tut01_layer1}\n</code></pre> <p>Keep in mind that the names of environment variables can only contain letters, numbers, and underscores. Notice how we use the <code>${}</code> syntax to read an environment variable. There are a few built-in environment variables that might be useful:</p> <pre><code>% echo ${HOSTNAME}\n% echo ${HOME}\n% echo ${PWD}\n</code></pre> <p>We often use the <code>HOME</code> environment variable in directory paths like this:</p> <pre><code>% cd ${HOME}/ece2300\n</code></pre> <p>The <code>PWD</code> environment variable always holds the current working directory. We can use environment variables as options to commands other than <code>echo</code>. A common example is to use an environment variable to \"remember\" a specific directory location, which we can quickly return to with the <code>cd</code> command like this:</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% TUT01=${PWD}\n% cd\n% pwd\n/home/netid\n% cd ${TUT01}\n% pwd\n/home/netid/ece2300/tut01\n</code></pre> <p>Activity 9: Experimenting with Environment Variables</p> <p>Create a new environment variable named <code>ece2300_tut01_layer2</code> and write it with the second layer in the computer systems stack (i.e., algorithm). Use the <code>echo</code> command to display this environment variable. Experiment with creating a new subdirectory within <code>ece2300/tut01</code> and then using an environment variable to \"remember\" that location.</p>"},{"location":"ece2300-tut01-linux/#112-command-output-redirection","title":"1.12. Command Output Redirection","text":"<p>We have already seen using the <code>echo</code> command and command output redirection to create simple text files. Here is another example:</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% echo \"Application\" &gt; computing-stack.txt\n% cat computing-stack.txt\n</code></pre> <p>The <code>&gt;</code> operator tells the Bash shell to take the output from the command on the left and overwrite the file named on the right. We can use any command on the left. For example, we can save the output from the <code>pwd</code> command or the <code>man</code> command to a file for future reference.</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% pwd &gt; cmd-output.txt\n% cat cmd-output.txt\n% man pwd &gt; cmd-output.txt\n% cat cmd-output.txt\n</code></pre> <p>We can also use the <code>&gt;&gt;</code> operator which tells the Bash shell to take the output from the command on the left and append the file named on the right. We can use this to create multiline text files:</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% echo \"Application\"           &gt; computing-stack.txt\n% echo \"Algorithm\"            &gt;&gt; computing-stack.txt\n% echo \"Programming Language\" &gt;&gt; computing-stack.txt\n% echo \"Operating System\"     &gt;&gt; computing-stack.txt\n% cat computing-stack.txt\n</code></pre> <p>Activity 10: Experimenting with Output Redirection</p> <p>Add the remaining levels of the computing stack (i.e., compiler, instruction-set architecture, microarchitecture, register-transfer-level, gate-level, circuits, devices, technology) to the <code>computing-stack.txt</code> text file. Use the <code>cat</code> command to verify the file contents.</p>"},{"location":"ece2300-tut01-linux/#113-command-chaining","title":"1.13. Command Chaining","text":"<p>We can use the <code>&amp;&amp;</code> operator to specify two commands that we want to chaining together. The second command will only execute if the first command succeeds. Below is an example.</p> <pre><code>% cd ${HOME}/ece2300/tut01 &amp;&amp; cat computing-stack.txt\n</code></pre> <p>Activity 11: Experimenting with Command Chaining</p> <p>Create a single-line command that combines creating a new directory with the <code>mkdir</code> command and then immediately changes into the directory using the <code>cd</code> command.</p>"},{"location":"ece2300-tut01-linux/#114-command-pipelining","title":"1.14. Command Pipelining","text":"<p>The Bash shell allows you to run multiple commands simultaneously, with the output of one command becoming the input to the next command. We can use this to assemble \"pipelines\"; we \"pipe\" the output of one command to another command for further actions using the <code>|</code> operator.</p> <p>The following example uses the <code>grep</code> command to search the special <code>proc/cpuinfo</code> file for lines containing the word \"processor\" and then pipes the result to the <code>wc</code> command. The <code>wc</code> command counts the number of characters, words, or lines of its input. We use the <code>-l</code> command line option with the <code>wc</code> command to count the number of lines.</p> <pre><code>% grep processor /proc/cpuinfo | wc -l\n</code></pre> <p>This is a great example of the Linux philosophy of providing many simple commands that can be combined to create more powerful functionality. Essentially the pipeline we have created is a command that tells us the number of processors in our system.</p> <p>As another example, we will pipe the output of the <code>last</code> command to the <code>grep</code> command. The <code>last</code> command lists the names of all of the users that have logged into the system since the system was rebooted. We can use <code>grep</code> to search for your NetID and thus quickly see how when you previously have logged into this system.</p> <pre><code>% last | grep netid\n</code></pre> <p>We can create even longer pipelines. The following pipeline will report the number of times you have logged into the system since it was rebooted.</p> <pre><code>% last | grep netid | wc -l\n</code></pre> <p>Activity 12: Experimenting with Command Pipelines</p> <p>Use the <code>cat</code> command with the <code>overview.txt</code> file and pipe the output to the <code>grep</code> command to search for the word \"\"memories\". While this is not as fast as using <code>grep</code> directly on the file, it does illustrate how many commands (e.g., <code>grep</code>) can take their input specified as a command line argument or through a pipe.</p>"},{"location":"ece2300-tut01-linux/#114-bash-shell-scripts","title":"1.14. Bash Shell Scripts","text":"<p>If you find yourself continually having to use the same complex commands over and over, consider creating a Bash shell script to automatically execute those commands. A Bash shell script is just a text file with a list of commands that you can run using the <code>source</code> command.</p> <p>For example, let's create a Bash shell script to automatically grep for information about the processor and memory in a single step. Use VS Code to open a new file called <code>get-processor-memory-info.sh</code> (note that by convention we usually use the <code>.sh</code> extension for Bash shell scripts).</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% code get-processor-memory-info.sh\n</code></pre> <p>Then enter the following commands into this new Bash shell script.</p> <pre><code>grep \"processor\" /proc/cpuinfo\ngrep \"vendor_id\" /proc/cpuinfo\ngrep \"cpu MHz\"   /proc/cpuinfo\ngrep \"MemTotal\"  /proc/meminfo\n</code></pre> <p>Then save the Bash shell script and execute it using the <code>source</code> command.</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% source get-processor-memory-info.sh\n</code></pre> <p>Activity 13: Experimenting with Bash Shell Scripts</p> <p>Create a new Bash shell script named <code>wget-and-grep.sh</code>. The Bash shell script should use <code>wget</code> to get the <code>overview.txt</code> file for the course and then uses grep to find instances of the workd \"digital logic\" in this file. See earlier examples in this tutorial for the commands required for both steps. Then use <code>source</code> to execute the new Bash shell script.</p>"},{"location":"ece2300-tut01-linux/#115-aliases-wildcards-command-history-and-tab-completion","title":"1.15. Aliases, Wildcards, Command History, and Tab Completion","text":"<p>In this section, we describe some miscellaneous features of the Bash shell which can potentially be quite useful in increasing your productivity.</p> <p>Aliases are a way to create short names for command sequences to make it easier to quickly execute those command sequences in the future. For example, assume that you frequently want to change to a specific directory. We can create an alias to make this process take just two keystrokes.</p> <pre><code>% alias ct=\"cd ${HOME}/ece2300/tut01\"\n% ct\n% pwd\n/home/academic/netid/ece2300/tut01\n</code></pre> <p>If you always want this alias to be available whenever you login to the system, you can save it in your <code>.bashrc</code> file. The <code>.bashrc</code> is a special Bash script that is run on every invocation of a Bash shell.</p> <pre><code>% echo \"alias ct=\\\"cd ${HOME}/ece2300/tut01\\\"\" &gt;&gt; ${HOME}/.bashrc\n</code></pre> <p>The reason we have to use a back slash (<code>\\</code>) in front of the double quotes is to make sure the <code>echo</code> command sees this command line argument as one complete string.</p> <p>Wildcards make it easy to manipulate many files and directories at once. Whenever we specify a file or directory on the command line, we can often use a wildcard instead. In a wildcard, the asterisk (<code>*</code>) will match any sequence of characters. The following example illustrates how to list all files that end in the suffix <code>.txt</code> and then copies all files that match the wildcard from one directory to another.</p> <pre><code>% cd ${HOME}/ece2300/tut01\n% ls *.txt\n% cp dirA/file*.txt dirB\n% tree\n</code></pre> <p>The Bash shell keeps a history of everything you do at the command line. You can display the history with the <code>history</code> command. To rerun a previous command, you can use the <code>!</code> operator and the corresponding command number shown with the <code>history</code> command.</p> <pre><code>% history\n</code></pre> <p>You can pipe the output of the <code>history</code> command to the <code>grep</code> command to see how you might have done something in the past.</p> <pre><code>% history | grep wc\n</code></pre> <p>If you press the up arrow key at the command line, the Bash shell will show you the previous command you used. Continuing to press the up/down keys will enable you to step through your history. It is very useful to press the up arrow key once to rerun your last command.</p> <p>The Bash shell supports tab completion. When you press the tab key twice after entering the beginning of a filename or directory name, Bash will try to automatically complete the filename or directory name. If there is more than one match, Bash will show you all of these matches so you can continue narrowing your search.</p>"},{"location":"ece2300-tut01-linux/#2-course-specific-linux-commands","title":"2. Course-Specific Linux Commands","text":"<p>In this section, we describe various aspects of the development environment that are specific to the severs used in the course.</p>"},{"location":"ece2300-tut01-linux/#21-course-setup-script","title":"2.1. Course Setup Script","text":"<p>As discussed in the remote access tutorial, the very first thing you need to do after logging into the <code>ecelinux</code> servers is source the course setup script. This will ensure your environment is setup with everything you need for working on the laboratory assignments. Enter the following command on the command line:</p> <pre><code>% source setup-ece2300.sh\n</code></pre> <p>You should now see <code>ECE 2300</code> in your prompt which means your environment is setup for the course.</p> <p>It can be tedious to always remember to source the course setup script. You can also use auto setup which will automatically source the course setup for you when you open a terminal. Note that if the environment for ECE 2300 conflicts with the environment required by a different course then you will need to manually source the setup script when you are working on this course. Enter the following command on the command line to use auto setup:</p> <pre><code>% source setup-ece2300.sh --enable-auto-setup\n</code></pre> <p>Now close the terminal and log out completely from the <code>ecelinux</code> servers. Log back in and you should see <code>ECE 2300</code> in the prompt meaning your environment is automatically setup for the course. If at anytime you need to disable auto setup you can use the following command:</p> <pre><code>% source setup-ece2300.sh --disable-auto-setup\n</code></pre> <p>Again, if for any reason running the setup script prevents you from using tools for another course, you cannot use the auto setup. You will need to run the setup script manually every time you want to work on this course.</p>"},{"location":"ece2300-tut01-linux/#22-using-quota-to-check-your-space-usage","title":"2.2. Using <code>quota</code> to Check Your Space Usage","text":"<p>Students are allocated 10GB of storage on the servers. You can use the following command to show much space you are using:</p> <pre><code>% quota -s\n</code></pre> <p>The <code>blocks</code> column is how much data you are using, and the <code>quota</code> column is your quota. If you have exceed the 10GB quota, you can browse your home directory and list the size of files and the contents of directories with the <code>du</code> command:</p> <pre><code>% cd ${HOME}\n% du -sh *\n</code></pre> <p>By recursively changing directories and examining the sizes of files and directories you can figure out what you need to delete. We can pipe the output of <code>du</code> to the <code>sort</code> and <code>head</code> commands to find the top 20 largest files and directories like this:</p> <pre><code>% cd ${HOME}\n% du -xak . | sort -nr | head --lines=20\n</code></pre> <p>Or just use the following to generate a human readable summary of the size of files/directories in the current working directory. Note that it can take 20--30 seconds for this command to finish, so please be patient.</p>"},{"location":"ece2300-tut01-linux/#23-using-trash-to-safely-remove-files","title":"2.3. Using <code>trash</code> to Safely Remove Files","text":"<p>We have installed a simple program called <code>trash</code> which moves files you wish to delete into a special subdirectory of your home directory located at <code>${HOME}/tmp/trash</code>. The following commands create a file and then deletes it using <code>trash</code>.</p> <pre><code>% cd ${HOME}\n% echo \"This file will be deleted.\" &gt; testing.txt\n% trash testing.txt\n% echo \"This file will also be deleted.\" &gt; testing.txt\n% trash testing.txt\n% ls ${HOME}/tmp/trash\n</code></pre> <p>If you look in <code>${HOME}/tmp/trash</code> you will see subdirectories organized by date. Look in the subdirectory with today's date and you should two files corresponding to the two files you deleted. We highly recommend always using the <code>trash</code> command instead of <code>rm</code> since this avoids accidentally deleting your work.</p>"},{"location":"ece2300-tut02-git/","title":"Tutorial 2: Git Distributed Version Control System","text":"<p>In this course, we will be using Git as our revision control and source code management system. We will be using GitHub for centralized online repository hosting, and GitHub Actions for online continuous integration testing. These tools will enable us to adopt an agile hardware development methodology so your group can rapidly collaborate and iterate on the design, verification, and evaluation of the lab assignments. This tutorial covers how to: setup your GitHub account, use Git for basic incremental development, use GitHub to collaborate with your group, manage Git branches and GitHub pull requests, and use GitHub actions. This tutorial assumes that you have completed the remote access and Linux tutorials.</p> <p>Before you begin, make sure that you have logged into the <code>ecelinux</code> servers as described in the remote access tutorial. You will need to open a terminal and be ready to work at the Linux command line using VS Code. To follow along with the tutorial, type the commands without the <code>%</code> character. In addition to working through the commands in the tutorial, you should also try the more open-ended activities.</p> <p>Before you begin, make sure that you have sourced the setup-ece2300.sh script or that you have enabled auto setup. Sourcing the setup script sets up the environment required for this tutorial.</p>"},{"location":"ece2300-tut02-git/#1-setting-up-your-github-account","title":"1. Setting up Your GitHub Account","text":"<p>GitHub is an online service that hosts centralized Git repositories for a growing number of open-source projects. It has many useful features including a web-based source browser, history browser, branch management, merge requests, code review, issue tracking, and even a built-in wiki attached to every repository. We have created a dedicated GitHub organization for the course located here:</p> <ul> <li>https://github.com/cornell-ece2300</li> </ul> <p>The course staff will add all officially registered students to the course organization. For most of this tutorial you will be using a public repository in your own personal GitHub account, but you will be using a private repository in our course GithHub organization for all of your lab assignments. Note that we will not be using the version of GitHub hosted at Cornell We will instead be using the public version of GitHub at <code>github.com</code>. You can check to see if you have a GitHub account on the public version of GitHub here:</p> <ul> <li>https://github.com/githubid</li> </ul> <p>where <code>githubid</code> is your GitHub username on the public version of GitHub. You must replace <code>githubid</code> with your real GitHub username for this link to work! If the above link still does not work, then you do not have an account on the public version of GitHub. You will need to create one here:</p> <ul> <li>https://github.com/join</li> </ul> <p>Your NetID makes a great GitHub username. If you are creating a new GitHub account, then be sure to use your Cornell email address. If you have an existing account it is fine for it to use a non-Cornell email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Please also consider uploading a profile photo to GitHub; it makes it more fun to interact on GitHub if we all know what each other look like. Go to the following page and enter your first and last name in the Name field, and then consider uploading a profile photo.</p> <ul> <li>https://github.com/settings/profile</li> </ul> <p>Once you have a GitHub username, please fill out the following form on Canvas so the instructors know the mapping from your NetID to your GitHub username.</p> <ul> <li>http://www.csl.cornell.edu/courses/ece2300/githubid</li> </ul> <p>Before you can begin using GitHub, you need to create an SSH key pair on an <code>ecelinux</code> machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. The course setup script takes care of creating an SSH key pair which you can use. Login to an <code>ecelinux</code> machine, source the course setup script, and then view the contents of your public key using the following commands:</p> <pre><code>% source setup-ece2300.sh\n% cat ~/.ssh/ece2300-github.pub\n</code></pre> <p>Use the following page to upload the public key to GitHub:</p> <ul> <li>https://github.com/settings/ssh</li> </ul> <p>Click on New SSH Key, and then cut-and-paste the public key you displayed using <code>cat</code> into the key textbox. Give the key the title \"ece2300-github\". Then click Add SSH key. To test things out try the following on an <code>ecelinux</code> machine.</p> <pre><code>% ssh -T git@github.com\n</code></pre> <p>You may see a warning about the authenticity of the host. Don't worry, this is supposed to happen the first time you access GitHub using your new key. Just enter \"yes\". The GitHub server should output some text including your GitHub username. Verify that the GitHub username is correct, and then you should be all set. There are two good GitHub Guides you might want to take a look at:</p> <ul> <li>https://guides.github.com/activities/hello-world</li> <li>https://guides.github.com/introduction/flow</li> </ul> <p>GitHub has two integrated tools that students might find useful: an issue tracker and a wiki. Consider using the GitHub issue tracker to track bugs you find in your code or to manage tasks required to complete the lab assignment. You can label issues, comment on issues, and attach them to commits. See the following links for more information about GitHub issues:</p> <ul> <li>https://help.github.com/articles/about-issues</li> </ul> <p>Consider using the GitHub per-repository wiki to create task lists, brainstorm design ideas, rapidly collaborate on text for the lab assignment report, or keep useful command/code snippets. See the following links for more information about GitHub wikis:</p> <ul> <li>https://help.github.com/articles/about-github-wikis</li> </ul>"},{"location":"ece2300-tut02-git/#2-git-and-github","title":"2. Git and GitHub","text":"<p>In this section, we begin with a basic single-user workflow before demonstrating how Git and Github can be used for effective collaboration among multiple users. We discuss how to resolve conflicts and how to manage branches and pull requests.</p>"},{"location":"ece2300-tut02-git/#21-single-user-workflow","title":"2.1. Single-User Workflow","text":"<p>In this section, we cover some basic Git commands and illustrate a simple Git workflow. We have created a Git repository that we will be using as an initial template, so the first step is to fork this tutorial repository. Forking is the process of making a personal copy of someone else's repository on GitHub. Start by going to the GitHub page for the tutorial repository located here:</p> <ul> <li>https://github.com/cornell-ece2300/ece2300-tut02-git</li> </ul> <p></p> <p>Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a brand new repository in your account:</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git</li> </ul> <p>Where <code>githubid</code> is your GitHub username on the public version of GitHub. Now that you have your own copy of the tutorial repository, the next step is to clone this repository to an <code>ecelinux</code> machine so you can manipulate the content within the repository. We call the repository on GitHub the remote repository and we call the repository on the <code>ecelinux</code> machine the local repository. A local repository is a first-class mirror of the remote repository with the entire history of the repository, and thus almost all operations are essentially local requiring no communication with GitHub. The following commands write an environment variable with your GitHub username, create a subdirectory for this tutorial in your home directory before using the <code>git clone</code> command to clone the remote repository and thus create a local repository.</p> <pre><code>% source setup-ece2300.sh\n% GITHUBID=\"githubid\"\n% mkdir -p ${HOME}/ece2300\n% cd ${HOME}/ece2300\n% git clone git@github.com:${GITHUBID}/ece2300-tut02-git tut02\n% cd tut02\n% TUTROOT=${PWD}\n</code></pre> <p>Where again <code>githubid</code> is your GitHub username on the public version of GitHub. The <code>git clone</code> command takes two command line arguments. The first argument specifies the remote repository on GitHub you would like to clone, and the second argument specifies the name to give to the new local repository. Note that we created an environment variable with the directory path to the local repository to simplify navigating the file system in the rest of this tutorial.</p> <p>The repository currently contains two files: a <code>README</code> file, and <code>overview.txt</code> which contains an overview of the course. These files are contained within what we call the working directory. The repository also includes a special directory named <code>.git</code> which contains all of the extra repository metadata. You should never directly manipulate anything within the <code>.git</code> directory.</p> <pre><code>% cd ${TUTROOT}\n% ls -la\n</code></pre> <p>Let's assume we want to create a new file that contains a list of fruits, and that we want to manage this file using Git version control. First, we create the new file.</p> <pre><code>% cd ${TUTROOT}\n% echo \"apple\" &gt; fruit.txt\n</code></pre> <p>To manage a file using Git, we need to first use the <code>git add</code> command to tell Git that it should track this file from now on. We can then use <code>git commit</code> to commit our changes to this file into the repository, and <code>git log</code> to confirm the result.</p> <pre><code>% cd ${TUTROOT}\n% git add fruit.txt\n% git commit -m \"initial fruit list\"\n% git log\n</code></pre> <p>The <code>-m</code> command line option with the <code>git commit</code> command enables you to specify a commit message that describes this commit. All commit messages should include a \"subject line\" which is a single short line briefly describing the commit. Many commits will just include a subject line (e.g., the above commit). If you want to include more information in your commit message then skip the <code>-m</code> command line option and Git will launch Nano. You still want to include a subject line at the top of your commit message, but now you can include more information separated from the subject line by a blank line.</p> <p>Note, you can learn about any Git command and its usage by typing <code>git help command</code>, where <code>command</code> should be substituted by the actual name of the command. This would display the output similar to the manual pages for a Linux command, as seen in Tutorial 1. Students are encouraged to learn more about each Git command beyond the details covered in this tutorial.</p> <p>The <code>git log</code> command displays information about the commit history. The beginning of the output from <code>git log</code> should look something like this:</p> <pre><code>commit a8ac41ea8dba1371888ec7a2341f79de20521a4d (HEAD -&gt; main)\nAuthor: cb &lt;cb535@cornell.edu&gt;\nDate:   Mon Sep 2 13:17:32 2024 -0400\n\n    initial fruit list\n</code></pre> <p>Conceptually, we should think of each commit as a copy of all of the tracked files in the project at the time of the commit. This commit just included changes to one file, but as we add more files each commit will include more and more information. The history of a git repository is just a long sequence of commits that track how the files in the repository have evolved over time. Notice that Git has recorded the name of who made the commit, the date and time of the commit, and the log message. The first line is the commit id which uniquely identifies this commit. Git does not use monotonically increasing revision numbers like other version control systems, but instead uses a 40-digit SHA1 hash as the commit id. This is a hash of all the files included as part of this commit (not just the changes). We can refer to a commit by the full hash or by just the first few digits as long as we provide enough digits to unambiguously reference the commit. Now let's add a fruit to our list and commit the change.</p> <pre><code>% cd ${TUTROOT}\n% echo \"mango\" &gt;&gt; fruit.txt\n% git commit -m \"added mango to fruit list\"\n</code></pre> <p>Unfortunately, this doesn't work. The output from <code>git commit</code> indicates that there have been no changes since the last commit so there is no need to create a new commit. Git has a concept of an index which is different compared to other version control systems. We must \"stage\" files (really we stage content not files) into the index, and then <code>git commit</code> will commit that content into the repository. We can see this with the <code>git status</code> command.</p> <pre><code>% cd ${TUTROOT}\n% git status\n</code></pre> <p>which should show that <code>fruit.txt</code> is modified but not added to the index. We stage files in the index with <code>git add</code> like this:</p> <pre><code>% cd ${TUTROOT}\n% git add fruit.txt\n% git status\n</code></pre> <p>Now <code>git status</code> should show that the file is modified and also added to the index. Our commit should now complete correctly.</p> <pre><code>% cd ${TUTROOT}\n% git commit -m \"added mango to fruit list\"\n% git status\n</code></pre> <p>So even though Git is tracking <code>fruit.txt</code> and knows it has changed, we still must explicitly add the files we want to commit. You definitely want to avoid using something like <code>git add .</code> to add all files, since this will inevitably end up adding files that you don't really want to commit. There is a short cut which uses the <code>-a</code> command line option with the <code>git commit</code> command. This command line option tells Git to add any file which has changed and was previously added to the repository before doing the commit.</p> <pre><code>% cd ${TUTROOT}\n% echo \"orange\" &gt;&gt; fruit.txt\n% git commit -a -m \"added orange to fruit list\"\n% git status\n</code></pre> <p>Staging files is a useful way to preview what we will commit before we actually do the commit. This helps when we have many changes in our working directory but we don't want to commit them all at once. Instead we might want to break them into smaller, more meaningful commits or we might want to keep working on some of the modified files while committing others.</p> <p>The following figure illustrates how the commands we have used so far create a single-user development workflow. The <code>git clone</code> command copies the remote repository to create a local repository which includes both the working directory and the special <code>.git</code> directory. The <code>git add</code> command adds files to the index from the working directory. The <code>git commit</code> command moves files from the index into the special <code>.git</code> directory. The <code>-a</code> command line option with the <code>git commit</code> command can commit files directly from the working directory to the special <code>.git</code> directory.</p> <p></p> <p>Now that we have made some changes, we can use <code>git log</code> to view the history of last few commits and then add another line to the <code>fruit.txt</code> file.</p> <pre><code>% cd ${TUTROOT}\n% git log\n% echo \"plum\" &gt;&gt; fruit.txt\n% cat fruit.txt\n</code></pre> <p>Imagine you didn't like your changes and want to revert the changes, you would use the <code>git checkout</code> command as below.</p> <pre><code>% cd ${TUTROOT}\n% git checkout fruit.txt\n% cat fruit.txt\n</code></pre> <p>As illustrated in the above single-user development workflow figure, the <code>git checkout</code> command resets any a file or directory to the state it was in at the time of the last commit. The output from the <code>git status</code> command should look something like this:</p> <pre><code>% cd ${TUTROOT}\n% git status\n On branch main\n Your branch is ahead of 'origin/main' by 3 commits.\n   (use \"git push\" to publish your local commits)\n nothing to commit, working directory clean\n</code></pre> <p>The <code>git status</code> command is telling us that the local clone of the repository now has more commits than the remote repository on GitHub. If you visit the GitHub page for this repository you will not see any changes. This is a critical difference from other centralized version control systems. In Git, when we use the <code>git commit</code> command it only commits these changes to your local repository.</p> <p>If we have done some local work that we are happy with, we can push these changes to the remote repository on GitHub using the <code>git push</code> command.</p> <pre><code>% cd ${TUTROOT}\n% git push\n% git status\n</code></pre> <p>Notice that the output of the <code>git status</code> command indicates that our local repository is up-to-date with the remote repository on GitHub. The above single-user development workflow figure shows visually the idea that the <code>git push</code> command moves commits from your local repository to the remote repository on GitHub. Visit the GitHub page to verify that our new commits have been pushed to the remote repository:</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git</li> </ul> <p>Click on commits at the top of the GitHub page to view the log of commits. You can browse who made each commit, what changed in each commit, and the state of the repository at each commit. Return to the main GitHub page for the repository and click on the <code>fruit.txt</code> file to view it.</p> <p>Activity 1: Experiment with Commiting Files</p> <p>Create a new file called <code>shapes.txt</code> that includes a list of different shapes. Commit the new file, make some edits, and commit these edits. Use <code>git status</code> and <code>git log</code> to keep track of your changes. Push your changes to GitHub and browse the updated files on GitHub.</p>"},{"location":"ece2300-tut02-git/#22-multi-user-workflow","title":"2.2. Multi-User Workflow","text":"<p>Since your tutorial repository is public on GitHub, any other user can also clone this repository. If you would like to collaborate with another GitHub user, you would need to give that user read/write permission. The instructors will take care of setting up the appropriate teams for the lab assignments when you work with a partner. To emulate how collaboration with GitHub works, we will \"pretend\" to be different users by cloning extra copies of the tutorial repository.</p> <pre><code>% cd ${HOME}/ece2300\n% git clone git@github.com:${GITHUBID}/ece2300-tut02-git tut02-alice\n% cd tut02-alice\n% ALICE=${PWD}\n% cd ${HOME}/ece2300\n% git clone git@github.com:${GITHUBID}/ece2300-tut02-git tut02-bob\n% cd tut02-bob\n% BOB=${PWD}\n</code></pre> <p>We can now emulate different users by simply working in these different local repositories: when we work in <code>ALICE</code> we will be acting as the user Alice, and when we work in <code>BOB</code> we will be acting as the user Bob. The following figure illustrates a multi-user development environment: both Alice and Bob have their own separate local repositories (including their own working directories, index, and special <code>.git</code> directories), yet they will both communicate with the same centralized remote repository on GitHub.</p> <p></p> <p>Let's have Alice add another entry to the <code>fruit.txt</code> file, commit her changes to her local repository, and then push those commits to the remote repository on GitHub:</p> <pre><code>% cd ${ALICE}\n% echo \"banana\" &gt;&gt; fruit.txt\n% git commit -a -m \"ALICE: added banana to fruit list\"\n% git log --oneline\n% git push\n% cat fruit.txt\n</code></pre> <p>If you view the GitHub page for this repository it will appear that you are the one making the commit (remember we are just pretending to be Alice), which is why we used <code>ALICE:</code> as a prefix in the commit message.</p> <p>Now let's assume Bob wants to retrieve the changes that Alice just made to the repository. Bob can use the <code>git pull</code> command to pull all new commits from the remote repository into his local repository. The <code>git pull</code> command performs two actions, it first fetches all the updates and then merges or applies them to the local project. If there are no conflicts in the file contents, the command executes successfully. If there are conflicts, the command does not merge all the changes and reports the conflicting content. We will learn how to resolve conflicts in a later section.</p> <pre><code>% cd ${BOB}\n% git pull\n% git log --oneline\n% cat fruit.txt\n</code></pre> <p>The multi-user development workflow figure shows visually the idea that the <code>git pull</code> command moves commits from the remote repository on GitHub to your local repository. Bob's copy of tutorial repository should contain Alice's most recent commit and his copy of the <code>fruits.txt</code> file should include <code>banana</code>. Now let's assume Bob also wants to make some changes and push those changes to the remote repository on GitHub:</p> <pre><code>% cd ${BOB}\n% echo \"peach\" &gt;&gt; fruit.txt\n% git commit -a -m \"BOB: added peach to fruit list\"\n% git log --oneline\n% git push\n% cat fruit.txt\n</code></pre> <p>Similar to before, Alice can now retrieve the changes that Bob just made to the repository using the <code>git pull</code> command.</p> <pre><code>% cd ${ALICE}\n% git pull\n% git log --oneline\n% cat fruit.txt\n</code></pre> <p>This process is at the key to collaborating via GitHub. Each student works locally on his or her part of the lab assignment and periodically pushes/pulls commits to synchronize with the remote repository on GitHub.</p> <p>Activity 2: Experimenting with a Multi-User Workflow</p> <p>Create a new file called <code>letters.txt</code> in Bob's local repository that includes a list of letters from A to M, one per line. Commit the new file, make some edits to add say more letters from say M to Z, and commit these edits. Use <code>git push</code> to push these commits to the centralized repository. Switch to Alice's local repository and use <code>git pull</code> to pull in the new commits. Verify that all of your files and commits are in both Bob's and Alice's local repositories.</p>"},{"location":"ece2300-tut02-git/#23-resolving-conflicts","title":"2.3. Resolving Conflicts","text":"<p>Of course the real challenge occurs when both Alice and Bob modify content at the same time. There are two possible scenarios: Alice and Bob modify different content such that it is possible to combine their commits without issue, or Alice and Bob have modified the exact same content resulting in a conflict. We will address how to resolve both scenarios.</p> <p>Let us assume that Alice wants to add <code>lemon</code> to the list and Bob would like to create a new file named <code>vegetables.txt</code>. Alice would go ahead and first pull from the central repository to grab any new commits from the remote repository on GitHub. On seeing that there are no new commits, she edits the file, commits, and pushes this new commit.</p> <pre><code>% cd ${ALICE}\n% git pull\n% echo \"lemon\" &gt;&gt; fruit.txt\n% git commit -a -m \"ALICE: added lemon to fruit list\"\n% git push\n</code></pre> <p>Since Bob recently pulled from the remote repository on GitHub, let's say he assumes that there have been no new commits. He would then go ahead and create his new file, commit, and attempt to push this new commit.</p> <pre><code>% cd ${BOB}\n% echo \"spinach\"  &gt;  vegetables.txt\n% echo \"broccoli\" &gt;&gt; vegetables.txt\n% echo \"turnip\"   &gt;&gt; vegetables.txt\n% git add vegetables.txt\n% git commit -m \"BOB: initial vegetable list\"\n% git push\n To git@github.com:githubid/ece2300-tut02-git\n  ! [rejected]        main -&gt; main (fetch first)\n error: failed to push some refs to 'git@github.com:githubid/ece2300-tut02-git'\n hint: Updates were rejected because the remote contains work that you do\n hint: not have locally. This is usually caused by another repository pushing\n hint: to the same ref. You may want to first integrate the remote changes\n hint: (e.g., 'git pull ...') before pushing again.\n hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n</code></pre> <p>On executing the sequence of commands above, you should notice that Git does not allow Bob to push his changes to the central repository as the version of the central repository has been updated by Alice. You should see a message similar to the one above. Git suggests us to merge the remote commits before pushing the local commits. We can do so by first using the <code>git pull</code> command to merge the local commits.</p> <pre><code>% cd ${BOB}\n% git pull\n</code></pre> <p>Git will launch Nano because we need to merge your local commits and the remote commits. You will need to enter a commit message, although usually the default message provided by Git is fine. We can take a look at the Git history using <code>git log</code> to see what happened.</p> <pre><code>% cd ${BOB}\n% git log --oneline --graph\n *   f5c1361 (HEAD -&gt; main) Merge branch 'main' of github.com:githubid/ece2300-tut02-git\n |\\\n | * c13f30e (origin/main, origin/HEAD) ALICE: added lemon to fruit list\n * | 3ef8c85 BOB: initial vegetable list\n |/\n * 5877142 BOB: added peach to fruit list\n * 7896fff ALICE: added banana to fruit list\n</code></pre> <p>The <code>--graph</code> command line option with the <code>git log</code> command will display a visual graph of the commit history. You can see that Bob and Alice worked on two different commits at the same time. Alice worked on commit <code>c13f30e</code> while Bob was working on commit <code>3ef8c85</code>. Bob then merged these two sets of commits using a new commit <code>f5c1361</code>. Your exact commit hashes might be different. Bob can now push his changes to the remote repository in GitHub.</p> <pre><code>% cd ${BOB}\n% git push\n</code></pre> <p>GitHub has a nice commit history viewer which shows a similar commit graph as we saw above:</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git/network</li> </ul> <p>Sometimes Alice and Bob are editing the exact same lines in the exact same file. In this case, Git does not really know how to resolve this conflict. It does not know how to merge the two sets of commits to create a consistent view of the repository. The user will have to manually resolve the conflict. Let's explore what happens when Alice and Bob want to add a new fruit to the <code>fruits.txt</code> file at the exact same time. First, Alice adds <code>kiwi</code> and pushes her updates to the remote repository on GitHub.</p> <pre><code>% cd ${ALICE}\n% git pull\n% echo \"kiwi\" &gt;&gt; fruit.txt\n% git commit -a -m \"ALICE: added kiwi to fruit list\"\n% git push\n</code></pre> <p>Now Bob adds <code>date</code> and tries to push his update to the remote repository on GitHub.</p> <pre><code>% cd ${BOB}\n% echo \"date\" &gt;&gt; fruit.txt\n% git commit -a -m \"BOB: added date to fruit list\"\n% git push\n To git@github.com:githubid/ece2300-tut02-git\n  ! [rejected]        main -&gt; main (fetch first)\n</code></pre> <p>Let's see what happens if Bob uses the <code>git pull</code> command to pull and merge the commits from the remote repository on GitHub.</p> <pre><code>% cd ${BOB}\n% git pull\n Unpacking objects: 100% (3/3), done.\n From github.com:cbatten/ece2300-tut02-git\n    f5c1361..3d43934  main     -&gt; origin/main\n Auto-merging fruit.txt\n CONFLICT (content): Merge conflict in fruit.txt\n Automatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>Git indicates that it was not able to complete the merge. There is a conflict in the <code>fruit.txt</code> file. We can also use the <code>git status</code> command to see which files have conflicts. They will be marked as <code>both modified</code>:</p> <pre><code>% cd ${BOB}\n% git status\n</code></pre> <p>Git instructs Bob to first resolve the conflict and then use the <code>git commit</code> command to finish the merge. If you take a look at the <code>fruit.txt</code> file you will see that it now includes conflict markers showing exactly where the conflict occurred.</p> <pre><code>% cd ${BOB}\n% cat fruit.txt\n apple\n mango\n orange\n banana\n peach\n lemon\n &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n date\n =======\n kiwi\n &gt;&gt;&gt;&gt;&gt;&gt;&gt; 3d43934f045d6ab3c354893a97fd4967997bcb35\n</code></pre> <p>This shows that the commit from the local repository has <code>date</code> on the last line in the file, while the remote repository on GitHub has <code>kiwi</code> as the last line in the file. To resolve the conflict we can directly edit this file so that it reflects how we want to merge. We can choose one fruit over the other, choose to include neither fruit, or choose to include both fruit. Edit the file using VS Code to remove the lines with markers <code>&lt;&lt;&lt;&lt;</code>, <code>===</code>, and <code>&gt;&gt;&gt;&gt;</code> so that the file includes both fruit.</p> <pre><code>% cd ${BOB}\n% code fruit.txt\n% cat fruit.txt\n apple\n mango\n orange\n banana\n peach\n lemon\n date\n kiwi\n</code></pre> <p>Now that we have resolved the conflict we just need to commit these new changes.</p> <pre><code>% cd ${BOB}\n% git status\n% git commit -a -m \"fixed conflict\"\n% git push\n% git status\n% git log --oneline --graph\n</code></pre> <p>Resolving conflicts is tedious, so to avoid conflicts you should communicate with your group members which student is going to be executing which files. Try to avoid having multiple students working on the same file at the same time, or at least avoid having multiple students working on the same lines of the same file at the same time.</p> <p>Activity 3: Experimenting with Resolving Conflicts</p> <p>Experiment with both Alice and Bob editing the same lines in the <code>overview.txt</code> file at the same time. Try to force a conflict, and then carefully resolve the conflict.</p>"},{"location":"ece2300-tut02-git/#24-branches-and-pull-requests","title":"2.4. Branches and Pull Requests","text":"<p>In this section, we describe branches and pull requests which are slightly more advanced topics but tremendously useful. Students could probably skim this section initially, and then revisit this information later in the semester. Branches and pull requests enable different students to work on different aspects at the project at the same time while keeping their commits separated in the remote repository on GitHub. So far, all of our work has been on the main branch. The main branch is the primary default branch. Creating additional branches can enable one student to work on a new feature while also fixing bugs on the main branch, or branches can enable students to experiment with some more advanced ideas but easily revert back to the \"stable\" main branch.</p> <p>Let's say that Alice wants to work on a new list of animals in Alice and Bob's shared repository, but she wants to keep her work separate from the primary work they are focusing on. Alice can create a branch called <code>alice-animals</code> and commit her new ideas on that branch. It is usually good practice to prefix branch names with your NetID to ensure that branch names are unique. The following commands will first display the branches in the local repository using the <code>git branch</code> command before creating a new branch called <code>alice-animals</code>.</p> <pre><code>% cd ${ALICE}\n% git pull\n% git branch\n% git checkout -b alice-animals\n% git branch\n% git status\n</code></pre> <p>The <code>git branch</code> command uses an asterisk (<code>*</code>) to indicate the current branch. The <code>git status</code> command also indicates the current branch. Alice can now create a new file and commit her changes to this new branch.</p> <pre><code>% cd ${ALICE}\n% git branch\n% echo \"cow\"  &gt; animals.txt\n% echo \"pig\" &gt;&gt; animals.txt\n% echo \"dog\" &gt;&gt; animals.txt\n% git add animals.txt\n% git commit -m \"ALICE: initial animal list\"\n% git log --oneline --graph\n</code></pre> <p>It should be clear that the <code>alice-animals</code> branch is one commit ahead of the <code>main</code> branch. Pushing this branch to the remote repository on GitHub requires a slightly more complicated syntax. We need to specify which branch to push to which remote repository:</p> <pre><code>% cd ${ALICE}\n% git push -u origin alice-animals\n% cat animals.txt\n</code></pre> <p>The name <code>origin</code> refers to the remote repository that the local repository was originally cloned from (i.e., the remote repository on GitHub). You can now see this new branch on GitHub here:</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git/branches</li> </ul> <p>You can browse the commits and source code in the <code>alice-animals</code> just like the <code>main</code> branch. If Bob wants to checkout Alice's new branch, he needs to use a slightly different syntax.</p> <pre><code>% cd ${BOB}\n% git pull\n% git checkout --track origin/alice-animals\n% git branch\n% cat animals.txt\n</code></pre> <p>Alice and Bob can switch back to the <code>main</code> branch using the <code>git checkout</code> command.</p> <pre><code>% cd ${ALICE}\n% git checkout main\n% git branch\n% ls\n% cd ${BOB}\n% git checkout main\n% git branch\n% ls\n</code></pre> <p>The <code>git branch</code> command should indicate that both Alice and Bob are now on the <code>main</code> branch, and there should no longer be an <code>animals.txt</code> file in the working directory. One strength of Git is that it makes it very easy to switch back and forth between branches.</p> <p>Once Alice has worked on her new branch, she might be ready to merge that branch back into the <code>main</code> branch so it becomes part of the primary project. GitHub has a nice feature called pull requests that simply this process. To create a pull request, Alice would first go to the branch page on GitHub for this repository.</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git/branches</li> </ul> <p>She then just needs to click on the three dots next to her branch and choose New pull request. You must carefully select the base fork! If you simply choose the default you will try to merge your branch into the repository that is part of the <code>cornell-ece2300</code> GitHub organization. Click on base fork and select githubid/ece2300-tut02-git. Alice can leave a comment about what this new branch does. Other students can use the pull request page on GitHub to comment on and monitor the new branch.</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git/pull/1</li> </ul> <p>Users can continue to develop and work on the branch until it is ready to be merged into <code>main</code>. When the pull request is ready to be accepted, a user simply clicks on Merge pull request on the GitHub pull request page. When this is finished the Git history for this example would look like this:</p> <pre><code>% cd ${ALICE}\n% git pull\n% git log --oneline --graph\n*   3e523c8 (HEAD -&gt; main, origin/main, origin/HEAD) Merge pull request #1 fr&gt;\n|\\\n| * 651eb8c (origin/alice-animals, alice-animals) ALICE: initial animal list\n|/\n*   e6c85c3 fixed conflict\n|\\\n| * 3d43934 ALICE: added kiwi to fruit list\n* | 9d12ba9 BOB: added date to fruit list\n|/\n*   f5c1361 Merge branch 'main' of github.com:cbatten/ece2300-tut02-git\n|\\\n| * c13f30e ALICE: added lemon to fruit list\n* | 3ef8c85 BOB: initial vegetable list\n|/\n* 5877142 BOB: added peach to fruit list\n* 7896fff ALICE: added banana to fruit list\n* bf6a25f added orange to fruit list\n* bc0e024 added mango to fruit list\n* a8ac41e initial fruit list\n* bb9506b initial import\n</code></pre> <p>Activity 4: Experimenting with Branches</p> <p>Have Bob create his own branch for development, and then create a new file named <code>states.txt</code> with the names of states. Have Bob commit his changes to a new branch and push this branch to the remote repository on GitHub. Finally, have Alice pull this new branch into her local repository.</p>"},{"location":"ece2300-tut02-git/#3-github-actions-for-continuous-integration","title":"3. GitHub Actions for Continuous Integration","text":"<p>GitHub Actions is an online continuous integration service that is integrated within GitHub. GitHub Actions will automatically run all tests for a student's lab assignment every time the students push their code to GitHub. We will be using the results reported by GitHub Actions to evaluate the code functionality of the lab assignments. In this section, we do a small experiment to illustrate how GitHub Actions work.</p> <p>GitHub Actions looks for specials file in the <code>.github/workflows</code> subdirectory in the top of your repository to determine how to build and test your project. We have already created one of those files for you, and you can see it here:</p> <pre><code>% cd ${TUTROOT}\n% cat .github/workflows/git-tutorial.yml\n</code></pre> <p>The <code>git-tutorial.yml</code> file for this tutorial is very simple. It just uses the <code>grep</code> command to check if the fruit <code>blueberry</code> is in the <code>fruit.txt</code> file. If the <code>blueberry</code> is present then the test passes, otherwise the test fails. Click on the Actions tab in your repository on GitHub and click I understand my workflows, go ahead and enable them as shown in the following figure.</p> <p></p> <p>Let's add <code>melon</code> to the list of fruits in our local repository and then push the corresponding commit to the remote repository on GitHub.</p> <pre><code>% cd ${TUTROOT}\n% git pull\n% echo \"melon\" &gt;&gt; fruit.txt\n% git commit -a -m \"added melon to fruit list\"\n% git push\n</code></pre> <p>Notice how we first use the <code>git pull</code> command to ensure our local repository has all of the commits from the remote repository on GitHub. To see the results of the workflow run go to the Actions tab for the corresponding repository on GitHub. You can also use a link like this:</p> <ul> <li>https://github.com/githubid/ece2300-tut02-git/actions</li> </ul> <p>where <code>githubid</code> is your GitHub username on the public version of GitHub. You should be able to see a list of workflow runs as illustrated below.</p> <p></p> <p>Each run corresponds to a push to GitHub. A green checkmark means that run passed, while a red X means that run failed. If you click on the name of a run, and then click on check you can see a list of steps that GitHub actions ran. Click on the little <code>&gt;</code> next to Run grep blueberry fruit.txt to see the output from running <code>grep</code>.</p> <p></p> <p>The test should fail because <code>blueberry</code> is not currently in the <code>fruit.txt</code> file. Now let's add <code>blueberry</code> and then push the corresponding to commit to trigger another build on GitHub Actions.</p> <pre><code>% cd ${TUTROOT}\n% echo \"blueberry\" &gt;&gt; fruit.txt\n% git commit -a -m \"added blueberry to fruit list\"\n% git push\n</code></pre> <p>If you revisit the GitHub Actions page for this repository, you should now see that the check has passed!</p> <p>Using GitHub Actions to perform continuous integration testing is a key component of an agile development methodology. It means the entire group can quickly spot commits which break certain tests, and always be certain that their <code>main</code> branch is passing all tests before submitting the lab assignment. The course staff will actually be using GitHub Actions to grade your lab assignments. The staff will be able to look at the build log in GitHub Actions to see if your assignment is passing your own test suite, and then the staff can add more tests to see if your assignment passes a more exhaustive test suite.</p> <p>Activity 5: Experimenting with GitHub Actions</p> <p>Edit the <code>git-tutorial.yml</code> file to search for <code>apple</code> instead. Experiment with removing and adding <code>apple</code> from the <code>fruits.txt</code> file to see the tests on GitHub Actions pass and fail.</p>"},{"location":"ece2300-tut02-git/#4-course-specific-git-scripts","title":"4. Course-Specific Git Scripts","text":"<p>This section describes some useful scripts we have installed that make it easier to use Git. Each script is invoked by typing the name along with the standard <code>git</code> command.</p>"},{"location":"ece2300-tut02-git/#41-using-git-xstatus-to-compactly-see-status-information","title":"4.1. Using <code>git xstatus</code> to Compactly See Status Information","text":"<p>The <code>git xstatus</code> command produces a status output somewhat similar to subversion's status command. It first shows the status of all tracked files which are modified, deleted, or added, then shows the status of all files in the index (marked with an asterisk), and finally shows which files and directories are untracked. Here is an example output:</p> <pre><code>% cd ${TUTROOT}\n% echo \"cyan\" &gt;&gt; colors.txt\n% echo \"rabbit\" &gt;&gt; animals.txt\n% git add colors.txt animals.txt\n% git commit -m \"added some colors and animals\"\n% echo \"grape\" &gt;&gt; fruit.txt\n% git add fruit.txt\n% echo \"strawberry\" &gt;&gt; fruit.txt\n% echo \"bird\" &gt;&gt; animals.txt\n% echo \"tulip\"  &gt;&gt; flowers.txt\n% rm colors.txt\n% git xstatus\n  M animals.txt\n  D colors.txt\n  M fruit.txt\n *M fruit.txt\n  ? flowers.txt\n</code></pre> <p>This shows that the file <code>colors.txt</code> has been deleted from the working directory, but this deletion has not been added to the index yet (<code>colors.txt</code> is not listed with an asterisk). The file <code>animals.txt</code> has been modified buy not added to the index yet. Note that the file named <code>fruit.txt</code> has been modified and added to the index, but it has been modified since it was added to the index as indicated by its double listing. The file named <code>flowers.txt</code> is currently untracked.</p> <p>The possible status codes are as follows:</p> <pre><code> - A : addition of a file\n - C : copy of a file into a new one\n - D : deletion of a file\n - M : modification of the contents or mode of a file\n - R : renaming of a file\n - T : change in the type of the file\n - U : file is unmerged (you must complete the merge before commit)\n - ? : file is untracked (you need to add it if you want to track it)\n</code></pre>"},{"location":"ece2300-tut02-git/#42-using-git-xadd-to-add-all-changed-files","title":"4.2. Using <code>git xadd</code> to Add All Changed Files","text":"<p>The <code>git xadd</code> command adds all files which are currently tracked and display the new status in a format similar to the <code>git xstatus</code> command. You can use this to quickly stage files for commit and see what would be committed before actually executing the commit.</p> <pre><code>% cd ${TUTROOT}\n% git xstatus\n% git xadd\n</code></pre>"},{"location":"ece2300-tut02-git/#43-using-git-xlog-to-compactly-see-log-information","title":"4.3. Using <code>git xlog</code> to Compactly See Log Information","text":"<p>The <code>git xlog</code> command displays a compact log format with one commit per line and a graph representing the commit history. This script passes along whatever the additional options are included straight onto <code>git log</code>. Here is a simple example of the log output.</p> <pre><code>% cd ${TUTROOT}\n% git xlog\n* be57e36 cb added some colors and animals\n* d2c0ecd cb added blueberry to fruit list\n* 1e4792f cb added melon to fruit list\n*   3e523c8 cb Merge pull request #1 from cbatten/alice-animals\n|\\\n| * 651eb8c cb ALICE: initial animal list\n|/\n*   e6c85c3 cb fixed conflict\n|\\\n| * 3d43934 cb ALICE: added kiwi to fruit list\n* | 9d12ba9 cb BOB: added date to fruit list\n|/\n*   f5c1361 cb Merge branch 'main' of github.com:cbatten/ece2300-tut02-git\n|\\\n| * c13f30e cb ALICE: added lemon to fruit list\n</code></pre> <p>You can see one line per commit along with the commit hash, the committer's name, and the short commit message. The graph shows a merge between commits <code>3d43934</code> and <code>6ee31c69d12ba9</code>.</p>"}]}